(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],p=0,d=[];p<s.length;p++)o=s[p],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&d.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(u&&u(e);d.length;)d.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"ef3c19d7",3:"6c751b76",4:"170dc5c6",5:"941beff0",6:"33bdde04",7:"9ae02016",8:"d7f28a1b",9:"e1a97372",10:"d0da2d00",11:"094af0f7",12:"087d9d64",13:"9f74cedd",14:"075bc1e8",15:"352de9d0",16:"1037707a",17:"da7d69e2",18:"5c679ebf",19:"8da6f713",20:"09f3e31f",21:"93f96fbf",22:"c8e72392",23:"aa348d71",24:"6a58329b",25:"d1acb113",26:"aa1aadad",27:"9f15bea7",28:"3384d2d9",29:"9c56cf5b",30:"dcd74553",31:"4ff1e8f6",32:"62381306",33:"dc513db8",34:"8b3a337d",35:"04568da7",36:"51783946",37:"1badf864",38:"05ea371a",39:"3d598867",40:"8e2b0352",41:"bb444122",42:"62192483",43:"83ccc5c4",44:"90daf435",45:"301b681c",46:"0e827cce",47:"eedca947",48:"6acf7c92",49:"21eb7836",50:"c3943321",51:"7225b235",52:"d6e0bf51",53:"7a8b511d",54:"6902bb99",55:"f3608dae"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;i.push([103,0]),t()}([function(n,e,t){var a=t(56),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var a=t(2);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(14),r=t(52);n.exports=function(n){if("Function"===a(n))return r(n)}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(4),r=t(31),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(0),r=t(56),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(162),r=t(165);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return f})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(16);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function d(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:p(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function f(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return h(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?h(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function h(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(15),r=t(147),i=t(148),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(52),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(6).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(27),r=t(31),i=t(32),o=t(128),s=t(130),l=t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)})),c=!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}();a({target:"Array",proto:!0,arity:1,forced:l||c},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var a=t(3),r=t(65),i=t(99),o=t(26),s=t(55),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=u(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(1),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(3),r=t(17),i=t(34);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(152),r=t(153),i=t(154),o=t(155),s=t(156);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(174);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(44);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),u=a.speed,p=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),u=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&d(r),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function u(n,e){var t,a=p(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(1),r=t(51).f,i=t(19),o=t(111),s=t(36),l=t(66),c=t(124);n.exports=function(n,e){var t,u,p,d,m,f=n.target,h=n.global,g=n.stat;if(t=h?a:g?a[f]||s(f,{}):(a[f]||{}).prototype)for(u in e){if(d=e[u],p=n.dontCallGetSet?(m=r(t,u))&&m.value:t[u],!c(h?u:f+(g?".":"#")+u,n.forced)&&void 0!==p){if(typeof d==typeof p)continue;l(d,p)}(n.sham||p&&p.sham)&&i(d,"sham",!0),o(t,u,d,n)}}},function(n,e,t){var a=t(2);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(46),r=t(53);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(1),r=t(62),i=t(8),o=t(64),s=t(60),l=t(59),c=r("wks"),u=a.Symbol,p=u&&u.for,d=l?u:u&&u.withoutSetter||o;n.exports=function(n){if(!i(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&i(u,n)?c[n]=u[n]:c[n]=l&&p?p(e):d(e)}return c[n]}},function(n,e,t){var a=t(53),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(122);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(28),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(1),r=t(36),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(146),r=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(6),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(166),r=t(173),i=t(175),o=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),r=t(44),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(4),r=t(2),i=t(14),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e,t){var a=t(0),r=t(109),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,p=Math.max,d=Math.min,m=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(w,e),u?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=i}function w(){var n=m();if(x(n))return j(n);s=setTimeout(w,function(n){var t=e-(n-l);return g?d(t,i-(n-c)):t}(n))}function j(n){return s=void 0,v&&a?b(n):(a=r=void 0,o)}function S(){var n=m(),t=x(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(g)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=h(e)||0,f(t)&&(u=!!t.leading,i=(g="maxWait"in t)?p(h(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),S.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},S.flush=function(){return void 0===s?o:j(m())},S}},function(n,e,t){var a=t(3),r=t(33),i=t(105),o=t(34),s=t(29),l=t(55),c=t(8),u=t(65),p=Object.getOwnPropertyDescriptor;e.f=a?p:function(n,e){if(n=s(n),e=l(e),u)try{return p(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(28),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e,t){var a=t(54),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(106),r=t(57);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(18),r=t(0),i=t(58),o=t(59),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(4);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(60);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(61),r=t(2);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(1),o=t(107),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(r=(a=u.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(63),r=t(35);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.26.0",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(4),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(3),r=t(2),i=t(98);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(8),r=t(117),i=t(51),o=t(17);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,u=0;u<s.length;u++){var p=s[u];a(n,p)||t&&a(t,p)||l(n,p,c(e,p))}}},function(n,e,t){var a=t(121);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(4),r=t(26),i=t(134);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(20),r=t(157),i=t(158),o=t(159),s=t(160),l=t(161);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(13),r=t(39);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(178),r=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(77),r=t(181),i=t(78);n.exports=function(n,e,t,o,s,l){var c=1&t,u=n.length,p=e.length;if(u!=p&&!(c&&p>u))return!1;var d=l.get(n),m=l.get(e);if(d&&m)return d==e&&m==n;var f=-1,h=!0,g=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var v=n[f],b=e[f];if(o)var y=c?o(b,v,f,e,n,l):o(v,b,f,n,e,l);if(void 0!==y){if(y)continue;h=!1;break}if(g){if(!r(e,(function(n,e){if(!i(g,e)&&(v===n||s(v,n,t,o,l)))return g.push(e)}))){h=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var a=t(40),r=t(179),i=t(180);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(191),r=t(197),i=t(83);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(6),r=t(193),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(194),r=t(195),i=t(196),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(73),r=t(42);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(6),"Set");n.exports=a},function(n,e,t){var a=t(39);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(88),r=t(24);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(5),r=t(43),i=t(208),o=t(211);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(144),r=t(149),i=t(220),o=t(228),s=t(237),l=t(102),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(240),t(7)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(241),t(7)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(1),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(3),r=t(2);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(62),r=t(64),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(4),r=t(8),i=t(29),o=t(119).indexOf,s=t(48),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,u=[];for(t in a)!r(s,t)&&r(a,t)&&l(u,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(u,t)||l(u,t));return u}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(246)},function(n,e,t){"use strict";var a=t(27),r=t(125).left,i=t(126),o=t(61),s=t(127);a({target:"Array",proto:!0,forced:!i("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(33),r=t(9),i=t(57),o=t(108),s=t(110),l=t(30),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,u);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var a=t(18);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(47),r=t(54);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(33),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(17),i=t(112),o=t(36);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(2),r=t(0),i=t(8),o=t(3),s=t(113).CONFIGURABLE,l=t(114),c=t(115),u=c.enforce,p=c.get,d=Object.defineProperty,m=o&&!a((function(){return 8!==d((function(){}),"length",{value:8}).length})),f=String(String).split("String"),h=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||s&&n.name!==e)&&(o?d(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&i(t,"arity")&&n.length!==t.arity&&d(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?o&&d(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=u(n);return i(a,"source")||(a.source=f.join("string"==typeof e?e:"")),n};Function.prototype.toString=h((function(){return r(this)&&p(this).source||l(this)}),"toString")},function(n,e,t){var a=t(3),r=t(8),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(4),r=t(0),i=t(35),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,o=t(116),s=t(1),l=t(9),c=t(19),u=t(8),p=t(35),d=t(100),m=t(48),f=s.TypeError,h=s.WeakMap;if(o||p.state){var g=p.state||(p.state=new h);g.get=g.get,g.has=g.has,g.set=g.set,a=function(n,e){if(g.has(n))throw f("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},i=function(n){return g.has(n)}}else{var v=d("state");m[v]=!0,a=function(n,e){if(u(n,v))throw f("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return u(n,v)?n[v]:{}},i=function(n){return u(n,v)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw f("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(1),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(18),r=t(4),i=t(118),o=t(123),s=t(26),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(101),r=t(97).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(29),r=t(120),i=t(32),o=function(n){return function(e,t,o){var s,l=a(e),c=i(l),u=r(o,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(67),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(67),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(2),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==u||t!=c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(47),r=t(31),i=t(46),o=t(32),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var u=r(e),p=i(u),d=o(u),m=n?d-1:0,f=n?-1:1;if(l<2)for(;;){if(m in p){c=p[m],m+=f;break}if(m+=f,n?m<0:d<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:d>m;m+=f)m in p&&(c=t(c,p[m],m,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(2);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(14),r=t(1);n.exports="process"==a(r.process)},function(n,e,t){"use strict";var a=t(3),r=t(129),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(14);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(27),r=t(1),i=t(132),o=t(133),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(28),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(18),r=t(8),i=t(19),o=t(58),s=t(68),l=t(66),c=t(135),u=t(136),p=t(137),d=t(141),m=t(142),f=t(143),h=t(3),g=t(63);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),x=y[y.length-1],w=a.apply(null,y);if(w){var j=w.prototype;if(!g&&r(j,"cause")&&delete j.cause,!t)return w;var S=a("Error"),E=e((function(n,e){var t=p(v?e:n,void 0),a=v?new w(n):new w;return void 0!==t&&i(a,"message",t),f&&i(a,"stack",m(a.stack,2)),this&&o(j,this)&&u(a,this,E),arguments.length>b&&d(a,arguments[b]),a}));if(E.prototype=j,"Error"!==x?s?s(E,S):l(E,S,{name:!0}):h&&"stackTraceLimit"in w&&(c(E,w,"stackTraceLimit"),c(E,w,"prepareStackTrace")),l(E,w),!g)try{j.name!==x&&i(j,"name",x),j.constructor=E}catch(n){}return E}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(17).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(68);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(138);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(139),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(140),r=t(0),i=t(14),o=t(30)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(30)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(19);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(4),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(2),r=t(34);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(69),r=t(145);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var u=e[l];t>0&&i(u)?t>1?n(u,t-1,i,o,s):a(s,u):o||(s[s.length]=u)}return s}},function(n,e,t){var a=t(15),r=t(37),i=t(5),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(150),r=t(206),i=t(45),o=t(5),s=t(217);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(151),r=t(205),i=t(86);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(71),r=t(75);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var u=(c=t[o])[0],p=n[u],d=c[1];if(l&&c[2]){if(void 0===p&&!(u in n))return!1}else{var m=new a;if(i)var f=i(p,d,u,n,e,m);if(!(void 0===f?r(d,p,3,i,m):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(21),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(21);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(21);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(20);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(20),r=t(38),i=t(40);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(73),r=t(163),i=t(39),o=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,p=c.hasOwnProperty,d=RegExp("^"+u.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?d:s).test(o(n))}},function(n,e,t){var a,r=t(164),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(6)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(167),r=t(20),i=t(38);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(168),r=t(169),i=t(170),o=t(171),s=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(22);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(22),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(22),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(23);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(71),r=t(76),i=t(182),o=t(185),s=t(201),l=t(5),c=t(80),u=t(82),p="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,f,h){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?p:b)==p,w=(y="[object Arguments]"==y?p:y)==p,j=b==y;if(j&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(j&&!x)return h||(h=new a),g||u(n)?r(n,e,t,m,f,h):i(n,e,b,t,m,f,h);if(!(1&t)){var S=x&&d.call(n,"__wrapped__"),E=w&&d.call(e,"__wrapped__");if(S||E){var k=S?n.value():n,_=E?e.value():e;return h||(h=new a),f(k,_,t,m,h)}}return!!j&&(h||(h=new a),o(n,e,t,m,f,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),r=t(183),i=t(72),o=t(76),s=t(184),l=t(41),c=a?a.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,p,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var f=1&a;if(m||(m=l),n.size!=e.size&&!f)return!1;var h=d.get(n);if(h)return h==e;a|=2,d.set(n,e);var g=o(m(n),m(e),a,c,p,d);return d.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var a=t(6).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(186),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),u=c.length;if(u!=a(e).length&&!l)return!1;for(var p=u;p--;){var d=c[p];if(!(l?d in e:r.call(e,d)))return!1}var m=s.get(n),f=s.get(e);if(m&&f)return m==e&&f==n;var h=!0;s.set(n,e),s.set(e,n);for(var g=l;++p<u;){var v=n[d=c[p]],b=e[d];if(i)var y=l?i(b,v,d,e,n,s):i(v,b,d,n,e,s);if(!(void 0===y?v===b||o(v,b,t,i,s):y)){h=!1;break}g||(g="constructor"==d)}if(h&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var a=t(187),r=t(188),i=t(79);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(69),r=t(5);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(189),r=t(190),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(192),r=t(37),i=t(5),o=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),u=!t&&r(n),p=!t&&!u&&o(n),d=!t&&!u&&!p&&l(n),m=t||u||p||d,f=m?a(n.length,String):[],h=f.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||p&&("offset"==g||"parent"==g)||d&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,h))||f.push(g);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(13),r=t(42),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(70),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var a=t(198),r=t(199),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(200)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(202),r=t(38),i=t(203),o=t(84),s=t(204),l=t(13),c=t(74),u=c(a),p=c(r),d=c(i),m=c(o),f=c(s),h=l;(a&&"[object DataView]"!=h(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=h(new r)||i&&"[object Promise]"!=h(i.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case u:return"[object DataView]";case p:return"[object Map]";case d:return"[object Promise]";case m:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var a=t(10)(t(6),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(6),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(6),"WeakMap");n.exports=a},function(n,e,t){var a=t(85),r=t(79);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(75),r=t(207),i=t(214),o=t(43),s=t(85),l=t(86),c=t(24);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(87);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(209),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(210);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(40);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(212);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),r=t(213),i=t(5),o=t(44),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(215),r=t(216);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(88),r=t(37),i=t(5),o=t(81),s=t(42),l=t(24);n.exports=function(n,e,t){for(var c=-1,u=(e=a(e,n)).length,p=!1;++c<u;){var d=l(e[c]);if(!(p=null!=n&&t(n,d)))break;n=n[d]}return p||++c!=u?p:!!(u=null==n?0:n.length)&&s(u)&&o(d,u)&&(i(n)||r(n))}},function(n,e,t){var a=t(218),r=t(219),i=t(43),o=t(24);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(87);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(45),r=t(221),i=t(223);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(222),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(224),r=t(227)(a);n.exports=r},function(n,e,t){var a=t(225),r=t(226),i=t(45),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(77),r=t(229),i=t(234),o=t(78),s=t(235),l=t(41);n.exports=function(n,e,t){var c=-1,u=r,p=n.length,d=!0,m=[],f=m;if(t)d=!1,u=i;else if(p>=200){var h=e?null:s(n);if(h)return l(h);d=!1,u=o,f=new a}else f=e?[]:m;n:for(;++c<p;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,d&&v==v){for(var b=f.length;b--;)if(f[b]===v)continue n;e&&f.push(v),m.push(g)}else u(f,v,t)||(f!==m&&f.push(v),m.push(g))}return m}},function(n,e,t){var a=t(230);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(231),r=t(232),i=t(233);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(84),r=t(236),i=t(41),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(83),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.13
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var p=Object.prototype.toString;function d(n){return"[object Object]"===p.call(n)}function m(n){return"[object RegExp]"===p.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var w=Object.prototype.hasOwnProperty;function j(n,e){return w.call(n,e)}function S(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,k=S((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),_=S((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,C=S((function(n){return n.replace(T,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function O(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function D(n,e){for(var t in e)n[t]=e[t];return n}function A(n){for(var e={},t=0;t<n.length;t++)n[t]&&D(e,n[t]);return e}function z(n,e,t){}var J=function(n,e,t){return!1},P=function(n){return n};function L(n,e){if(n===e)return!0;var t=u(n),a=u(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var $=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:J,isReservedAttr:J,isUnknownElement:J,getTagNamespace:z,parsePlatformTagName:P,mustUseProp:J,async:!0,_lifecycleHooks:N},F=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var H=new RegExp("[^".concat(F.source,".$_\\d]"));var G="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),Z=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Y=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Q=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(W)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function dn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),fn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function hn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function jn(){xn.pop(),yn.target=xn[xn.length-1]}var Sn=Array.prototype,En=Object.create(Sn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Sn[n];V(En,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var kn=new WeakMap;function _n(n){return Tn(n,!0),V(n,"__v_isShallow",!0),n}function Tn(n,e){if(!Cn(n)){Pn(n,e,on());0}}function Cn(n){return!(!n||!n.__v_isReadonly)}var In=Object.getOwnPropertyNames(En),On={},Dn=!0;function An(n){Dn=n}var zn={notify:z,depend:z,addSub:z,removeSub:z},Jn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new yn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(G)n.__proto__=En;else for(var a=0,i=In.length;a<i;a++){V(n,s=In[a],En[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;Ln(n,s=o[a],On,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&j(n,"__ob__")&&n.__ob__ instanceof Jn?n.__ob__:!Dn||!t&&on()||!r(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||kn.has(n)||$n(n)||n instanceof mn?void 0:new Jn(n,e,t)}function Ln(n,e,t,a,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==On&&2!==arguments.length||(t=n[e]);var p=!i&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),p&&(p.dep.depend(),r(e)&&Rn(e))),$n(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(R(a,e)){if(u)u.call(n,e);else{if(c)return;if(!i&&$n(a)&&!$n(e))return void(a.value=e);t=e}p=!i&&Pn(e,!1,o),s.notify()}}}),s}}function Mn(n,e,t){if(!Cn(n)){var a=n.__ob__;return r(n)&&f(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Ln(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(r(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Cn(n)||j(n,e)&&(delete n[e],t&&t.dep.notify())}}function Rn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Rn(e)}function $n(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if($n(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];$n(a)&&!$n(n)?a.value=n:e[t]=n}})}new WeakMap,new WeakMap;"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var qn;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=qn,!n&&qn&&(this.index=(qn.scopes||(qn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=qn;try{return qn=this,n()}finally{qn=e}}else 0},n.prototype.on=function(){qn=this},n.prototype.off=function(){qn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Vn=S((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Ce(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ce(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,a,r,o){var l,c,u,p;for(l in n)c=n[l],u=e[l],p=Vn(l),i(c)||(i(u)?(i(c.fns)&&(c=n[l]=Hn(c,o)),s(p.once)&&(c=n[l]=r(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)i(n[l])&&a((p=Vn(l)).name,e[l],p.capture)}function Wn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(a.fns,l)}i(r)?a=Hn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Hn([r,l]),a.merged=!0,n[e]=a}function Kn(n,e,t,a,r){if(o(e)){if(j(e,t))return n[t]=e[t],r||delete e[t],!0;if(j(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Zn(n){return l(n)?[hn(n)]:r(n)?function n(e,t){var a,c,u,p,d=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(u=d.length-1,p=d[u],r(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Xn(p)&&(d[u]=hn(p.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Xn(p)?d[u]=hn(p.text+c):""!==c&&d.push(hn(c)):Xn(c)&&Xn(p)?d[u]=hn(p.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),d.push(c)));return d}(n):void 0}function Xn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Yn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),p=c.next();!p.done;)l.push(e(p.value,l.length)),p=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Qn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=D(D({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function ne(n){return Dt(this.$options,"filters",n,!0)||P}function ee(n,e){return r(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,a,r){var i=q.keyCodes[e]||t;return r&&a&&!q.keyCodes[e]?ee(r,a):i?ee(i,n):a?C(a)!==e:void 0===n}function ae(n,e,t,a,i){if(t)if(u(t)){r(t)&&(t=A(t));var o=void 0,s=function(r){if("class"===r||"style"===r||y(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||q.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(r),c=C(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||oe(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ie(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&se(n[a],"".concat(e,"_").concat(a),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(d(e)){var t=n.on=n.on?D({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function ce(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?ce(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function ue(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=ie,n._n=v,n._s=g,n._l=Yn,n._t=Qn,n._q=L,n._i=M,n._m=re,n._f=ne,n._k=te,n._b=ae,n._v=hn,n._e=fn,n._u=ce,n._g=le,n._d=ue,n._p=pe}function me(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function ge(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=ve(n,t,c,e[c]))}else i={};for(var u in t)u in i||(i[u]=be(t,u));return e&&Object.isExtensible(e)&&(e._normalized=i),V(i,"$stable",s),V(i,"$key",l),V(i,"$hasNormal",o),i}function ve(n,e,t,a){var i=function(){var e=pn;dn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Zn(t))&&t[0];return dn(e),t&&(!i||1===t.length&&i.isComment&&!he(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function be(n,e){return function(){return n[e]}}function ye(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),xe(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||je(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function xe(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,we(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function we(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function je(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Se=null;function Ee(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function ke(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||he(t)))return t}}function _e(n,e,t,a,p,d){return(r(t)||l(t))&&(p=a,a=t,t=void 0),s(d)&&(p=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return fn();o(t)&&o(t.is)&&(e=t.is);if(!e)return fn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Zn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var p,d;if("string"==typeof e){var m=void 0;d=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),p=q.isReservedTag(e)?new mn(q.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=Dt(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):wt(m,t,n,a,e)}else p=wt(e,t,n,a);return r(p)?p:o(p)?(o(d)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(p,d),o(t)&&function(n){u(n.style)&&Fe(n.style);u(n.class)&&Fe(n.class)}(t),p):fn()}(n,e,t,a,p)}function Te(n,e,t){wn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Ie(n,a,"errorCaptured hook")}}Ie(n,e,t)}finally{jn()}}function Ce(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Te(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Te(n,a,r)}return i}function Ie(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Oe(e,null,"config.errorHandler")}Oe(n,e,t)}function Oe(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var De,Ae=!1,ze=[],Je=!1;function Pe(){Je=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Le=Promise.resolve();De=function(){Le.then(Pe),Q&&setTimeout(z)},Ae=!0}else if(Z||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())De="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Pe)}:function(){setTimeout(Pe,0)};else{var Me=1,Be=new MutationObserver(Pe),Re=document.createTextNode(String(Me));Be.observe(Re,{characterData:!0}),De=function(){Me=(Me+1)%2,Re.data=String(Me)},Ae=!0}function $e(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Te(n,e,"nextTick")}else t&&t(e)})),Je||(Je=!0,De()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var a=n.$options;a[e]=Tt(a[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var qe=new cn;function Fe(n){return function n(e,t){var a,i,o=r(e);if(!o&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if($n(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,qe),qe.clear(),n}var Ue,Ve=0,He=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=qn&&!qn._vm?qn:n?n._scope:void 0)&&(o=qn),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ve,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Te(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),jn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){Ue.$on(n,e)}function We(n,e){Ue.$off(n,e)}function Ke(n,e){var t=Ue;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Ze(n,e,t){Ue=n,Gn(e,t||{},Ge,We,Ke,n),Ue=void 0}var Xe=null;function Ye(n){var e=Xe;return Xe=n,function(){Xe=e}}function Qe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Qe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,a){void 0===a&&(a=!0),wn();var r=pn;a&&dn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Ce(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&dn(r),jn()}var tt=[],at=[],rt={},it=!1,ot=!1,st=0;var lt=0,ct=Date.now;if(W&&!Z){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(lt=ct(),ot=!0,tt.sort(pt),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=at.slice(),a=tt.slice();st=tt.length=at.length=0,rt={},it=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&et(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&q.devtools&&sn.emit("flush")}function mt(n){var e=n.id;if(null==rt[e]&&(n!==yn.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);it||(it=!0,$e(dt))}}function ft(n,e){if(n){for(var t=Object.create(null),a=un?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,i,o){var l,c=this,u=o.options;j(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var p=s(u._compiled),d=!p;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=ft(u.inject,i),this.slots=function(){return c.$slots||ge(i,n.scopedSlots,c.$slots=me(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(i,n.scopedSlots,this.slots())}}),p&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ge(i,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,a){var o=_e(l,n,e,t,a,d);return o&&!r(o)&&(o.fnScopeId=u._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return _e(l,n,e,t,a,d)}}function gt(n,e,t,a,r){var i=gn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function vt(n,e){for(var t in e)n[k(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}de(ht.prototype);var yt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;yt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var p=r.data.attrs||a;n._attrsProxy&&xe(n._attrsProxy,p,u.data&&u.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=p,t=t||a;var d=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,d||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ze(n,t,d),e&&n.$options.props){An(!1);for(var m=n._props,f=n.$options._propKeys||[],h=0;h<f.length;h++){var g=f[h],v=n.$options.props;m[g]=At(g,v,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=me(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,et(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,at.push(e)):nt(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Qe(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);et(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(yt);function wt(n,e,t,l,c){if(!i(n)){var p=t.$options._base;if(u(n)&&(n=p.extend(n)),"function"==typeof n){var d;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Se;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(a,t)}));var p=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=B((function(t){n.resolved=Ee(t,e),r?a.length=0:p(!0)})),m=B((function(e){o(n.errorComp)&&(n.error=!0,p(!0))})),f=n(d,m);return u(f)&&(h(f)?i(n.resolved)&&f.then(d,m):h(f.component)&&(f.component.then(d,m),o(f.error)&&(n.errorComp=Ee(f.error,e)),o(f.loading)&&(n.loadingComp=Ee(f.loading,e),0===f.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,p(!1))}),f.delay||200)),o(f.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),f.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(d=n,p)))return function(n,e,t,a,r){var i=fn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(d,e,t,l,c);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var u=C(c);Kn(r,l,c,u,!0)||Kn(r,s,c,u,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},u=l.props;if(o(u))for(var p in u)c[p]=At(p,u,e||a);else o(t.attrs)&&vt(c,t.attrs),o(t.props)&&vt(c,t.props);var d=new ht(t,c,s,i,n),m=l.render.call(null,d._c,d);if(m instanceof mn)return gt(m,t,d.parent,l,d);if(r(m)){for(var f=Zn(m)||[],h=new Array(f.length),g=0;g<f.length;g++)h[g]=gt(f[g],t,d.parent,l,d);return h}}(n,m,e,t,l);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var a=xt[t],r=e[a],i=yt[a];r===i||r&&r._merged||(e[a]=r?jt(i,r):i)}}(e);var v=bt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:f,tag:c,children:l},d)}}}function jt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var St=z,Et=q.optionMergeStrategies;function kt(n,e){if(!e)return n;for(var t,a,r,i=un?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(a=n[t],r=e[t],j(n,t)?a!==r&&d(a)&&d(r)&&kt(a,r):Mn(n,t,r));return n}function _t(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?kt(a,r):r}:e?n?function(){return kt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Tt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,a){var r=Object.create(n||null);return e?D(r,e):r}Et.data=function(n,e,t){return t?_t(n,e,t):e&&"function"!=typeof e?n:_t(n,e)},N.forEach((function(n){Et[n]=Tt})),$.forEach((function(n){Et[n+"s"]=Ct})),Et.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in D(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return D(r,n),e&&D(r,e),r},Et.provide=_t;var It=function(n,e){return void 0===e?n:e};function Ot(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[k(i)]={type:null});else if(d(t))for(var s in t)i=t[s],o[k(s)]=d(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(d(t))for(var o in t){var s=t[o];a[o]=d(s)?D({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=Ot(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=Ot(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)j(n,o)||l(o);function l(a){var r=Et[a]||It;s[a]=r(n[a],e[a],t,a)}return s}function Dt(n,e,t,a){if("string"==typeof t){var r=n[e];if(j(r,t))return r[t];var i=k(t);if(j(r,i))return r[i];var o=_(i);return j(r,o)?r[o]:r[t]||r[i]||r[o]}}function At(n,e,t,a){var r=e[n],i=!j(t,n),o=t[n],s=Lt(Boolean,r.type);if(s>-1)if(i&&!j(r,"default"))o=!1;else if(""===o||o===C(n)){var l=Lt(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!j(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Jt(e.type)?a.call(n):a}(a,r,n);var u=Dn;An(!0),Pn(o),An(u)}return o}var zt=/^\s*function (\w+)/;function Jt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Pt(n,e){return Jt(n)===Jt(e)}function Lt(n,e){if(!r(e))return Pt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Pt(e[t],n))return t;return-1}var Mt={enumerable:!0,configurable:!0,get:z,set:z};function Bt(n,e,t){Mt.get=function(){return this[e][t]},Mt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Mt)}function Rt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=_n({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var i=function(i){r.push(i);var o=At(i,e,t,n);Ln(a,i,o),i in n||Bt(n,"_props",i)};for(var o in e)i(o);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=ye(n);dn(n),wn();var r=Ce(t,null,[n._props||_n({}),a],n,"setup");if(jn(),dn(),c(r))e.render=r;else if(u(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Nn(i,r,o)}else for(var o in r)U(o)||Nn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Te(n,e,"data()"),{}}finally{jn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&j(a,i)||U(i)||Bt(n,"_data",i)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new He(n,o||z,z,$t)),r in n||Nt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Ut(n,t,a[i]);else Ut(n,t,a)}}(n,e.watch)}var $t={lazy:!0};function Nt(n,e,t){var a=!on();c(t)?(Mt.get=a?qt(e):Ft(t),Mt.set=z):(Mt.get=t.get?a&&!1!==t.cache?qt(e):Ft(t.get):z,Mt.set=t.set||z),Object.defineProperty(n,e,Mt)}function qt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function Ut(n,e,t,a){return d(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Vt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&D(n.extendOptions,a),(e=n.options=Ot(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=bt(n)||bt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Ot(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Bt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,$.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=D({},o.options),r[a]=o,o}}function Kt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Zt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Xt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Yt(t,i,a,r)}}}function Yt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Vt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ot(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=me(e._renderChildren,r),n.$scopedSlots=t?ge(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return _e(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return _e(n,e,t,a,r,!0)};var i=t&&t.data;Ln(n,"$attrs",i&&i.attrs||a,null,!0),Ln(n,"$listeners",e._parentListeners||a,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ft(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Ln(n,t,e[t])})),An(!0))}(e),Rt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var a=Un(n),r=un?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Gt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Mn,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(d(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var a=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');wn(),Ce(e,this,[a.value],this,r),jn()}return function(){a.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?O(t):t;for(var a=O(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ce(t[i],e,a,e,r)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ye(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return $e(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=ge(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&je(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{dn(e),Se=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Te(t,e,"render"),n=e._vnode}finally{Se=null,dn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=fn()),n.parent=i,n}}(Gt);var Qt=[String,RegExp,Array],na={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Qt,exclude:Qt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Kt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Zt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=ke(n),t=e&&e.componentOptions;if(t){var a=Kt(t),r=this.include,i=this.exclude;if(r&&(!a||!Zt(r,a))||i&&a&&Zt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:St,extend:D,mergeOptions:Ot,defineReactive:Ln},n.set=Mn,n.delete=Bn,n.nextTick=$e,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),$.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,D(n.options.components,na),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=O(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ot(this.options,n),this}}(n),Wt(n),function(n){$.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:on}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:ht}),Gt.version="2.7.13";var ea=b("style,class"),ta=b("input,textarea,option,select,progress"),aa=b("contenteditable,draggable,spellcheck"),ra=b("events,caret,typing,plaintext-only"),ia=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),oa="http://www.w3.org/1999/xlink",sa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},la=function(n){return sa(n)?n.slice(6,n.length):""},ca=function(n){return null==n||!1===n};function ua(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=pa(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=pa(e,t.data));return function(n,e){if(o(n)||o(e))return da(n,ma(e));return""}(e.staticClass,e.class)}function pa(n,e){return{staticClass:da(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function da(n,e){return n?e?n+" "+e:n:e||""}function ma(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=ma(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var fa={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ga=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(n){return ha(n)||ga(n)};var ba=Object.create(null);var ya=b("text,number,password,search,email,tel,url");var xa=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(fa[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wa={create:function(n,e){ja(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ja(n,!0),ja(e))},destroy:function(n){ja(n,!0)}};function ja(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ce(t,a,[s],a,"template ref function");else{var u=n.data.refInFor,p="string"==typeof t||"number"==typeof t,d=$n(t),m=a.$refs;if(p||d)if(u){var f=p?m[t]:t.value;e?r(f)&&x(f,i):r(f)?f.includes(i)||f.push(i):p?(m[t]=[i],Sa(a,t,m[t])):t.value=[i]}else if(p){if(e&&m[t]!==i)return;m[t]=l,Sa(a,t,s)}else if(d){if(e&&t.value!==i)return;t.value=s}else 0}}}function Sa(n,e,t){var a=n._setupState;a&&j(a,e)&&($n(a[e])?a[e].value=t:a[e]=t)}var Ea=new mn("",{},[]),ka=["create","activate","update","remove","destroy"];function _a(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||ya(a)&&ya(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ta(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ca={create:Ia,update:Ia,destroy:function(n){Ia(n,Ea)}};function Ia(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===Ea,o=e===Ea,s=Da(n.data.directives,n.context),l=Da(e.data.directives,e.context),c=[],u=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(za(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var p=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};i?Wn(e,"insert",p):p()}u.length&&Wn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)za(u[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||za(s[t],"unbind",n,n,o)}(n,e)}var Oa=Object.create(null);function Da(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Oa),r[Aa(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||Dt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Dt(e.$options,"directives",a.name)}return r}function Aa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Te(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ja=[wa,Ca];function Pa(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(a in(o(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=D({},u)),u)r=u[a],c[a]!==r&&La(l,a,r,e.data.pre);for(a in(Z||Y)&&u.value!==c.value&&La(l,"value",u.value),c)i(u[a])&&(sa(a)?l.removeAttributeNS(oa,la(a)):aa(a)||l.removeAttribute(a))}}function La(n,e,t,a){a||n.tagName.indexOf("-")>-1?Ma(n,e,t):ia(e)?ca(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):aa(e)?n.setAttribute(e,function(n,e){return ca(e)||"false"===e?"false":"contenteditable"===n&&ra(e)?e:"true"}(e,t)):sa(e)?ca(t)?n.removeAttributeNS(oa,la(e)):n.setAttributeNS(oa,e,t):Ma(n,e,t)}function Ma(n,e,t){if(ca(t))n.removeAttribute(e);else{if(Z&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ba={create:Pa,update:Pa};function Ra(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=ua(e),l=t._transitionClasses;o(l)&&(s=da(s,ma(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var $a,Na={create:Ra,update:Ra};function qa(n,e,t){var a=$a;return function r(){var i=e.apply(null,arguments);null!==i&&Va(n,r,t,a)}}var Fa=Ae&&!(en&&Number(en[1])<=53);function Ua(n,e,t,a){if(Fa){var r=lt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}$a.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Va(n,e,t,a){(a||$a).removeEventListener(n,e._wrapper||e,t)}function Ha(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};$a=e.elm||n.elm,function(n){if(o(n.__r)){var e=Z?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,a,Ua,Va,qa,e.context),$a=void 0}}var Ga,Wa={create:Ha,update:Ha,destroy:function(n){return Ha(n,Ea)}};function Ka(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=D({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var u=i(a)?"":String(a);Za(r,u)&&(r.value=u)}else if("innerHTML"===t&&ga(r.tagName)&&i(r.innerHTML)){(Ga=Ga||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var p=Ga.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;p.firstChild;)r.appendChild(p.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Za(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xa={create:Ka,update:Ka},Ya=S((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Qa(n){var e=nr(n.style);return n.staticStyle?D(n.staticStyle,e):e}function nr(n){return Array.isArray(n)?A(n):"string"==typeof n?Ya(n):n}var er,tr=/^--/,ar=/\s*!important$/,rr=function(n,e,t){if(tr.test(e))n.style.setProperty(e,t);else if(ar.test(t))n.style.setProperty(C(e),t.replace(ar,""),"important");else{var a=or(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},ir=["Webkit","Moz","ms"],or=S((function(n){if(er=er||document.createElement("div").style,"filter"!==(n=k(n))&&n in er)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ir.length;t++){var a=ir[t]+e;if(a in er)return a}}));function sr(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,u=a.normalizedStyle||a.style||{},p=c||u,d=nr(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?D({},d):d;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Qa(r.data))&&D(a,t);(t=Qa(n.data))&&D(a,t);for(var i=n;i=i.parent;)i.data&&(t=Qa(i.data))&&D(a,t);return a}(e,!0);for(s in p)i(m[s])&&rr(l,s,"");for(s in m)(r=m[s])!==p[s]&&rr(l,s,null==r?"":r)}}var lr={create:sr,update:sr},cr=/\s+/;function ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(cr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function dr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&D(e,mr(n.name||"v")),D(e,n),e}return"string"==typeof n?mr(n):void 0}}var mr=S((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),fr=W&&!X,hr="transition",gr="transitionend",vr="animation",br="animationend";fr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(vr="WebkitAnimation",br="webkitAnimationEnd"));var yr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){yr((function(){yr(n)}))}function wr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ur(n,e))}function jr(n,e){n._transitionClasses&&x(n._transitionClasses,e),pr(n,e)}function Sr(n,e,t){var a=kr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?gr:br,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,u)}var Er=/\b(transform|all)(,|$)/;function kr(n,e){var t,a=window.getComputedStyle(n),r=(a[hr+"Delay"]||"").split(", "),i=(a[hr+"Duration"]||"").split(", "),o=_r(r,i),s=(a[vr+"Delay"]||"").split(", "),l=(a[vr+"Duration"]||"").split(", "),c=_r(s,l),u=0,p=0;return"transition"===e?o>0&&(t="transition",u=o,p=i.length):"animation"===e?c>0&&(t="animation",u=c,p=l.length):p=(t=(u=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:u,propCount:p,hasTransform:"transition"===t&&Er.test(a[hr+"Property"])}}function _r(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Tr(e)+Tr(n[t])})))}function Tr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Cr(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=dr(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,p=a.enterToClass,d=a.enterActiveClass,m=a.appearClass,f=a.appearToClass,h=a.appearActiveClass,g=a.beforeEnter,b=a.enter,y=a.afterEnter,x=a.enterCancelled,w=a.beforeAppear,j=a.appear,S=a.afterAppear,E=a.appearCancelled,k=a.duration,_=Xe,T=Xe.$vnode;T&&T.parent;)_=T.context,T=T.parent;var C=!_._isMounted||!n.isRootInsert;if(!C||j||""===j){var I=C&&m?m:l,O=C&&h?h:d,D=C&&f?f:p,A=C&&w||g,z=C&&c(j)?j:b,J=C&&S||y,P=C&&E||x,L=v(u(k)?k.enter:k);0;var M=!1!==r&&!X,R=Dr(z),$=t._enterCb=B((function(){M&&(jr(t,D),jr(t,O)),$.cancelled?(M&&jr(t,I),P&&P(t)):J&&J(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,$)})),A&&A(t),M&&(wr(t,I),wr(t,O),xr((function(){jr(t,I),$.cancelled||(wr(t,D),R||(Or(L)?setTimeout($,L):Sr(t,s,$)))}))),n.data.show&&(e&&e(),z&&z(t,$)),M||R||$()}}}function Ir(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=dr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,p=a.leaveActiveClass,d=a.beforeLeave,m=a.leave,f=a.afterLeave,h=a.leaveCancelled,g=a.delayLeave,b=a.duration,y=!1!==r&&!X,x=Dr(m),w=v(u(b)?b.leave:b);0;var j=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(jr(t,c),jr(t,p)),j.cancelled?(y&&jr(t,l),h&&h(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(S):S()}function S(){j.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),y&&(wr(t,l),wr(t,p),xr((function(){jr(t,l),j.cancelled||(wr(t,c),x||(Or(w)?setTimeout(j,w):Sr(t,s,j)))}))),m&&m(t,j),y||x||j())}}function Or(n){return"number"==typeof n&&!isNaN(n)}function Dr(n){if(i(n))return!1;var e=n.fns;return o(e)?Dr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ar(n,e){!0!==e.data.show&&Cr(e)}var zr=function(n){var e,t,a={},c=n.modules,u=n.nodeOps;for(e=0;e<ka.length;++e)for(a[ka[e]]=[],t=0;t<c.length;++t)o(c[t][ka[e]])&&a[ka[e]].push(c[t][ka[e]]);function p(n){var e=u.parentNode(n);o(e)&&u.removeChild(e,n)}function d(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=gn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),f(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](Ea,s);e.push(s);break}f(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var p=n.data,d=n.children,g=n.tag;o(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),y(n),h(n,d,e),o(p)&&v(n,e),f(t,n.elm,r)):s(n.isComment)?(n.elm=u.createComment(n.text),f(t,n.elm,r)):(n.elm=u.createTextNode(n.text),f(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),y(n)):(ja(n),e.push(n))}function f(n,e,t){o(n)&&(o(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function h(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)d(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r](Ea,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Ea,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;o(e=Xe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,a,r,i){for(;a<=r;++a)d(t[a],i,n,e,!1,t,a)}function w(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function j(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(S(a),w(a)):p(a.elm))}}function S(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&p(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&S(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else p(n.elm)}function E(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&_a(n,i))return r}}function k(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=gn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,f=e.data;o(f)&&o(m=f.hook)&&o(m=m.prepatch)&&m(n,e);var h=n.children,v=e.children;if(o(f)&&g(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=f.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(h)&&o(v)?h!==v&&function(n,e,t,a,r){var s,l,c,p=0,m=0,f=e.length-1,h=e[0],g=e[f],v=t.length-1,b=t[0],y=t[v],w=!r;for(0;p<=f&&m<=v;)i(h)?h=e[++p]:i(g)?g=e[--f]:_a(h,b)?(k(h,b,a,t,m),h=e[++p],b=t[++m]):_a(g,y)?(k(g,y,a,t,v),g=e[--f],y=t[--v]):_a(h,y)?(k(h,y,a,t,v),w&&u.insertBefore(n,h.elm,u.nextSibling(g.elm)),h=e[++p],y=t[--v]):_a(g,b)?(k(g,b,a,t,m),w&&u.insertBefore(n,g.elm,h.elm),g=e[--f],b=t[++m]):(i(s)&&(s=Ta(e,p,f)),i(l=o(b.key)?s[b.key]:E(b,e,p,f))?d(b,a,n,h.elm,!1,t,m):_a(c=e[l],b)?(k(c,b,a,t,m),e[l]=void 0,w&&u.insertBefore(n,c.elm,h.elm)):d(b,a,n,h.elm,!1,t,m),b=t[++m]);p>f?x(n,i(t[v+1])?null:t[v+1].elm,t,m,v,a):m>v&&j(e,p,f)}(p,h,v,t,c):o(v)?(o(n.text)&&u.setTextContent(p,""),x(p,null,v,0,v.length-1,t)):o(h)?j(h,0,h.length-1):o(n.text)&&u.setTextContent(p,""):n.text!==e.text&&u.setTextContent(p,e.text),o(f)&&o(m=f.hook)&&o(m=m.postpatch)&&m(n,e)}}}function _(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var T=b("attrs,class,staticClass,staticStyle,key");function C(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,p=n.firstChild,d=0;d<c.length;d++){if(!p||!C(p,c[d],t,a)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else h(e,c,t);if(o(l)){var f=!1;for(var g in l)if(!T(g)){f=!0,v(e,t);break}!f&&l.class&&Fe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,p=[];if(i(n))c=!0,d(e,p);else{var m=o(n.nodeType);if(!m&&_a(n,e))k(n,e,p,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,p))return _(e,p,!0),n;l=n,n=new mn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,h=u.parentNode(f);if(d(e,p,f._leaveCb?null:h,u.nextSibling(f)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<a.create.length;++x)a.create[x](Ea,v);var S=v.data.hook.insert;if(S.merged)for(var E=1;E<S.fns.length;E++)S.fns[E]()}else ja(v);v=v.parent}o(h)?j([n],0,0):o(n.tag)&&w(n)}}return _(e,p,c),e.elm}o(n)&&w(n)}}({nodeOps:xa,modules:[Ba,Na,Wa,Xa,lr,W?{create:Ar,activate:Ar,remove:function(n,e){!0!==n.data.show?Ir(n,e):e()}}:{}].concat(Ja)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Nr(n,"input")}));var Jr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Wn(t,"postpatch",(function(){Jr.componentUpdated(n,e,t)})):Pr(n,e,t.context),n._vOptions=[].map.call(n.options,Br)):("textarea"===t.tag||ya(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Rr),n.addEventListener("compositionend",$r),n.addEventListener("change",$r),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Br);if(r.some((function(n,e){return!L(n,a[e])})))(n.multiple?e.value.some((function(n){return Mr(n,r)})):e.value!==e.oldValue&&Mr(e.value,r))&&Nr(n,"change")}}};function Pr(n,e,t){Lr(n,e,t),(Z||Y)&&setTimeout((function(){Lr(n,e,t)}),0)}function Lr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=M(a,Br(o))>-1,o.selected!==i&&(o.selected=i);else if(L(Br(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Mr(n,e){return e.every((function(e){return!L(e,n)}))}function Br(n){return"_value"in n?n._value:n.value}function Rr(n){n.target.composing=!0}function $r(n){n.target.composing&&(n.target.composing=!1,Nr(n.target,"input"))}function Nr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function qr(n){return!n.componentInstance||n.data&&n.data.transition?n:qr(n.componentInstance._vnode)}var Fr={model:Jr,show:{bind:function(n,e,t){var a=e.value,r=(t=qr(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Cr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=qr(t)).data&&t.data.transition?(t.data.show=!0,a?Cr(t,(function(){n.style.display=n.__vOriginalDisplay})):Ir(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Ur={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Vr(ke(e.children)):n}function Hr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[k(a)]=r[a];return e}function Gr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wr=function(n){return n.tag||he(n)},Kr=function(n){return"show"===n.name},Zr={name:"transition",props:Ur,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=Vr(r);if(!i)return r;if(this._leaving)return Gr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Hr(this),c=this._vnode,u=Vr(c);if(i.data.directives&&i.data.directives.some(Kr)&&(i.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=D({},s);if("out-in"===a)return this._leaving=!0,Wn(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gr(n,r);if("in-out"===a){if(he(i))return c;var d,m=function(){d()};Wn(s,"afterEnter",m),Wn(s,"enterCancelled",m),Wn(p,"delayLeave",(function(n){d=n}))}}return r}}},Xr=D({tag:String,moveClass:String},Ur);function Yr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Qr(n){n.data.newPos=n.elm.getBoundingClientRect()}function ni(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Xr.mode;var ei={Transition:Zr,TransitionGroup:{props:Xr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Hr(this),s=0;s<r.length;s++){if((u=r[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))i.push(u),t[u.key]=u,(u.data||(u.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var u;(u=a[s]).data.transition=o,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Yr),n.forEach(Qr),n.forEach(ni),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;wr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(gr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(gr,n),t._moveCb=null,jr(t,e))})}})))},methods:{hasMove:function(n,e){if(!fr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pr(t,n)})),ur(t,e),t.style.display="none",this.$el.appendChild(t);var a=kr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ti(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&ta(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=va,Gt.config.isReservedAttr=ea,Gt.config.getTagNamespace=function(n){return ga(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!W)return!0;if(va(n))return!1;if(n=n.toLowerCase(),null!=ba[n])return ba[n];var e=document.createElement(n);return n.indexOf("-")>-1?ba[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ba[n]=/HTMLUnknownElement/.test(e.toString())},D(Gt.options.directives,Fr),D(Gt.options.components,ei),Gt.prototype.__patch__=W?zr:z,Gt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=fn),et(n,"beforeMount"),a=function(){n._update(n._render(),t)},new He(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){q.devtools&&sn&&sn.emit("init",Gt)}),0);var ai=/[!'()*]/g,ri=function(n){return"%"+n.charCodeAt(0).toString(16)},ii=/%2C/g,oi=function(n){return encodeURIComponent(n).replace(ai,ri).replace(ii,",")};function si(n){try{return decodeURIComponent(n)}catch(n){0}return n}var li=function(n){return null==n||"object"==typeof n?n:String(n)};function ci(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=si(t.shift()),r=t.length>0?si(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function ui(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oi(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(oi(e)):a.push(oi(e)+"="+oi(n)))})),a.join("&")}return oi(e)+"="+oi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pi=/\/?$/;function di(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=mi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:gi(e,r),matched:n?hi(n):[]};return t&&(o.redirectedFrom=gi(t,r)),Object.freeze(o)}function mi(n){if(Array.isArray(n))return n.map(mi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mi(n[t]);return e}return n}var fi=di(null,{path:"/"});function hi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function gi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||ui)(a)+r}function vi(n,e,t){return e===fi?n===e:!!e&&(n.path&&e.path?n.path.replace(pi,"")===e.path.replace(pi,"")&&(t||n.hash===e.hash&&bi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bi(n.query,e.query)&&bi(n.params,e.params))))}function bi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?bi(i,o):String(i)===String(o)}))}function yi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),u=0,p=!1;r&&r._routerRoot!==r;){var d=r.$vnode?r.$vnode.data:{};d.routerView&&u++,d.keepAlive&&r._directInactive&&r._inactive&&(p=!0),r=r.$parent}if(i.routerViewDepth=u,p){var m=c[s],f=m&&m.component;return f?(m.configProps&&wi(f,i,m.route,m.configProps),o(f,i,a)):o()}var h=l.matched[u],g=h&&h.components[s];if(!h||!g)return c[s]=null,o();c[s]={component:g},i.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),yi(l)};var v=h.props&&h.props[s];return v&&(ti(c[s],{route:l,configProps:v}),wi(g,i,l,v)),o(g,i,a)}};function wi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ti({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function ji(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function Si(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ei=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ki=Ri,_i=Di,Ti=function(n,e){return zi(Di(n,e),e)},Ci=zi,Ii=Bi,Oi=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Di(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Oi.exec(n));){var l=t[0],c=t[1],u=t.index;if(o+=n.slice(i,u),i=u+l.length,c)o+=c[1];else{var p=n[i],d=t[2],m=t[3],f=t[4],h=t[5],g=t[6],v=t[7];o&&(a.push(o),o="");var b=null!=d&&null!=p&&p!==d,y="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,j=f||h;a.push({name:m||r++,prefix:d||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:j?Pi(j):v?".*":"[^"+Ji(w)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function Ai(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Mi(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?Ai:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=i[l.name];if(null==u){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Ei(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(c=o(u[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Ji(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Pi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Li(n,e){return n.keys=e,n}function Mi(n){return n&&n.sensitive?"":"i"}function Bi(n,e,t){Ei(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Ji(s);else{var l=Ji(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Ji(t.delimiter||"/"),p=i.slice(-u.length)===u;return a||(i=(p?i.slice(0,-u.length):i)+"(?:"+u+"(?=$))?"),i+=r?"$":a&&p?"":"(?="+u+"|$)",Li(new RegExp("^"+i,Mi(t)),e)}function Ri(n,e,t){return Ei(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Li(n,e)}(n,e):Ei(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Ri(n[r],e,t).source);return Li(new RegExp("(?:"+a.join("|")+")",Mi(t)),e)}(n,e,t):function(n,e,t){return Bi(Di(n,t),e,t)}(n,e,t)}ki.parse=_i,ki.compile=Ti,ki.tokensToFunction=Ci,ki.tokensToRegExp=Ii;var $i=Object.create(null);function Ni(n,e,t){e=e||{};try{var a=$i[n]||($i[n]=ki.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function qi(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ti({},n)).params;return i&&"object"==typeof i&&(r.params=ti({},i)),r}if(!r.path&&r.params&&e){(r=ti({},r))._normalized=!0;var o=ti(ti({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Ni(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",u=l.path?ji(l.path,c,t||r.append):c,p=function(n,e,t){void 0===e&&(e={});var a,r=t||ci;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(li):li(o)}return a}(l.query,r.query,a&&a.options.parseQuery),d=r.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:u,query:p,hash:d}}var Fi,Ui=function(){},Vi={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,d=null==u?"router-link-exact-active":u,m=null==this.activeClass?p:this.activeClass,f=null==this.exactActiveClass?d:this.exactActiveClass,h=o.redirectedFrom?di(null,qi(o.redirectedFrom),null,t):o;l[f]=vi(a,h,this.exactPath),l[m]=this.exact||this.exactPath?l[f]:function(n,e){return 0===n.path.replace(pi,"/").indexOf(e.path.replace(pi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,h);var g=l[f]?this.ariaCurrentValue:null,v=function(n){Hi(n)&&(e.replace?t.replace(i,Ui):t.push(i,Ui))},b={click:Hi};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[m],isExactActive:l[f]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":g};else{var w=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var j=w.data=ti({},w.data);for(var S in j.on=j.on||{},j.on){var E=j.on[S];S in b&&(j.on[S]=Array.isArray(E)?E:[E])}for(var k in b)k in j.on?j.on[k].push(b[k]):j.on[k]=v;var _=w.data.attrs=ti({},w.data.attrs);_.href=s,_["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Hi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Gi="undefined"!=typeof window;function Wi(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Si(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var p={path:u,regex:Ki(u,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?Si(o+"/"+r.path):void 0;n(e,t,a,r,p,i)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==r.alias)for(var d=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<d.length;++m){0;var f={path:d[m],children:r.children};n(e,t,a,f,i,p.path||"/")}l&&(a[l]||(a[l]=p))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Ki(n,e){return ki(n,[],e)}function Zi(n,e){var t=Wi(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=qi(n,t,!1,e),c=s.name;if(c){var u=i[c];if(!u)return l(null,s);var p=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&p.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Ni(u.path,s.params),l(u,s,o)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var f=a[m],h=r[f];if(Xi(h.regex,s.path,s.params))return l(h,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(di(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,u=s.path,p=t.query,d=t.hash,m=t.params;if(p=s.hasOwnProperty("query")?s.query:p,d=s.hasOwnProperty("hash")?s.hash:d,m=s.hasOwnProperty("params")?s.params:m,c){i[c];return o({_normalized:!0,name:c,query:p,hash:d,params:m},void 0,t)}if(u){var f=function(n,e){return ji(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:Ni(f,m),query:p,hash:d},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Ni(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):di(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Wi([e||n],a,r,i,t),t&&t.alias.length&&Wi(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Wi(n,a,r,i)}}}function Xi(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?si(a[r]):a[r])}return!0}var Yi=Gi&&window.performance&&window.performance.now?window.performance:Date;function Qi(){return Yi.now().toFixed(3)}var no=Qi();function eo(){return no}function to(n){return no=n}var ao=Object.create(null);function ro(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ti({},window.history.state);return t.key=eo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",so),function(){window.removeEventListener("popstate",so)}}function io(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=eo();if(n)return ao[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){mo(n,i)})).catch((function(n){0})):mo(o,i))}))}}function oo(){var n=eo();n&&(ao[n]={x:window.pageXOffset,y:window.pageYOffset})}function so(n){oo(),n.state&&n.state.key&&to(n.state.key)}function lo(n){return uo(n.x)||uo(n.y)}function co(n){return{x:uo(n.x)?n.x:window.pageXOffset,y:uo(n.y)?n.y:window.pageYOffset}}function uo(n){return"number"==typeof n}var po=/^#\d/;function mo(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:uo((t=i).x)?t.x:0,y:uo(t.y)?t.y:0})}else lo(n)&&(e=co(n))}else a&&lo(n)&&(e=co(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fo,ho=Gi&&((-1===(fo=window.navigator.userAgent).indexOf("Android 2.")&&-1===fo.indexOf("Android 4.0")||-1===fo.indexOf("Mobile Safari")||-1!==fo.indexOf("Chrome")||-1!==fo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function go(n,e){oo();var t=window.history;try{if(e){var a=ti({},t.state);a.key=eo(),t.replaceState(a,"",n)}else t.pushState({key:to(Qi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vo(n){go(n,!0)}var bo={redirected:2,aborted:4,cancelled:8,duplicated:16};function yo(n,e){return wo(n,e,bo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return jo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xo(n,e){return wo(n,e,bo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wo(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var jo=["params","query","hash"];function So(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Eo(n,e){return So(n)&&n._isRouter&&(null==e||n.type===e)}function ko(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function _o(n){return function(e,t,a){var r=!1,i=0,o=null;To(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=Oo((function(e){var r;((r=e).__esModule||Io&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Fi.extend(e),t.components[s]=e,--i<=0&&a()})),u=Oo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=So(n)?n:new Error(e),a(o))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,u)}}})),r||a()}}function To(n,e){return Co(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Co(n){return Array.prototype.concat.apply([],n)}var Io="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Oo(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Do=function(n,e){this.router=n,this.base=function(n){if(!n)if(Gi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=fi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ao(n,e,t,a){var r=To(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=Fi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Co(a?r.reverse():r)}function zo(n,e){if(e)return function(){return n.apply(e,arguments)}}Do.prototype.listen=function(n){this.cb=n},Do.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Do.prototype.onError=function(n){this.errorCbs.push(n)},Do.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(Eo(n,bo.redirected)&&i===fi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Do.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!Eo(n)&&So(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(vi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&io(this.router,r,n,!1),s(((o=wo(i=r,n,bo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=u.updated,d=u.deactivated,m=u.activated,f=[].concat(function(n){return Ao(n,"beforeRouteLeave",zo,!0)}(d),this.router.beforeHooks,function(n){return Ao(n,"beforeRouteUpdate",zo)}(p),m.map((function(n){return n.beforeEnter})),_o(m)),h=function(e,t){if(a.pending!==n)return s(xo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return wo(n,e,bo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):So(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(yo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};ko(f,h,(function(){ko(function(n){return Ao(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),h,(function(){if(a.pending!==n)return s(xo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){yi(n)}))}))}))},Do.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Do.prototype.setupListeners=function(){},Do.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=fi,this.pending=null};var Jo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Po(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=ho&&t;a&&this.listeners.push(ro());var r=function(){var t=n.current,r=Po(n.base);n.current===fi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&io(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){go(Si(a.base+n.fullPath)),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){vo(Si(a.base+n.fullPath)),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Po(this.base)!==this.current.fullPath){var e=Si(this.base+this.current.fullPath);n?go(e):vo(e)}},e.prototype.getCurrentLocation=function(){return Po(this.base)},e}(Do);function Po(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(Si(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Lo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Po(n);if(!/^\/#/.test(e))return window.location.replace(Si(n+"/#"+e)),!0}(this.base)||Mo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ho&&e;t&&this.listeners.push(ro());var a=function(){var e=n.current;Mo()&&n.transitionTo(Bo(),(function(a){t&&io(n.router,a,e,!0),ho||No(a.fullPath)}))},r=ho?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){$o(n.fullPath),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){No(n.fullPath),io(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Bo()!==e&&(n?$o(e):No(e))},e.prototype.getCurrentLocation=function(){return Bo()},e}(Do);function Mo(){var n=Bo();return"/"===n.charAt(0)||(No("/"+n),!1)}function Bo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ro(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function $o(n){ho?go(Ro(n)):window.location.hash=n}function No(n){ho?vo(Ro(n)):window.location.replace(Ro(n))}var qo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Eo(n,bo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Do),Fo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Zi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ho&&!1!==n.fallback,this.fallback&&(e="hash"),Gi||(e="abstract"),this.mode=e,e){case"history":this.history=new Jo(this,n.base);break;case"hash":this.history=new Lo(this,n.base,this.fallback);break;case"abstract":this.history=new qo(this,n.base);break;default:0}},Uo={currentRoute:{configurable:!0}};Fo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Uo.currentRoute.get=function(){return this.history&&this.history.current},Fo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Jo||t instanceof Lo){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;ho&&r&&"fullPath"in n&&io(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fo.prototype.beforeEach=function(n){return Ho(this.beforeHooks,n)},Fo.prototype.beforeResolve=function(n){return Ho(this.resolveHooks,n)},Fo.prototype.afterEach=function(n){return Ho(this.afterHooks,n)},Fo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fo.prototype.onError=function(n){this.history.onError(n)},Fo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Fo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fo.prototype.go=function(n){this.history.go(n)},Fo.prototype.back=function(){this.go(-1)},Fo.prototype.forward=function(){this.go(1)},Fo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fo.prototype.resolve=function(n,e,t){var a=qi(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?Si(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Fo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==fi&&this.history.transitionTo(this.history.getCurrentLocation())},Fo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==fi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fo.prototype,Uo);var Vo=Fo;function Ho(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fo.install=function n(e){if(!n.installed||Fi!==e){n.installed=!0,Fi=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xi),e.component("RouterLink",Vi);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Fo.version="3.6.5",Fo.isNavigationFailure=Eo,Fo.NavigationFailureType=bo,Fo.START_LOCATION=fi,Gi&&window.Vue&&window.Vue.use(Fo);t(104);t(16),t(131);var Go={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,326)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,325))},Wo={"v-543835a4":()=>t.e(5).then(t.bind(null,327)),"v-41ebcf77":()=>t.e(6).then(t.bind(null,328)),"v-63fa4ab4":()=>t.e(7).then(t.bind(null,329)),"v-bba527d6":()=>t.e(10).then(t.bind(null,330)),"v-4fdbef37":()=>t.e(9).then(t.bind(null,331)),"v-3d7150a1":()=>t.e(11).then(t.bind(null,332)),"v-39e1a6ba":()=>t.e(8).then(t.bind(null,333)),"v-4cadd5a4":()=>t.e(12).then(t.bind(null,334)),"v-1a49289b":()=>t.e(13).then(t.bind(null,335)),"v-50c27a77":()=>t.e(14).then(t.bind(null,336)),"v-76e62b1a":()=>t.e(15).then(t.bind(null,337)),"v-5f2b8c5c":()=>t.e(18).then(t.bind(null,338)),"v-b0f13722":()=>t.e(16).then(t.bind(null,339)),"v-6ed74962":()=>t.e(19).then(t.bind(null,340)),"v-8a5f2b9e":()=>t.e(17).then(t.bind(null,341)),"v-153cf32e":()=>t.e(20).then(t.bind(null,342)),"v-677586e7":()=>t.e(22).then(t.bind(null,343)),"v-17d42598":()=>t.e(21).then(t.bind(null,344)),"v-6e542804":()=>t.e(23).then(t.bind(null,345)),"v-309b2a07":()=>t.e(24).then(t.bind(null,346)),"v-007fa29a":()=>t.e(25).then(t.bind(null,347)),"v-31b974f5":()=>t.e(26).then(t.bind(null,348)),"v-94d17ce6":()=>t.e(27).then(t.bind(null,349)),"v-0609ad2e":()=>t.e(28).then(t.bind(null,350)),"v-484b5d68":()=>t.e(29).then(t.bind(null,351)),"v-44272527":()=>t.e(30).then(t.bind(null,352)),"v-742f5d39":()=>t.e(31).then(t.bind(null,353)),"v-7f1fe1d3":()=>t.e(32).then(t.bind(null,354)),"v-3745d52d":()=>t.e(33).then(t.bind(null,355)),"v-56a5be0e":()=>t.e(34).then(t.bind(null,356)),"v-5dfccfb9":()=>t.e(35).then(t.bind(null,357)),"v-6e7f3c94":()=>t.e(36).then(t.bind(null,358)),"v-1a749d5a":()=>t.e(37).then(t.bind(null,359)),"v-208af354":()=>t.e(38).then(t.bind(null,360)),"v-6e6b2235":()=>t.e(39).then(t.bind(null,361)),"v-2eda8d39":()=>t.e(40).then(t.bind(null,362)),"v-64a3dc1c":()=>t.e(41).then(t.bind(null,363)),"v-4bbe2486":()=>t.e(42).then(t.bind(null,364)),"v-6d925efc":()=>t.e(43).then(t.bind(null,365)),"v-25f42d5c":()=>t.e(44).then(t.bind(null,366)),"v-1253b9e4":()=>t.e(45).then(t.bind(null,367)),"v-e42fc402":()=>t.e(46).then(t.bind(null,368)),"v-5e941770":()=>t.e(47).then(t.bind(null,369)),"v-174c68ca":()=>t.e(48).then(t.bind(null,370)),"v-35524cbe":()=>t.e(49).then(t.bind(null,371)),"v-3ec4edea":()=>t.e(50).then(t.bind(null,372)),"v-717c1b47":()=>t.e(54).then(t.bind(null,373)),"v-76db8340":()=>t.e(51).then(t.bind(null,374)),"v-4afa064f":()=>t.e(52).then(t.bind(null,375)),"v-7dee37d9":()=>t.e(53).then(t.bind(null,376)),"v-15fce9f3":()=>t.e(55).then(t.bind(null,377))};function Ko(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Zo=/-(\w)/g,Xo=Ko(n=>n.replace(Zo,(n,e)=>e?e.toUpperCase():"")),Yo=/\B([A-Z])/g,Qo=Ko(n=>n.replace(Yo,"-$1").toLowerCase()),ns=Ko(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Xo(e))):n(ns(e))||n(Qo(e))}const ts=Object.assign({},Go,Wo),as=n=>ts[n],rs=n=>Wo[n],is=n=>Go[n],os=n=>Gt.component(n);function ss(n){return es(rs,n)}function ls(n){return es(is,n)}function cs(n){return es(as,n)}function us(n){return es(os,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!us(n)&&cs(n)){const e=await cs(n)();Gt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ms=t(93),fs=t.n(ms),hs=t(94),gs=t.n(hs),vs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${gs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=ys(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return fs()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){bs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",ys(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),bs()}};function bs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function ys(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var js=t(50),Ss={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(js)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Es=t(25),ks=t.n(Es),_s={mounted(){ks.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||ks.a.start(),t()}),this.$router.afterEach(()=>{ks.a.done(),this.isSidebarOpen=!1})}};t(238),t(239);class Ts{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Cs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ts).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Is={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Os={},Ds=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},As=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Is[n]},zs=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Js=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Ps=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ds(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=As("vue");return s.jsLib.unshift(l),s},Ls=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ms=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Bs(){var n=Js(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Js(n,"vuepress-plugin-demo-block__code"),t=Js(n,"vuepress-plugin-demo-block__display"),a=Js(n,"vuepress-plugin-demo-block__footer"),r=Js(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ms(n),htmlTpl:Ds("")},o=As("react"),s=As("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Ls(i,o):Ps(i,o),u=zs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(u),u.addEventListener("click",Rs.bind(null,u,l,e,a)),As("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(As("cssLib")).concat(As("jsLib")).join(",");return zs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),As("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(As("jsLib")).join(";"),css_external:i.concat(As("cssLib")).join(";"),layout:As("codepenLayout"),js_pre_processor:As("codepenJsProcessor"),editors:As("codepenEditors")});return zs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:As("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!Os[n]){var e=zs("style",{innerHTML:n});document.body.appendChild(e),Os[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();r.appendChild(d.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Bs()}),300)}function Rs(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var $s={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Bs()},updated:function(){Bs()}},Ns="auto",qs="zoom-in",Fs="zoom-out",Us="grab",Vs="move";function Hs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Gs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ws(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ks(n,e,t){!function(n){var e=Zs,t=Xs;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Zs="transition",Xs="transform",Ys="transform",Qs="transitionend";var nl=function(){},el={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:nl,onClose:nl,onGrab:nl,onMove:nl,onRelease:nl,onBeforeOpen:nl,onBeforeClose:nl,onBeforeGrab:nl,onBeforeRelease:nl,onImageLoading:nl,onImageLoaded:nl},tl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(al(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){al(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function al(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var il={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ks(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ks(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),ll=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},cl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ws(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Us:Fs,transition:Ys+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ks(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ks(this.el,{transform:"none"})},grab:function(n,e,t){var a=ul(),r=a.x-n,i=a.y-e;Ks(this.el,{cursor:Vs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=ul(),r=a.x-n,i=a.y-e;Ks(this.el,{transition:Ys,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ks(this.el,this.styleClose)},restoreOpenStyle:function(){Ks(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=ul(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ol(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=ul(),c={x:l.x-o,y:l.y-s},u=c.x/o,p=c.y/s,d=i+Math.min(u,p);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,f=e||this.el.naturalHeight,h=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*f/(100*this.rect.height);if(d>h||d>g)return{x:h,y:g}}return{x:d,y:d}}};function ul(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Hs(n,a,e[a],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(cl),this.overlay=Object.create(il),this.handler=Object.create(tl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ll({},el,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=qs,Hs(n,"click",this.handler.click),this.options.preloadImage&&Gs(Ws(n)));return this}},{key:"config",value:function(n){return n?(ll(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Gs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var i=function n(){Hs(a,Qs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(a)};return Hs(a,Qs,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ns,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Hs(t,Qs,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Qs,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Hs(r,Qs,n,!1),a(r)};return Hs(r,Qs,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Vs,this.target.move(n,e,t);var r=this.target.el,i=function n(){Hs(r,Qs,n,!1),a(r)};return Hs(r,Qs,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ns,this.target.restoreOpenStyle();var a=function a(){Hs(t,Qs,a,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Qs,a),this}}}]),n}();const ml=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),fl=Number("500");class hl{constructor(){this.instance=new dl(ml)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=fl){setTimeout(()=>this.update(n),e)}}var gl=[vs,Ss,_s,Cs,$s,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],vl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bl=t(7),yl=Object(bl.a)(vl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(yl,"mixins",gl);const xl=[{name:"v-543835a4",path:"/pages/7daf0d/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-543835a4").then(t)}},{path:"/pages/7daf0d/index.html",redirect:"/pages/7daf0d/"},{path:"/0101.Java 核心知识/01.Java 基础知识/00.Java开发环境.html",redirect:"/pages/7daf0d/"},{name:"v-41ebcf77",path:"/pages/2950ba/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-41ebcf77").then(t)}},{path:"/pages/2950ba/index.html",redirect:"/pages/2950ba/"},{path:"/0101.Java 核心知识/01.Java 基础知识/01.Java基础语法.html",redirect:"/pages/2950ba/"},{name:"v-63fa4ab4",path:"/pages/55d693/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-63fa4ab4").then(t)}},{path:"/pages/55d693/index.html",redirect:"/pages/55d693/"},{path:"/0101.Java 核心知识/01.Java 基础知识/02.Java基本数据类型.html",redirect:"/pages/55d693/"},{name:"v-bba527d6",path:"/pages/155518/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-bba527d6").then(t)}},{path:"/pages/155518/index.html",redirect:"/pages/155518/"},{path:"/0101.Java 核心知识/01.Java 基础知识/05.Java数组.html",redirect:"/pages/155518/"},{name:"v-4fdbef37",path:"/pages/7a3ffc/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-4fdbef37").then(t)}},{path:"/pages/7a3ffc/index.html",redirect:"/pages/7a3ffc/"},{path:"/0101.Java 核心知识/01.Java 基础知识/04.Java方法.html",redirect:"/pages/7a3ffc/"},{name:"v-3d7150a1",path:"/pages/979887/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-3d7150a1").then(t)}},{path:"/pages/979887/index.html",redirect:"/pages/979887/"},{path:"/0101.Java 核心知识/01.Java 基础知识/06.Java枚举.html",redirect:"/pages/979887/"},{name:"v-39e1a6ba",path:"/pages/3e1661/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-39e1a6ba").then(t)}},{path:"/pages/3e1661/index.html",redirect:"/pages/3e1661/"},{path:"/0101.Java 核心知识/01.Java 基础知识/03.Java面向对象.html",redirect:"/pages/3e1661/"},{name:"v-4cadd5a4",path:"/pages/fb4f8c/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-4cadd5a4").then(t)}},{path:"/pages/fb4f8c/index.html",redirect:"/pages/fb4f8c/"},{path:"/0101.Java 核心知识/01.Java 基础知识/07.Java控制语句.html",redirect:"/pages/fb4f8c/"},{name:"v-1a49289b",path:"/pages/37415c/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-1a49289b").then(t)}},{path:"/pages/37415c/index.html",redirect:"/pages/37415c/"},{path:"/0101.Java 核心知识/01.Java 基础知识/08.Java异常.html",redirect:"/pages/37415c/"},{name:"v-50c27a77",path:"/pages/33a820/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-50c27a77").then(t)}},{path:"/pages/33a820/index.html",redirect:"/pages/33a820/"},{path:"/0101.Java 核心知识/01.Java 基础知识/09.Java泛型.html",redirect:"/pages/33a820/"},{name:"v-76e62b1a",path:"/pages/0d066a/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-76e62b1a").then(t)}},{path:"/pages/0d066a/index.html",redirect:"/pages/0d066a/"},{path:"/0101.Java 核心知识/01.Java 基础知识/10.Java反射.html",redirect:"/pages/0d066a/"},{name:"v-5f2b8c5c",path:"/pages/47aa52/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-5f2b8c5c").then(t)}},{path:"/pages/47aa52/index.html",redirect:"/pages/47aa52/"},{path:"/0101.Java 核心知识/01.Java 基础知识/99.参考和来源.html",redirect:"/pages/47aa52/"},{name:"v-b0f13722",path:"/pages/ecc011/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-b0f13722").then(t)}},{path:"/pages/ecc011/index.html",redirect:"/pages/ecc011/"},{path:"/0101.Java 核心知识/01.Java 基础知识/11.Java注解.html",redirect:"/pages/ecc011/"},{name:"v-6ed74962",path:"/pages/7ea877/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-6ed74962").then(t)}},{path:"/pages/7ea877/index.html",redirect:"/pages/7ea877/"},{path:"/0102.Java 版本特性/01.Java 8 新特性/01.Overview.html",redirect:"/pages/7ea877/"},{name:"v-8a5f2b9e",path:"/pages/bc583c/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-8a5f2b9e").then(t)}},{path:"/pages/bc583c/index.html",redirect:"/pages/bc583c/"},{path:"/0101.Java 核心知识/01.Java 基础知识/42.JavaString类型.html",redirect:"/pages/bc583c/"},{name:"v-153cf32e",path:"/pages/81ea3b/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-153cf32e").then(t)}},{path:"/pages/81ea3b/index.html",redirect:"/pages/81ea3b/"},{path:"/0102.Java 版本特性/01.Java 8 新特性/02.Lambda 表达式.html",redirect:"/pages/81ea3b/"},{name:"v-677586e7",path:"/pages/bece42/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-677586e7").then(t)}},{path:"/pages/bece42/index.html",redirect:"/pages/bece42/"},{path:"/0103.JVM 相关/01.Java 类加载机制/01.Overview.html",redirect:"/pages/bece42/"},{name:"v-17d42598",path:"/pages/ce7867/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-17d42598").then(t)}},{path:"/pages/ce7867/index.html",redirect:"/pages/ce7867/"},{path:"/0102.Java 版本特性/01.Java 8 新特性/03.Optional.html",redirect:"/pages/ce7867/"},{name:"v-6e542804",path:"/pages/cef328/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-6e542804").then(t)}},{path:"/pages/cef328/index.html",redirect:"/pages/cef328/"},{path:"/02.算法/01.算法基础/01.数据结构.html",redirect:"/pages/cef328/"},{name:"v-309b2a07",path:"/pages/1b68b5/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-309b2a07").then(t)}},{path:"/pages/1b68b5/index.html",redirect:"/pages/1b68b5/"},{path:"/0201.速查表/01.速查表.html",redirect:"/pages/1b68b5/"},{name:"v-007fa29a",path:"/pages/5bc7d8/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-007fa29a").then(t)}},{path:"/pages/5bc7d8/index.html",redirect:"/pages/5bc7d8/"},{path:"/0201.速查表/0200001.Shell.html",redirect:"/pages/5bc7d8/"},{name:"v-31b974f5",path:"/pages/918089/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-31b974f5").then(t)}},{path:"/pages/918089/index.html",redirect:"/pages/918089/"},{path:"/0201.速查表/0200003.Go.html",redirect:"/pages/918089/"},{name:"v-94d17ce6",path:"/pages/17da4a/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-94d17ce6").then(t)}},{path:"/pages/17da4a/index.html",redirect:"/pages/17da4a/"},{path:"/0303.开发 - 代码设计/01.设计模式/00.介绍.html",redirect:"/pages/17da4a/"},{name:"v-0609ad2e",path:"/pages/6278f7/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-0609ad2e").then(t)}},{path:"/pages/6278f7/index.html",redirect:"/pages/6278f7/"},{path:"/0303.开发 - 代码设计/01.设计模式/01.单例模式.html",redirect:"/pages/6278f7/"},{name:"v-484b5d68",path:"/pages/48ae87/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-484b5d68").then(t)}},{path:"/pages/48ae87/index.html",redirect:"/pages/48ae87/"},{path:"/0303.开发 - 代码设计/01.设计模式/02.工厂模式.html",redirect:"/pages/48ae87/"},{name:"v-44272527",path:"/pages/ea53e7/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-44272527").then(t)}},{path:"/pages/ea53e7/index.html",redirect:"/pages/ea53e7/"},{path:"/0303.开发 - 代码设计/01.设计模式/03.建造者模式.html",redirect:"/pages/ea53e7/"},{name:"v-742f5d39",path:"/pages/422210/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-742f5d39").then(t)}},{path:"/pages/422210/index.html",redirect:"/pages/422210/"},{path:"/0501.工具-开发工具/01.开发工具/01.Overview.html",redirect:"/pages/422210/"},{name:"v-7f1fe1d3",path:"/pages/30becd/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-7f1fe1d3").then(t)}},{path:"/pages/30becd/index.html",redirect:"/pages/30becd/"},{path:"/0502.工具-Git/01.Git/01.Overview.html",redirect:"/pages/30becd/"},{name:"v-3745d52d",path:"/pages/e71389/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-3745d52d").then(t)}},{path:"/pages/e71389/index.html",redirect:"/pages/e71389/"},{path:"/0601.编程语言 - Dart/01.Dart/01.环境搭建.html",redirect:"/pages/e71389/"},{name:"v-56a5be0e",path:"/pages/b214ca/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-56a5be0e").then(t)}},{path:"/pages/b214ca/index.html",redirect:"/pages/b214ca/"},{path:"/0601.编程语言 - Dart/01.Dart/02.变量.html",redirect:"/pages/b214ca/"},{name:"v-5dfccfb9",path:"/pages/e07dc6/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-5dfccfb9").then(t)}},{path:"/pages/e07dc6/index.html",redirect:"/pages/e07dc6/"},{path:"/0601.编程语言 - Dart/01.Dart/03.类型.html",redirect:"/pages/e07dc6/"},{name:"v-6e7f3c94",path:"/pages/f2e32e/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-6e7f3c94").then(t)}},{path:"/pages/f2e32e/index.html",redirect:"/pages/f2e32e/"},{path:"/96.工具/01.Docker/01.介绍.html",redirect:"/pages/f2e32e/"},{name:"v-1a749d5a",path:"/pages/abbe88/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-1a749d5a").then(t)}},{path:"/pages/abbe88/index.html",redirect:"/pages/abbe88/"},{path:"/96.工具/01.Docker/02.快速上手.html",redirect:"/pages/abbe88/"},{name:"v-208af354",path:"/pages/6b922f/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-208af354").then(t)}},{path:"/pages/6b922f/index.html",redirect:"/pages/6b922f/"},{path:"/96.工具/01.Docker/03.Docker 镜像.html",redirect:"/pages/6b922f/"},{name:"v-6e6b2235",path:"/pages/7e5b28/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-6e6b2235").then(t)}},{path:"/pages/7e5b28/index.html",redirect:"/pages/7e5b28/"},{path:"/96.工具/01.Docker/04.Docker 容器.html",redirect:"/pages/7e5b28/"},{name:"v-2eda8d39",path:"/pages/571205/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-2eda8d39").then(t)}},{path:"/pages/571205/index.html",redirect:"/pages/571205/"},{path:"/96.工具/01.Docker/05.Dockerfile.html",redirect:"/pages/571205/"},{name:"v-64a3dc1c",path:"/pages/ee7caf/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-64a3dc1c").then(t)}},{path:"/pages/ee7caf/index.html",redirect:"/pages/ee7caf/"},{path:"/96.工具/01.Docker/06.Docker compose.html",redirect:"/pages/ee7caf/"},{name:"v-4bbe2486",path:"/pages/c6bb18/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-4bbe2486").then(t)}},{path:"/pages/c6bb18/index.html",redirect:"/pages/c6bb18/"},{path:"/96.工具/01.Docker/99.玩转Docker.html",redirect:"/pages/c6bb18/"},{name:"v-6d925efc",path:"/pages/d9e60d/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-6d925efc").then(t)}},{path:"/pages/d9e60d/index.html",redirect:"/pages/d9e60d/"},{path:"/97.笔记/01.SSL 证书申请.html",redirect:"/pages/d9e60d/"},{name:"v-25f42d5c",path:"/pages/71a585/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-25f42d5c").then(t)}},{path:"/pages/71a585/index.html",redirect:"/pages/71a585/"},{path:"/97.笔记/02.Postgresql 安装和访问.html",redirect:"/pages/71a585/"},{name:"v-1253b9e4",path:"/pages/64f05e/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-1253b9e4").then(t)}},{path:"/pages/64f05e/index.html",redirect:"/pages/64f05e/"},{path:"/97.笔记/03.Linux 设置虚拟内存.html",redirect:"/pages/64f05e/"},{name:"v-e42fc402",path:"/pages/678b57/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-e42fc402").then(t)}},{path:"/pages/678b57/index.html",redirect:"/pages/678b57/"},{path:"/97.笔记/04.科学上网.html",redirect:"/pages/678b57/"},{name:"v-5e941770",path:"/pages/1e1742/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-5e941770").then(t)}},{path:"/pages/1e1742/index.html",redirect:"/pages/1e1742/"},{path:"/97.笔记/05.基于Maven打包独立jar.html",redirect:"/pages/1e1742/"},{name:"v-174c68ca",path:"/pages/501eec/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-174c68ca").then(t)}},{path:"/pages/501eec/index.html",redirect:"/pages/501eec/"},{path:"/97.笔记/06.ubuntu server 20.04 设置root用户登录.html",redirect:"/pages/501eec/"},{name:"v-35524cbe",path:"/pages/20d224/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-35524cbe").then(t)}},{path:"/pages/20d224/index.html",redirect:"/pages/20d224/"},{path:"/98.书签/01.资源站点.html",redirect:"/pages/20d224/"},{name:"v-3ec4edea",path:"/pages/8cbb5d/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-3ec4edea").then(t)}},{path:"/pages/8cbb5d/index.html",redirect:"/pages/8cbb5d/"},{path:"/98.书签/02.常用工具.html",redirect:"/pages/8cbb5d/"},{name:"v-717c1b47",path:"/blog/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-717c1b47").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-76db8340",path:"/pages/0b60af/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-76db8340").then(t)}},{path:"/pages/0b60af/index.html",redirect:"/pages/0b60af/"},{path:"/98.书签/03.技术社区&博客.html",redirect:"/pages/0b60af/"},{name:"v-4afa064f",path:"/pages/1b5e98/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-4afa064f").then(t)}},{path:"/pages/1b5e98/index.html",redirect:"/pages/1b5e98/"},{path:"/99.关于/01.关于/01.关于 - 我.html",redirect:"/pages/1b5e98/"},{name:"v-7dee37d9",path:"/pages/860e31/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-7dee37d9").then(t)}},{path:"/pages/860e31/index.html",redirect:"/pages/860e31/"},{path:"/99.关于/01.关于/02.关于 - 本站.html",redirect:"/pages/860e31/"},{name:"v-15fce9f3",path:"/",component:yl,beforeEnter:(n,e,t)=>{ps("Layout","v-15fce9f3").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:yl}],wl={title:"备忘录",description:"一个基于VuePress的备忘录文档",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,java"}],["meta",{name:"theme-color",content:"#11a8cd"}],["script",{src:"/js/baiduCode.js"}]],pages:[{title:"Java 开发环境",frontmatter:{title:"Java 开发环境",date:"2018-08-29T17:28:34.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE"],permalink:"/pages/7daf0d/",abbrlink:"3037f135"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/00.Java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/00.Java开发环境.md",key:"v-543835a4",path:"/pages/7daf0d/",headers:[{level:2,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:61},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:101},{level:2,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:48},{level:3,title:"Windows",slug:"windows",normalizedTitle:"windows",charIndex:187},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:149},{level:2,title:"测试安装成功",slug:"测试安装成功",normalizedTitle:"测试安装成功",charIndex:574},{level:2,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:631},{level:2,title:"第一个程序：Hello World",slug:"第一个程序-hello-world",normalizedTitle:"第一个程序：hello world",charIndex:1073}],headersStr:"下载 安装 环境变量 Windows Linux 测试安装成功 开发工具 第一个程序：Hello World",content:'# Java 开发环境\n\n> 📌 关键词： JAVA_HOME、CLASSPATH、Path、环境变量、IDE\n\n\n# 下载\n\n进入 JDK 官方下载地址 ，根据自己的环境选择下载所需版本。\n\n\n# 安装\n\nwindows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。\n\nLinux 环境的 jdk 包，解压到本地即可。\n\n\n# 环境变量\n\n\n# Windows\n\n计算机 > 属性 > 高级系统设置 > 环境变量\n\n添加以下环境变量：\n\nJAVA_HOME：C:\\Program Files (x86)\\Java\\jdk1.8.0_91 （根据自己的实际路径配置）\n\nCLASSPATH：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; （注意前面有个"."）\n\nPath：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n\n# Linux\n\n执行 vi /etc/profile ，编辑环境变量文件\n\n添加两行：\n\nexport JAVA_HOME=path/to/java\nexport PATH=JAVA_HOME/bin:JAVA_HOME/jre/bin:\n\n\n执行 source /etc/profile ，立即生效。\n\n\n# 测试安装成功\n\n执行命令 java -version ，如果安装成功，会打印当前 java 的版本信息。\n\n\n# 开发工具\n\n工欲善其事，必先利其器。编写 Java 程序，当然有必要选择一个合适的 IDE。\n\nIDE（Integrated Development Environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。\n\n常见的 Java IDE 如下：\n\n * Eclipse - 一个开放源代码的、基于 Java 的可扩展开发平台。\n * NetBeans - 开放源码的 Java 集成开发环境，适用于各种客户机和 Web 应用。\n * IntelliJ IDEA - 在代码自动提示、代码分析等方面的具有很好的功能。\n * MyEclipse - 由 Genuitec 公司开发的一款商业化软件，是应用比较广泛的 Java 应用程序集成开发环境。\n * EditPlus - 如果正确配置 Java 的编译器“Javac”以及解释器“Java”后，可直接使用 EditPlus 编译执行 Java 程序。\n\n\n# 第一个程序：Hello World\n\n添加 HelloWorld.java 文件，内容如下：\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println("Hello World");\n    }\n}\n\n\n执行后，控制台输出：\n\nHello World\n',normalizedContent:'# java 开发环境\n\n> 📌 关键词： java_home、classpath、path、环境变量、ide\n\n\n# 下载\n\n进入 jdk 官方下载地址 ，根据自己的环境选择下载所需版本。\n\n\n# 安装\n\nwindows 环境的 jdk 包是 exe 安装文件，启动后根据安装向导安装即可。\n\nlinux 环境的 jdk 包，解压到本地即可。\n\n\n# 环境变量\n\n\n# windows\n\n计算机 > 属性 > 高级系统设置 > 环境变量\n\n添加以下环境变量：\n\njava_home：c:\\program files (x86)\\java\\jdk1.8.0_91 （根据自己的实际路径配置）\n\nclasspath：.;%java_home%\\lib\\dt.jar;%java_home%\\lib\\tools.jar; （注意前面有个"."）\n\npath：%java_home%\\bin;%java_home%\\jre\\bin;\n\n\n# linux\n\n执行 vi /etc/profile ，编辑环境变量文件\n\n添加两行：\n\nexport java_home=path/to/java\nexport path=java_home/bin:java_home/jre/bin:\n\n\n执行 source /etc/profile ，立即生效。\n\n\n# 测试安装成功\n\n执行命令 java -version ，如果安装成功，会打印当前 java 的版本信息。\n\n\n# 开发工具\n\n工欲善其事，必先利其器。编写 java 程序，当然有必要选择一个合适的 ide。\n\nide（integrated development environment，即集成开发环境）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。\n\n常见的 java ide 如下：\n\n * eclipse - 一个开放源代码的、基于 java 的可扩展开发平台。\n * netbeans - 开放源码的 java 集成开发环境，适用于各种客户机和 web 应用。\n * intellij idea - 在代码自动提示、代码分析等方面的具有很好的功能。\n * myeclipse - 由 genuitec 公司开发的一款商业化软件，是应用比较广泛的 java 应用程序集成开发环境。\n * editplus - 如果正确配置 java 的编译器“javac”以及解释器“java”后，可直接使用 editplus 编译执行 java 程序。\n\n\n# 第一个程序：hello world\n\n添加 helloworld.java 文件，内容如下：\n\npublic class helloworld {\n    public static void main(string[] args) {\n        system.out.println("hello world");\n    }\n}\n\n\n执行后，控制台输出：\n\nhello world\n',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Java 基础语法特性",frontmatter:{title:"Java 基础语法特性",date:"2022-01-25T07:31:16.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE"],permalink:"/pages/2950ba/",abbrlink:"d3be5ffb"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01.Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/01.Java基础语法.md",key:"v-41ebcf77",path:"/pages/2950ba/",headers:[{level:2,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:18},{level:2,title:"基本数据类型",slug:"基本数据类型",normalizedTitle:"基本数据类型",charIndex:329},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:370},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:2504},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:2537},{level:2,title:"操作符",slug:"操作符",normalizedTitle:"操作符",charIndex:2570},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:401},{level:2,title:"控制语句",slug:"控制语句",normalizedTitle:"控制语句",charIndex:2652},{level:2,title:"异常",slug:"异常",normalizedTitle:"异常",charIndex:2684},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:2719},{level:2,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:2752},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:2792},{level:2,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:2831}],headersStr:"注释 基本数据类型 变量 数组 枚举 操作符 方法 控制语句 异常 泛型 反射 注解 序列化",content:'# Java 基础语法特性\n\n\n# 注释\n\n空白行，或者注释的内容，都会被 Java 编译器忽略掉。\n\nJava 支持多种注释方式，下面的示例展示了各种注释的使用方式：\n\npublic class HelloWorld {\n    /*\n     * JavaDoc 注释\n     */\n    public static void main(String[] args) {\n        // 单行注释\n        /* 多行注释：\n           1. 注意点a\n           2. 注意点b\n         */\n        System.out.println("Hello World");\n    }\n}\n\n\n\n# 基本数据类型\n\n\n\n> 👉 扩展阅读：深入理解 Java 基本数据类型\n\n\n# 变量\n\nJava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。   静态变量可以通过：ClassName.VariableName 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n变量修饰符\n\n * 访问级别修饰符\n   * 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符\n   * 如果变量是类变量，需要添加 static 修饰\n * final\n   * 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 数组\n\n\n\n> 👉 扩展阅读：深入理解 Java 数组\n\n\n# 枚举\n\n\n\n> 👉 扩展阅读：深入理解 Java 枚举\n\n\n# 操作符\n\nJava 中支持的操作符类型如下：\n\n\n\n> 👉 扩展阅读：Java 操作符\n\n\n# 方法\n\n\n\n> 👉 扩展阅读：深入理解 Java 方法\n\n\n# 控制语句\n\n\n\n> 👉 扩展阅读：Java 控制语句\n\n\n# 异常\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 异常\n\n\n# 泛型\n\n\n\n> 👉 扩展阅读：深入理解 Java 泛型\n\n\n# 反射\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 反射和动态代理\n\n\n# 注解\n\n\n\n\n\n\n\n\n\n> 👉 扩展阅读：深入理解 Java 注解\n\n\n# 序列化\n\n\n\n> 👉 扩展阅读：深入理解 Java 序列化',normalizedContent:'# java 基础语法特性\n\n\n# 注释\n\n空白行，或者注释的内容，都会被 java 编译器忽略掉。\n\njava 支持多种注释方式，下面的示例展示了各种注释的使用方式：\n\npublic class helloworld {\n    /*\n     * javadoc 注释\n     */\n    public static void main(string[] args) {\n        // 单行注释\n        /* 多行注释：\n           1. 注意点a\n           2. 注意点b\n         */\n        system.out.println("hello world");\n    }\n}\n\n\n\n# 基本数据类型\n\n\n\n> 👉 扩展阅读：深入理解 java 基本数据类型\n\n\n# 变量\n\njava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：obejectreference.variablename。   静态变量可以通过：classname.variablename 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n变量修饰符\n\n * 访问级别修饰符\n   * 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符\n   * 如果变量是类变量，需要添加 static 修饰\n * final\n   * 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 数组\n\n\n\n> 👉 扩展阅读：深入理解 java 数组\n\n\n# 枚举\n\n\n\n> 👉 扩展阅读：深入理解 java 枚举\n\n\n# 操作符\n\njava 中支持的操作符类型如下：\n\n\n\n> 👉 扩展阅读：java 操作符\n\n\n# 方法\n\n\n\n> 👉 扩展阅读：深入理解 java 方法\n\n\n# 控制语句\n\n\n\n> 👉 扩展阅读：java 控制语句\n\n\n# 异常\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 异常\n\n\n# 泛型\n\n\n\n> 👉 扩展阅读：深入理解 java 泛型\n\n\n# 反射\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 反射和动态代理\n\n\n# 注解\n\n\n\n\n\n\n\n\n\n> 👉 扩展阅读：深入理解 java 注解\n\n\n# 序列化\n\n\n\n> 👉 扩展阅读：深入理解 java 序列化',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 基本数据类型",frontmatter:{title:"深入理解 Java 基本数据类型",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","数据类型"],permalink:"/pages/55d693/",abbrlink:"98de92a0"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02.Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/02.Java基本数据类型.md",key:"v-63fa4ab4",path:"/pages/55d693/",headers:[{level:2,title:"数据类型分类",slug:"数据类型分类",normalizedTitle:"数据类型分类",charIndex:25},{level:3,title:"值类型",slug:"值类型",normalizedTitle:"值类型",charIndex:53},{level:3,title:"值类型和引用类型的区别",slug:"值类型和引用类型的区别",normalizedTitle:"值类型和引用类型的区别",charIndex:893},{level:2,title:"数据转换",slug:"数据转换",normalizedTitle:"数据转换",charIndex:1228},{level:3,title:"自动转换",slug:"自动转换",normalizedTitle:"自动转换",charIndex:1258},{level:3,title:"强制转换",slug:"强制转换",normalizedTitle:"强制转换",charIndex:1266},{level:2,title:"装箱和拆箱",slug:"装箱和拆箱",normalizedTitle:"装箱和拆箱",charIndex:2090},{level:3,title:"包装类、装箱、拆箱",slug:"包装类、装箱、拆箱",normalizedTitle:"包装类、装箱、拆箱",charIndex:2100},{level:3,title:"自动装箱、自动拆箱",slug:"自动装箱、自动拆箱",normalizedTitle:"自动装箱、自动拆箱",charIndex:2520},{level:3,title:"装箱、拆箱的应用和注意点",slug:"装箱、拆箱的应用和注意点",normalizedTitle:"装箱、拆箱的应用和注意点",charIndex:2952},{level:4,title:"装箱、拆箱应用场景",slug:"装箱、拆箱应用场景",normalizedTitle:"装箱、拆箱应用场景",charIndex:2968},{level:4,title:"装箱、拆箱应用注意点",slug:"装箱、拆箱应用注意点",normalizedTitle:"装箱、拆箱应用注意点",charIndex:5123},{level:2,title:"判等问题",slug:"判等问题",normalizedTitle:"判等问题",charIndex:4202},{level:3,title:"包装类的判等",slug:"包装类的判等",normalizedTitle:"包装类的判等",charIndex:5495},{level:3,title:"String 的判等",slug:"string-的判等",normalizedTitle:"string 的判等",charIndex:8128},{level:3,title:"实现 equals",slug:"实现-equals",normalizedTitle:"实现 equals",charIndex:10005},{level:3,title:"hashCode 和 equals 要配对实现",slug:"hashcode-和-equals-要配对实现",normalizedTitle:"hashcode 和 equals 要配对实现",charIndex:10759},{level:3,title:"compareTo 和 equals 的逻辑一致性",slug:"compareto-和-equals-的逻辑一致性",normalizedTitle:"compareto 和 equals 的逻辑一致性",charIndex:11281},{level:3,title:"小心 Lombok 生成代码的“坑”",slug:"小心-lombok-生成代码的-坑",normalizedTitle:"小心 lombok 生成代码的“坑”",charIndex:12633},{level:2,title:"数值计算",slug:"数值计算",normalizedTitle:"数值计算",charIndex:12819},{level:3,title:"浮点数计算问题",slug:"浮点数计算问题",normalizedTitle:"浮点数计算问题",charIndex:12828},{level:3,title:"浮点数精度和格式化",slug:"浮点数精度和格式化",normalizedTitle:"浮点数精度和格式化",charIndex:14202},{level:3,title:"BigDecimal 判等问题",slug:"bigdecimal-判等问题",normalizedTitle:"bigdecimal 判等问题",charIndex:15068},{level:3,title:"数值溢出",slug:"数值溢出",normalizedTitle:"数值溢出",charIndex:16380},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:17151}],headersStr:"数据类型分类 值类型 值类型和引用类型的区别 数据转换 自动转换 强制转换 装箱和拆箱 包装类、装箱、拆箱 自动装箱、自动拆箱 装箱、拆箱的应用和注意点 装箱、拆箱应用场景 装箱、拆箱应用注意点 判等问题 包装类的判等 String 的判等 实现 equals hashCode 和 equals 要配对实现 compareTo 和 equals 的逻辑一致性 小心 Lombok 生成代码的“坑” 数值计算 浮点数计算问题 浮点数精度和格式化 BigDecimal 判等问题 数值溢出 参考资料",content:'# 深入理解 Java 基本数据类型\n\n\n\n\n# 数据类型分类\n\nJava 中的数据类型有两类：\n\n * 值类型（又叫内置数据类型，基本数据类型）\n * 引用类型（除值类型以外，都是引用类型，包括 String、数组）\n\n\n# 值类型\n\nJava 语言提供了 8 种基本类型，大致分为 4 类\n\n基本数据类型    分类    比特数    默认值        取值范围                            说明\nboolean   布尔型   8 位    false      {false, true}                   \nchar      字符型   16 位   \'\\u0000\'   [0, $2^{16} - 1$]               存储 Unicode 码，用单引号赋值\nbyte      整数型   8 位    0          [-$2^7$, $2^7 - 1$]             \nshort     整数型   16 位   0          [-$2^{15}$, $2^{15} - 1$]       \nint       整数型   32 位   0          [-$2^{31}$, $2^{31} - 1$]       \nlong      整数型   64 位   0L         [-$2^{63}$, $2^{63} - 1$]       赋值时一般在数字后加上 l 或 L\nfloat     浮点型   32 位   +0.0F      [$2^{-149}$, $2^{128} - 1$]     赋值时必须在数字后加上 f 或 F\ndouble    浮点型   64 位   +0.0D      [$2^{-1074}$, $2^{1024} - 1$]   赋值时一般在数字后加 d 或 D\n\n尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。\n\n在这些基本类型中，boolean 和 char 是唯二的无符号类型。\n\n\n# 值类型和引用类型的区别\n\n * 从概念方面来说\n   * 基本类型：变量名指向具体的数值。\n   * 引用类型：变量名指向存数据对象的内存地址。\n * 从内存方面来说\n   * 基本类型：变量在声明之后，Java 就会立刻分配给他内存空间。\n   * 引用类型：它以特殊的方式（类似 C 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。\n * 从使用方面来说\n   * 基本类型：使用时需要赋具体值,判断时使用 == 号。\n   * 引用类型：使用时可以赋 null，判断时使用 equals 方法。\n\n> 👉 扩展阅读：Java 基本数据类型和引用类型\n> \n> 这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。\n\n\n# 数据转换\n\nJava 中，数据类型转换有两种方式：\n\n * 自动转换\n * 强制转换\n\n\n# 自动转换\n\n一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 JAVA 允许用户对基本类型做有限度的类型转换。\n\n如果符合以下条件，则 JAVA 将会自动做类型转换：\n\n * 由小数据转换为大数据\n   \n   显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。\n   \n   所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。\n   \n   反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为扩大转换。\n   \n   这些类型由“小”到“大”分别为：(byte，short，char) < int < long < float < double。\n   \n   这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。\n\n * 转换前后的数据类型要兼容\n   \n   由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。\n\n * 整型类型和浮点型进行计算后，结果会转为浮点类型\n\n示例：\n\nlong x = 30;\nfloat y = 14.3f;\nSystem.out.println("x/y = " + x/y);\n\n\n输出：\n\nx/y = 1.9607843\n\n\n可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。\n\n\n# 强制转换\n\n在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。\n\n强制转换使用括号 () 。\n\n引用类型也可以使用强制转换。\n\n示例：\n\nfloat f = 25.5f;\nint x = (int)f;\nSystem.out.println("x = " + x);\n\n\n\n# 装箱和拆箱\n\n\n# 包装类、装箱、拆箱\n\nJava 中为每一种基本数据类型提供了相应的包装类，如下：\n\nByte <-> byte\nShort <-> short\nInteger <-> int\nLong <-> long\nFloat <-> float\nDouble <-> double\nCharacter <-> char\nBoolean <-> boolean\n\n\n引入包装类的目的就是：提供一种机制，使得基本数据类型可以与引用类型互相转换。\n\n基本数据类型与包装类的转换被称为装箱和拆箱。\n\n * 装箱（boxing）是将值类型转换为引用类型。例如：int 转 Integer\n   * 装箱过程是通过调用包装类的 valueOf 方法实现的。\n * 拆箱（unboxing）是将引用类型转换为值类型。例如：Integer 转 int\n   * 拆箱过程是通过调用包装类的 xxxValue 方法实现的。（xxx 代表对应的基本数据类型）。\n\n\n# 自动装箱、自动拆箱\n\n基本数据（Primitive）型的自动装箱（boxing）拆箱（unboxing）自 JDK 5 开始提供的功能。\n\n自动装箱与拆箱的机制可以让我们在 Java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。 因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 GC 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。\n\nJDK 5 之前的形式：\n\nInteger i1 = new Integer(10); // 非自动装箱\n\n\nJDK 5 之后：\n\nInteger i2 = 10; // 自动装箱\n\n\nJava 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。\n\n> 👉 扩展阅读：深入剖析 Java 中的装箱和拆箱\n> \n> 结合示例，一步步阐述装箱和拆箱原理。\n\n\n# 装箱、拆箱的应用和注意点\n\n# 装箱、拆箱应用场景\n\n * 一种最普通的场景是：调用一个含类型为 Object 参数的方法，该 Object 可支持任意类型（因为 Object 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 Integer 装箱。\n * 另一种用法是：一个非泛型的容器，同样是为了保证通用，而将元素类型定义为 Object。于是，要将值类型数据加入容器时，需要装箱。\n * 当 == 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。\n\n【示例】装箱、拆箱示例\n\nInteger i1 = 10; // 自动装箱\nInteger i2 = new Integer(10); // 非自动装箱\nInteger i3 = Integer.valueOf(10); // 非自动装箱\nint i4 = new Integer(10); // 自动拆箱\nint i5 = i2.intValue(); // 非自动拆箱\nSystem.out.println("i1 = [" + i1 + "]");\nSystem.out.println("i2 = [" + i2 + "]");\nSystem.out.println("i3 = [" + i3 + "]");\nSystem.out.println("i4 = [" + i4 + "]");\nSystem.out.println("i5 = [" + i5 + "]");\nSystem.out.println("i1 == i2 is [" + (i1 == i2) + "]");\nSystem.out.println("i1 == i4 is [" + (i1 == i4) + "]"); // 自动拆箱\n// Output:\n// i1 = [10]\n// i2 = [10]\n// i3 = [10]\n// i4 = [10]\n// i5 = [10]\n// i1 == i2 is [false]\n// i1 == i4 is [true]\n\n\n【说明】\n\n上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 i1 == i2 is [false 而 i1 == i4 is [true] ？\n\n原因在于：\n\n * i1、i2 都是包装类，使用 == 时，Java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 equals 方法。\n * i1 是包装类，i4 是基础数据类型，使用 == 时，Java 会将两个 i1 这个包装类对象自动拆箱为一个 int 值，再代入到 == 运算表达式中计算；最终，相当于两个 int 进行比较，由于值相同，所以结果相等。\n\n【示例】包装类判等问题\n\nInteger a = 127; //Integer.valueOf(127)\nInteger b = 127; //Integer.valueOf(127)\nlog.info("\\nInteger a = 127;\\nInteger b = 127;\\na == b ? {}", a == b);    // true\n\nInteger c = 128; //Integer.valueOf(128)\nInteger d = 128; //Integer.valueOf(128)\nlog.info("\\nInteger c = 128;\\nInteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-XX:AutoBoxCacheMax=1000再试试\n\nInteger e = 127; //Integer.valueOf(127)\nInteger f = new Integer(127); //new instance\nlog.info("\\nInteger e = 127;\\nInteger f = new Integer(127);\\ne == f ? {}", e == f);   //false\n\nInteger g = new Integer(127); //new instance\nInteger h = new Integer(127); //new instance\nlog.info("\\nInteger g = new Integer(127);\\nInteger h = new Integer(127);\\ng == h ? {}", g == h);  //false\n\nInteger i = 128; //unbox\nint j = 128;\nlog.info("\\nInteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 == 却并非总是返回 true。\n\n# 装箱、拆箱应用注意点\n\n 1. 装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以应该尽量避免装箱。\n 2. 基础数据类型的比较操作使用 ==，包装类的比较操作使用 equals 方法。\n\n\n# 判等问题\n\nJava 中，通常使用 equals 或 == 进行判等操作。equals 是方法而 == 是操作符。此外，二者使用也是有区别的：\n\n * 对基本类型，比如 int、long，进行判等，只能使用 ==，比较的是字面值。因为基本类型的值就是其数值。\n * 对引用类型，比如 Integer、Long 和 String，进行判等，需要使用 equals 进行内容判等。因为引用类型的直接值是指针，使用 == 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。\n\n\n# 包装类的判等\n\n我们通过一个示例来深入研究一下判等问题。\n\n【示例】包装类的判等\n\nInteger a = 127; //Integer.valueOf(127)\nInteger b = 127; //Integer.valueOf(127)\nlog.info("\\nInteger a = 127;\\nInteger b = 127;\\na == b ? {}", a == b);    // true\n\nInteger c = 128; //Integer.valueOf(128)\nInteger d = 128; //Integer.valueOf(128)\nlog.info("\\nInteger c = 128;\\nInteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-XX:AutoBoxCacheMax=1000再试试\n\nInteger e = 127; //Integer.valueOf(127)\nInteger f = new Integer(127); //new instance\nlog.info("\\nInteger e = 127;\\nInteger f = new Integer(127);\\ne == f ? {}", e == f);   //false\n\nInteger g = new Integer(127); //new instance\nInteger h = new Integer(127); //new instance\nlog.info("\\nInteger g = new Integer(127);\\nInteger h = new Integer(127);\\ng == h ? {}", g == h);  //false\n\nInteger i = 128; //unbox\nint j = 128;\nlog.info("\\nInteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n第一个案例中，编译器会把 Integer a = 127 转换为 Integer.valueOf(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 Integer 指向同一个对象，所以 == 返回 true。\n\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n\n\n第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 JVM 参数加上 -XX:AutoBoxCacheMax=1000 再试试，是不是就返回 true 了呢？\n\nprivate static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n        if (integerCacheHighPropValue != null) {\n            try {\n                int i = parseInt(integerCacheHighPropValue);\n                i = Math.max(i, 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n\n\n第三和第四个案例中，New 出来的 Integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。\n\n第五个案例中，我们把装箱的 Integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。\n\n> 【总结】综上，我们可以得出结论：包装类需要使用 equals 进行内容判等，而不能使用 ==。\n\n\n# String 的判等\n\nString a = "1";\nString b = "1";\nlog.info("\\nString a = \\"1\\";\\nString b = \\"1\\";\\na == b ? {}", a == b); //true\n\nString c = new String("2");\nString d = new String("2");\nlog.info("\\nString c = new String(\\"2\\");\\nString d = new String(\\"2\\");\\nc == d ? {}", c == d); //false\n\nString e = new String("3").intern();\nString f = new String("3").intern();\nlog.info("\\nString e = new String(\\"3\\").intern();\\nString f = new String(\\"3\\").intern();\\ne == f ? {}", e == f); //true\n\nString g = new String("4");\nString h = new String("4");\nlog.info("\\nString g = new String(\\"4\\");\\nString h = new String(\\"4\\");\\ng == h ? {}", g.equals(h)); //true\n\n\n在 JVM 中，当代码中出现双引号形式创建字符串对象时，JVM 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。\n\n第一个案例返回 true，因为 Java 的字符串驻留机制，直接使用双引号声明出来的两个 String 对象指向常量池中的相同字符串。\n\n第二个案例，new 出来的两个 String 是不同对象，引用当然不同，所以得到 false 的结果。\n\n第三个案例，使用 String 提供的 intern 方法也会走常量池机制，所以同样能得到 true。\n\n第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。\n\n虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。\n\n【示例】String#intern 性能测试\n\n//-XX:+PrintStringTableStatistics\n//-XX:StringTableSize=10000000\nList<String> list = new ArrayList<>();\nlong begin = System.currentTimeMillis();\nlist = IntStream.rangeClosed(1, 10000000)\n    .mapToObj(i -> String.valueOf(i).intern())\n    .collect(Collectors.toList());\nSystem.out.println("size:" + list.size());\nSystem.out.println("time:" + (System.currentTimeMillis() - begin));\n\n\n上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 Map。如果容量太小（Number of buckets=60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 Average bucket size=167，代表了 Map 中桶的平均长度是 167。\n\n解决方法是：设置 JVM 参数 -XX:StringTableSize=10000000，指定更多的桶。\n\n为了方便观察，可以在启动程序时设置 JVM 参数 -XX:+PrintStringTableStatistic，程序退出时可以打印出字符串常量表的统计信息。\n\n执行结果比不设置 -XX:StringTableSize 要快很多。\n\n> 【总结】没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标。\n\n\n# 实现 equals\n\n如果看过 Object 类源码，你可能就知道，equals 的实现其实是比较对象引用\n\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n\n\n之所以 Integer 或 String 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。\n\n对于自定义类型，如果不覆写 equals 的话，默认就是使用 Object 基类的按引用的比较方式。\n\n实现一个更好的 equals 应该注意的点：\n\n * 考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；\n * 需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；\n * 需要判断两个对象的类型，如果类型都不同，那么直接返回 false；\n * 确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。\n\n【示例】自定义 equals 示例\n\n自定义类：\n\nclass Point {\n    private final int x;\n    private final int y;\n    private final String desc;\n}\n\n\n自定义 equals：\n\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    Point that = (Point) o;\n    return x == that.x && y == that.y;\n}\n\n\n\n# hashCode 和 equals 要配对实现\n\nPoint p1 = new Point(1, 2, "a");\nPoint p2 = new Point(1, 2, "b");\n\nHashSet<PointWrong> points = new HashSet<>();\npoints.add(p1);\nlog.info("points.contains(p2) ? {}", points.contains(p2));\n\n\n按照改进后的 equals 方法，这 2 个对象可以认为是同一个，Set 中已经存在了 p1 就应该包含 p2，但结果却是 false。\n\n出现这个 Bug 的原因是，散列表需要使用 hashCode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashCode 方法，就会使用 Object 超类的默认实现，得到的两个 hashCode 是不同的，导致无法满足需求。\n\n要自定义 hashCode，我们可以直接使用 Objects.hash 方法来实现。\n\n@Override\npublic int hashCode() {\n    return Objects.hash(x, y);\n}\n\n\n\n# compareTo 和 equals 的逻辑一致性\n\n【示例】自定义 compareTo 出错示例\n\n@Data\n@AllArgsConstructor\nstatic class Student implements Comparable<Student> {\n\n    private int id;\n    private String name;\n\n    @Override\n    public int compareTo(Student other) {\n        int result = Integer.compare(other.id, id);\n        if (result == 0) { log.info("this {} == other {}", this, other); }\n        return result;\n    }\n\n}\n\n\n调用：\n\nList<Student> list = new ArrayList<>();\nlist.add(new Student(1, "zhang"));\nlist.add(new Student(2, "wang"));\nStudent student = new Student(2, "li");\n\nlog.info("ArrayList.indexOf");\nint index1 = list.indexOf(student);\nCollections.sort(list);\nlog.info("Collections.binarySearch");\nint index2 = Collections.binarySearch(list, student);\n\nlog.info("index1 = " + index1);\nlog.info("index2 = " + index2);\n\n\nbinarySearch 方法内部调用了元素的 compareTo 方法进行比较；\n\n * indexOf 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；\n * binarySearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。\n\n修复方式很简单，确保 compareTo 的比较逻辑和 equals 的实现一致即可。\n\n@Data\n@AllArgsConstructor\nstatic class StudentRight implements Comparable<StudentRight> {\n\n    private int id;\n    private String name;\n\n    @Override\n    public int compareTo(StudentRight other) {\n        return Comparator.comparing(StudentRight::getName)\n            .thenComparingInt(StudentRight::getId)\n            .compare(this, other);\n    }\n\n}\n\n\n\n# 小心 Lombok 生成代码的“坑”\n\nLombok 的 @Data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时， Lombok 自动生成的方法可能就不是我们期望的了。\n\n@EqualsAndHashCode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callSuper 开关为 true，来覆盖这种默认行为。\n\n\n# 数值计算\n\n\n# 浮点数计算问题\n\n计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。\n\nSystem.out.println(0.1 + 0.2); // 0.30000000000000004\nSystem.out.println(1.0 - 0.8); // 0.19999999999999996\nSystem.out.println(4.015 * 100); // 401.49999999999994\nSystem.out.println(123.3 / 100); // 1.2329999999999999\ndouble amount1 = 2.15;\ndouble amount2 = 1.10;\nSystem.out.println(amount1 - amount2); // 1.0499999999999998\n\n\n上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？\n\n出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。Java 采用了 IEEE 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。\n\n比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n\n浮点数无法精确表达和运算的场景，一定要使用 BigDecimal 类型。\n\n使用 BigDecimal 时，有个细节要格外注意。让我们来看一段代码：\n\nSystem.out.println(new BigDecimal(0.1).add(new BigDecimal(0.2)));\n// Output: 0.3000000000000000166533453693773481063544750213623046875\n\nSystem.out.println(new BigDecimal(1.0).subtract(new BigDecimal(0.8)));\n// Output: 0.1999999999999999555910790149937383830547332763671875\n\nSystem.out.println(new BigDecimal(4.015).multiply(new BigDecimal(100)));\n// Output: 401.49999999999996802557689079549163579940795898437500\n\nSystem.out.println(new BigDecimal(123.3).divide(new BigDecimal(100)));\n// Output: 1.232999999999999971578290569595992565155029296875\n\n\n为什么输出结果仍然不符合预期呢？\n\n使用 BigDecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 BigDecimal。\n\n\n# 浮点数精度和格式化\n\n浮点数的字符串格式化也要通过 BigDecimal 进行。\n\nprivate static void wrong1() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    System.out.println(String.format("%.1f", num1)); // 3.4\n    System.out.println(String.format("%.1f", num2)); // 3.3\n}\n\nprivate static void wrong2() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    DecimalFormat format = new DecimalFormat("#.##");\n    format.setRoundingMode(RoundingMode.DOWN);\n    System.out.println(format.format(num1)); // 3.35\n    format.setRoundingMode(RoundingMode.DOWN);\n    System.out.println(format.format(num2)); // 3.34\n}\n\nprivate static void right() {\n    BigDecimal num1 = new BigDecimal("3.35");\n    BigDecimal num2 = num1.setScale(1, BigDecimal.ROUND_DOWN);\n    System.out.println(num2); // 3.3\n    BigDecimal num3 = num1.setScale(1, BigDecimal.ROUND_HALF_UP);\n    System.out.println(num3); // 3.4\n}\n\n\n\n# BigDecimal 判等问题\n\nprivate static void wrong() {\n    System.out.println(new BigDecimal("1.0").equals(new BigDecimal("1")));\n}\n\nprivate static void right() {\n    System.out.println(new BigDecimal("1.0").compareTo(new BigDecimal("1")) == 0);\n}\n\n\nBigDecimal 的 equals 方法的注释中说明了原因，equals 比较的是 BigDecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。\n\n如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法。\n\nBigDecimal 的 equals 和 hashCode 方法会同时考虑 value 和 scale，如果结合 HashSet 或 HashMap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 BigDecimal 加入 HashSet，然后判断其是否存在值为 1 的 BigDecimal，得到的结果是 false。\n\nSet<BigDecimal> hashSet1 = new HashSet<>();\nhashSet1.add(new BigDecimal("1.0"));\nSystem.out.println(hashSet1.contains(new BigDecimal("1")));//返回false\n\n\n\n\n解决办法有两个：\n\n第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。\n\n第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的。\n\nSet<BigDecimal> hashSet2 = new HashSet<>();\nhashSet2.add(new BigDecimal("1.0").stripTrailingZeros());\nSystem.out.println(hashSet2.contains(new BigDecimal("1.000").stripTrailingZeros()));//返回true\n\nSet<BigDecimal> treeSet = new TreeSet<>();\ntreeSet.add(new BigDecimal("1.0"));\nSystem.out.println(treeSet.contains(new BigDecimal("1")));//返回true\n\n\n\n# 数值溢出\n\n数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。\n\nlong l = Long.MAX_VALUE;\nSystem.out.println(l + 1); // -9223372036854775808\nSystem.out.println(l + 1 == Long.MIN_VALUE); // true\n\n\n显然这是发生了溢出，而且是默默的溢出，并没有任何异常。这类问题非常容易被忽略，改进方式有下面 2 种。\n\n方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。\n\ntry {\n    long l = Long.MAX_VALUE;\n    System.out.println(Math.addExact(l, 1));\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n\n\n方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则是对大数进行科学计算的专家。\n\nBigInteger i = new BigInteger(String.valueOf(Long.MAX_VALUE));\nSystem.out.println(i.add(BigInteger.ONE).toString());\n\ntry {\n    long l = i.add(BigInteger.ONE).longValueExact();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * 《Java 业务开发常见错误 100 例》\n * Java 基本数据类型和引用类型\n * 深入剖析 Java 中的装箱和拆箱',normalizedContent:'# 深入理解 java 基本数据类型\n\n\n\n\n# 数据类型分类\n\njava 中的数据类型有两类：\n\n * 值类型（又叫内置数据类型，基本数据类型）\n * 引用类型（除值类型以外，都是引用类型，包括 string、数组）\n\n\n# 值类型\n\njava 语言提供了 8 种基本类型，大致分为 4 类\n\n基本数据类型    分类    比特数    默认值        取值范围                            说明\nboolean   布尔型   8 位    false      {false, true}                   \nchar      字符型   16 位   \'\\u0000\'   [0, $2^{16} - 1$]               存储 unicode 码，用单引号赋值\nbyte      整数型   8 位    0          [-$2^7$, $2^7 - 1$]             \nshort     整数型   16 位   0          [-$2^{15}$, $2^{15} - 1$]       \nint       整数型   32 位   0          [-$2^{31}$, $2^{31} - 1$]       \nlong      整数型   64 位   0l         [-$2^{63}$, $2^{63} - 1$]       赋值时一般在数字后加上 l 或 l\nfloat     浮点型   32 位   +0.0f      [$2^{-149}$, $2^{128} - 1$]     赋值时必须在数字后加上 f 或 f\ndouble    浮点型   64 位   +0.0d      [$2^{-1074}$, $2^{1024} - 1$]   赋值时一般在数字后加 d 或 d\n\n尽管各种数据类型的默认值看起来不一样，但在内存中都是 0。\n\n在这些基本类型中，boolean 和 char 是唯二的无符号类型。\n\n\n# 值类型和引用类型的区别\n\n * 从概念方面来说\n   * 基本类型：变量名指向具体的数值。\n   * 引用类型：变量名指向存数据对象的内存地址。\n * 从内存方面来说\n   * 基本类型：变量在声明之后，java 就会立刻分配给他内存空间。\n   * 引用类型：它以特殊的方式（类似 c 指针）向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。\n * 从使用方面来说\n   * 基本类型：使用时需要赋具体值,判断时使用 == 号。\n   * 引用类型：使用时可以赋 null，判断时使用 equals 方法。\n\n> 👉 扩展阅读：java 基本数据类型和引用类型\n> \n> 这篇文章对于基本数据类型和引用类型的内存存储讲述比较生动。\n\n\n# 数据转换\n\njava 中，数据类型转换有两种方式：\n\n * 自动转换\n * 强制转换\n\n\n# 自动转换\n\n一般情况下，定义了某数据类型的变量，就不能再随意转换。但是 java 允许用户对基本类型做有限度的类型转换。\n\n如果符合以下条件，则 java 将会自动做类型转换：\n\n * 由小数据转换为大数据\n   \n   显而易见的是，“小”数据类型的数值表示范围小于“大”数据类型的数值表示范围，即精度小于“大”数据类型。\n   \n   所以，如果“大”数据向“小”数据转换，会丢失数据精度。比如：long 转为 int，则超出 int 表示范围的数据将会丢失，导致结果的不确定性。\n   \n   反之，“小”数据向“大”数据转换，则不会存在数据丢失情况。由于这个原因，这种类型转换也称为扩大转换。\n   \n   这些类型由“小”到“大”分别为：(byte，short，char) < int < long < float < double。\n   \n   这里我们所说的“大”与“小”，并不是指占用字节的多少，而是指表示值的范围的大小。\n\n * 转换前后的数据类型要兼容\n   \n   由于 boolean 类型只能存放 true 或 false，这与整数或字符是不兼容的，因此不可以做类型转换。\n\n * 整型类型和浮点型进行计算后，结果会转为浮点类型\n\n示例：\n\nlong x = 30;\nfloat y = 14.3f;\nsystem.out.println("x/y = " + x/y);\n\n\n输出：\n\nx/y = 1.9607843\n\n\n可见 long 虽然精度大于 float 类型，但是结果为浮点数类型。\n\n\n# 强制转换\n\n在不符合自动转换条件时或者根据用户的需要，可以对数据类型做强制的转换。\n\n强制转换使用括号 () 。\n\n引用类型也可以使用强制转换。\n\n示例：\n\nfloat f = 25.5f;\nint x = (int)f;\nsystem.out.println("x = " + x);\n\n\n\n# 装箱和拆箱\n\n\n# 包装类、装箱、拆箱\n\njava 中为每一种基本数据类型提供了相应的包装类，如下：\n\nbyte <-> byte\nshort <-> short\ninteger <-> int\nlong <-> long\nfloat <-> float\ndouble <-> double\ncharacter <-> char\nboolean <-> boolean\n\n\n引入包装类的目的就是：提供一种机制，使得基本数据类型可以与引用类型互相转换。\n\n基本数据类型与包装类的转换被称为装箱和拆箱。\n\n * 装箱（boxing）是将值类型转换为引用类型。例如：int 转 integer\n   * 装箱过程是通过调用包装类的 valueof 方法实现的。\n * 拆箱（unboxing）是将引用类型转换为值类型。例如：integer 转 int\n   * 拆箱过程是通过调用包装类的 xxxvalue 方法实现的。（xxx 代表对应的基本数据类型）。\n\n\n# 自动装箱、自动拆箱\n\n基本数据（primitive）型的自动装箱（boxing）拆箱（unboxing）自 jdk 5 开始提供的功能。\n\n自动装箱与拆箱的机制可以让我们在 java 的变量赋值或者是方法调用等情况下使用原始类型或者对象类型更加简单直接。 因为自动装箱会隐式地创建对象，如果在一个循环体中，会创建无用的中间对象，这样会增加 gc 压力，拉低程序的性能。所以在写循环时一定要注意代码，避免引入不必要的自动装箱操作。\n\njdk 5 之前的形式：\n\ninteger i1 = new integer(10); // 非自动装箱\n\n\njdk 5 之后：\n\ninteger i2 = 10; // 自动装箱\n\n\njava 对于自动装箱和拆箱的设计，依赖于一种叫做享元模式的设计模式（有兴趣的朋友可以去了解一下源码，这里不对设计模式展开详述）。\n\n> 👉 扩展阅读：深入剖析 java 中的装箱和拆箱\n> \n> 结合示例，一步步阐述装箱和拆箱原理。\n\n\n# 装箱、拆箱的应用和注意点\n\n# 装箱、拆箱应用场景\n\n * 一种最普通的场景是：调用一个含类型为 object 参数的方法，该 object 可支持任意类型（因为 object 是所有类的父类），以便通用。当你需要将一个值类型（如 int）传入时，需要使用 integer 装箱。\n * 另一种用法是：一个非泛型的容器，同样是为了保证通用，而将元素类型定义为 object。于是，要将值类型数据加入容器时，需要装箱。\n * 当 == 运算符的两个操作，一个操作数是包装类，另一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。\n\n【示例】装箱、拆箱示例\n\ninteger i1 = 10; // 自动装箱\ninteger i2 = new integer(10); // 非自动装箱\ninteger i3 = integer.valueof(10); // 非自动装箱\nint i4 = new integer(10); // 自动拆箱\nint i5 = i2.intvalue(); // 非自动拆箱\nsystem.out.println("i1 = [" + i1 + "]");\nsystem.out.println("i2 = [" + i2 + "]");\nsystem.out.println("i3 = [" + i3 + "]");\nsystem.out.println("i4 = [" + i4 + "]");\nsystem.out.println("i5 = [" + i5 + "]");\nsystem.out.println("i1 == i2 is [" + (i1 == i2) + "]");\nsystem.out.println("i1 == i4 is [" + (i1 == i4) + "]"); // 自动拆箱\n// output:\n// i1 = [10]\n// i2 = [10]\n// i3 = [10]\n// i4 = [10]\n// i5 = [10]\n// i1 == i2 is [false]\n// i1 == i4 is [true]\n\n\n【说明】\n\n上面的例子，虽然简单，但却隐藏了自动装箱、拆箱和非自动装箱、拆箱的应用。从例子中可以看到，明明所有变量都初始化为数值 10 了，但为何会出现 i1 == i2 is [false 而 i1 == i4 is [true] ？\n\n原因在于：\n\n * i1、i2 都是包装类，使用 == 时，java 将它们当做两个对象，而非两个 int 值来比较，所以两个对象自然是不相等的。正确的比较操作应该使用 equals 方法。\n * i1 是包装类，i4 是基础数据类型，使用 == 时，java 会将两个 i1 这个包装类对象自动拆箱为一个 int 值，再代入到 == 运算表达式中计算；最终，相当于两个 int 进行比较，由于值相同，所以结果相等。\n\n【示例】包装类判等问题\n\ninteger a = 127; //integer.valueof(127)\ninteger b = 127; //integer.valueof(127)\nlog.info("\\ninteger a = 127;\\ninteger b = 127;\\na == b ? {}", a == b);    // true\n\ninteger c = 128; //integer.valueof(128)\ninteger d = 128; //integer.valueof(128)\nlog.info("\\ninteger c = 128;\\ninteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-xx:autoboxcachemax=1000再试试\n\ninteger e = 127; //integer.valueof(127)\ninteger f = new integer(127); //new instance\nlog.info("\\ninteger e = 127;\\ninteger f = new integer(127);\\ne == f ? {}", e == f);   //false\n\ninteger g = new integer(127); //new instance\ninteger h = new integer(127); //new instance\nlog.info("\\ninteger g = new integer(127);\\ninteger h = new integer(127);\\ng == h ? {}", g == h);  //false\n\ninteger i = 128; //unbox\nint j = 128;\nlog.info("\\ninteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n通过运行结果可以看到，虽然看起来永远是在对 127 和 127、128 和 128 判等，但 == 却并非总是返回 true。\n\n# 装箱、拆箱应用注意点\n\n 1. 装箱操作会创建对象，频繁的装箱操作会造成不必要的内存消耗，影响性能。所以应该尽量避免装箱。\n 2. 基础数据类型的比较操作使用 ==，包装类的比较操作使用 equals 方法。\n\n\n# 判等问题\n\njava 中，通常使用 equals 或 == 进行判等操作。equals 是方法而 == 是操作符。此外，二者使用也是有区别的：\n\n * 对基本类型，比如 int、long，进行判等，只能使用 ==，比较的是字面值。因为基本类型的值就是其数值。\n * 对引用类型，比如 integer、long 和 string，进行判等，需要使用 equals 进行内容判等。因为引用类型的直接值是指针，使用 == 的话，比较的是指针，也就是两个对象在内存中的地址，即比较它们是不是同一个对象，而不是比较对象的内容。\n\n\n# 包装类的判等\n\n我们通过一个示例来深入研究一下判等问题。\n\n【示例】包装类的判等\n\ninteger a = 127; //integer.valueof(127)\ninteger b = 127; //integer.valueof(127)\nlog.info("\\ninteger a = 127;\\ninteger b = 127;\\na == b ? {}", a == b);    // true\n\ninteger c = 128; //integer.valueof(128)\ninteger d = 128; //integer.valueof(128)\nlog.info("\\ninteger c = 128;\\ninteger d = 128;\\nc == d ? {}", c == d);   //false\n//设置-xx:autoboxcachemax=1000再试试\n\ninteger e = 127; //integer.valueof(127)\ninteger f = new integer(127); //new instance\nlog.info("\\ninteger e = 127;\\ninteger f = new integer(127);\\ne == f ? {}", e == f);   //false\n\ninteger g = new integer(127); //new instance\ninteger h = new integer(127); //new instance\nlog.info("\\ninteger g = new integer(127);\\ninteger h = new integer(127);\\ng == h ? {}", g == h);  //false\n\ninteger i = 128; //unbox\nint j = 128;\nlog.info("\\ninteger i = 128;\\nint j = 128;\\ni == j ? {}", i == j); //true\n\n\n第一个案例中，编译器会把 integer a = 127 转换为 integer.valueof(127)。查看源码可以发现，这个转换在内部其实做了缓存，使得两个 integer 指向同一个对象，所以 == 返回 true。\n\npublic static integer valueof(int i) {\n    if (i >= integercache.low && i <= integercache.high)\n        return integercache.cache[i + (-integercache.low)];\n    return new integer(i);\n}\n\n\n第二个案例中，之所以同样的代码 128 就返回 false 的原因是，默认情况下会缓存[-128,127]的数值，而 128 处于这个区间之外。设置 jvm 参数加上 -xx:autoboxcachemax=1000 再试试，是不是就返回 true 了呢？\n\nprivate static class integercache {\n    static final int low = -128;\n    static final int high;\n    static final integer cache[];\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        string integercachehighpropvalue =\n            sun.misc.vm.getsavedproperty("java.lang.integer.integercache.high");\n        if (integercachehighpropvalue != null) {\n            try {\n                int i = parseint(integercachehighpropvalue);\n                i = math.max(i, 127);\n                // maximum array size is integer.max_value\n                h = math.min(i, integer.max_value - (-low) -1);\n            } catch( numberformatexception nfe) {\n                // if the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        cache = new integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new integer(j++);\n\n        // range [-128, 127] must be interned (jls7 5.1.7)\n        assert integercache.high >= 127;\n    }\n\n    private integercache() {}\n}\n\n\n第三和第四个案例中，new 出来的 integer 始终是不走缓存的新对象。比较两个新对象，或者比较一个新对象和一个来自缓存的对象，结果肯定不是相同的对象，因此返回 false。\n\n第五个案例中，我们把装箱的 integer 和基本类型 int 比较，前者会先拆箱再比较，比较的肯定是数值而不是引用，因此返回 true。\n\n> 【总结】综上，我们可以得出结论：包装类需要使用 equals 进行内容判等，而不能使用 ==。\n\n\n# string 的判等\n\nstring a = "1";\nstring b = "1";\nlog.info("\\nstring a = \\"1\\";\\nstring b = \\"1\\";\\na == b ? {}", a == b); //true\n\nstring c = new string("2");\nstring d = new string("2");\nlog.info("\\nstring c = new string(\\"2\\");\\nstring d = new string(\\"2\\");\\nc == d ? {}", c == d); //false\n\nstring e = new string("3").intern();\nstring f = new string("3").intern();\nlog.info("\\nstring e = new string(\\"3\\").intern();\\nstring f = new string(\\"3\\").intern();\\ne == f ? {}", e == f); //true\n\nstring g = new string("4");\nstring h = new string("4");\nlog.info("\\nstring g = new string(\\"4\\");\\nstring h = new string(\\"4\\");\\ng == h ? {}", g.equals(h)); //true\n\n\n在 jvm 中，当代码中出现双引号形式创建字符串对象时，jvm 会先对这个字符串进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回；否则，创建新的字符串对象，然后将这个引用放入字符串常量池，并返回该引用。这种机制，就是字符串驻留或池化。\n\n第一个案例返回 true，因为 java 的字符串驻留机制，直接使用双引号声明出来的两个 string 对象指向常量池中的相同字符串。\n\n第二个案例，new 出来的两个 string 是不同对象，引用当然不同，所以得到 false 的结果。\n\n第三个案例，使用 string 提供的 intern 方法也会走常量池机制，所以同样能得到 true。\n\n第四个案例，通过 equals 对值内容判等，是正确的处理方式，当然会得到 true。\n\n虽然使用 new 声明的字符串调用 intern 方法，也可以让字符串进行驻留，但在业务代码中滥用 intern，可能会产生性能问题。\n\n【示例】string#intern 性能测试\n\n//-xx:+printstringtablestatistics\n//-xx:stringtablesize=10000000\nlist<string> list = new arraylist<>();\nlong begin = system.currenttimemillis();\nlist = intstream.rangeclosed(1, 10000000)\n    .maptoobj(i -> string.valueof(i).intern())\n    .collect(collectors.tolist());\nsystem.out.println("size:" + list.size());\nsystem.out.println("time:" + (system.currenttimemillis() - begin));\n\n\n上面的示例执行时间会比较长。原因在于：字符串常量池是一个固定容量的 map。如果容量太小（number of buckets=60013）、字符串太多（1000 万个字符串），那么每一个桶中的字符串数量会非常多，所以搜索起来就很慢。输出结果中的 average bucket size=167，代表了 map 中桶的平均长度是 167。\n\n解决方法是：设置 jvm 参数 -xx:stringtablesize=10000000，指定更多的桶。\n\n为了方便观察，可以在启动程序时设置 jvm 参数 -xx:+printstringtablestatistic，程序退出时可以打印出字符串常量表的统计信息。\n\n执行结果比不设置 -xx:stringtablesize 要快很多。\n\n> 【总结】没事别轻易用 intern，如果要用一定要注意控制驻留的字符串的数量，并留意常量表的各项指标。\n\n\n# 实现 equals\n\n如果看过 object 类源码，你可能就知道，equals 的实现其实是比较对象引用\n\npublic boolean equals(object obj) {\n    return (this == obj);\n}\n\n\n之所以 integer 或 string 能通过 equals 实现内容判等，是因为它们都覆写了这个方法。\n\n对于自定义类型，如果不覆写 equals 的话，默认就是使用 object 基类的按引用的比较方式。\n\n实现一个更好的 equals 应该注意的点：\n\n * 考虑到性能，可以先进行指针判等，如果对象是同一个那么直接返回 true；\n * 需要对另一方进行判空，空对象和自身进行比较，结果一定是 fasle；\n * 需要判断两个对象的类型，如果类型都不同，那么直接返回 false；\n * 确保类型相同的情况下再进行类型强制转换，然后逐一判断所有字段。\n\n【示例】自定义 equals 示例\n\n自定义类：\n\nclass point {\n    private final int x;\n    private final int y;\n    private final string desc;\n}\n\n\n自定义 equals：\n\n@override\npublic boolean equals(object o) {\n    if (this == o) return true;\n    if (o == null || getclass() != o.getclass()) return false;\n    point that = (point) o;\n    return x == that.x && y == that.y;\n}\n\n\n\n# hashcode 和 equals 要配对实现\n\npoint p1 = new point(1, 2, "a");\npoint p2 = new point(1, 2, "b");\n\nhashset<pointwrong> points = new hashset<>();\npoints.add(p1);\nlog.info("points.contains(p2) ? {}", points.contains(p2));\n\n\n按照改进后的 equals 方法，这 2 个对象可以认为是同一个，set 中已经存在了 p1 就应该包含 p2，但结果却是 false。\n\n出现这个 bug 的原因是，散列表需要使用 hashcode 来定位元素放到哪个桶。如果自定义对象没有实现自定义的 hashcode 方法，就会使用 object 超类的默认实现，得到的两个 hashcode 是不同的，导致无法满足需求。\n\n要自定义 hashcode，我们可以直接使用 objects.hash 方法来实现。\n\n@override\npublic int hashcode() {\n    return objects.hash(x, y);\n}\n\n\n\n# compareto 和 equals 的逻辑一致性\n\n【示例】自定义 compareto 出错示例\n\n@data\n@allargsconstructor\nstatic class student implements comparable<student> {\n\n    private int id;\n    private string name;\n\n    @override\n    public int compareto(student other) {\n        int result = integer.compare(other.id, id);\n        if (result == 0) { log.info("this {} == other {}", this, other); }\n        return result;\n    }\n\n}\n\n\n调用：\n\nlist<student> list = new arraylist<>();\nlist.add(new student(1, "zhang"));\nlist.add(new student(2, "wang"));\nstudent student = new student(2, "li");\n\nlog.info("arraylist.indexof");\nint index1 = list.indexof(student);\ncollections.sort(list);\nlog.info("collections.binarysearch");\nint index2 = collections.binarysearch(list, student);\n\nlog.info("index1 = " + index1);\nlog.info("index2 = " + index2);\n\n\nbinarysearch 方法内部调用了元素的 compareto 方法进行比较；\n\n * indexof 的结果没问题，列表中搜索不到 id 为 2、name 是 li 的学生；\n * binarysearch 返回了索引 1，代表搜索到的结果是 id 为 2，name 是 wang 的学生。\n\n修复方式很简单，确保 compareto 的比较逻辑和 equals 的实现一致即可。\n\n@data\n@allargsconstructor\nstatic class studentright implements comparable<studentright> {\n\n    private int id;\n    private string name;\n\n    @override\n    public int compareto(studentright other) {\n        return comparator.comparing(studentright::getname)\n            .thencomparingint(studentright::getid)\n            .compare(this, other);\n    }\n\n}\n\n\n\n# 小心 lombok 生成代码的“坑”\n\nlombok 的 @data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时， lombok 自动生成的方法可能就不是我们期望的了。\n\n@equalsandhashcode 默认实现没有使用父类属性。为解决这个问题，我们可以手动设置 callsuper 开关为 true，来覆盖这种默认行为。\n\n\n# 数值计算\n\n\n# 浮点数计算问题\n\n计算机是把数值保存在了变量中，不同类型的数值变量能保存的数值范围不同，当数值超过类型能表达的数值上限则会发生溢出问题。\n\nsystem.out.println(0.1 + 0.2); // 0.30000000000000004\nsystem.out.println(1.0 - 0.8); // 0.19999999999999996\nsystem.out.println(4.015 * 100); // 401.49999999999994\nsystem.out.println(123.3 / 100); // 1.2329999999999999\ndouble amount1 = 2.15;\ndouble amount2 = 1.10;\nsystem.out.println(amount1 - amount2); // 1.0499999999999998\n\n\n上面的几个示例，输出结果和我们预期的很不一样。为什么会是这样呢？\n\n出现这种问题的主要原因是，计算机是以二进制存储数值的，浮点数也不例外。java 采用了 ieee 754 标准实现浮点数的表达和运算，你可以通过这里查看数值转化为二进制的结果。\n\n比如，0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，再转换为十进制就是 0.1000000000000000055511151231257827021181583404541015625。对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。\n\n浮点数无法精确表达和运算的场景，一定要使用 bigdecimal 类型。\n\n使用 bigdecimal 时，有个细节要格外注意。让我们来看一段代码：\n\nsystem.out.println(new bigdecimal(0.1).add(new bigdecimal(0.2)));\n// output: 0.3000000000000000166533453693773481063544750213623046875\n\nsystem.out.println(new bigdecimal(1.0).subtract(new bigdecimal(0.8)));\n// output: 0.1999999999999999555910790149937383830547332763671875\n\nsystem.out.println(new bigdecimal(4.015).multiply(new bigdecimal(100)));\n// output: 401.49999999999996802557689079549163579940795898437500\n\nsystem.out.println(new bigdecimal(123.3).divide(new bigdecimal(100)));\n// output: 1.232999999999999971578290569595992565155029296875\n\n\n为什么输出结果仍然不符合预期呢？\n\n使用 bigdecimal 表示和计算浮点数，且务必使用字符串的构造方法来初始化 bigdecimal。\n\n\n# 浮点数精度和格式化\n\n浮点数的字符串格式化也要通过 bigdecimal 进行。\n\nprivate static void wrong1() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    system.out.println(string.format("%.1f", num1)); // 3.4\n    system.out.println(string.format("%.1f", num2)); // 3.3\n}\n\nprivate static void wrong2() {\n    double num1 = 3.35;\n    float num2 = 3.35f;\n    decimalformat format = new decimalformat("#.##");\n    format.setroundingmode(roundingmode.down);\n    system.out.println(format.format(num1)); // 3.35\n    format.setroundingmode(roundingmode.down);\n    system.out.println(format.format(num2)); // 3.34\n}\n\nprivate static void right() {\n    bigdecimal num1 = new bigdecimal("3.35");\n    bigdecimal num2 = num1.setscale(1, bigdecimal.round_down);\n    system.out.println(num2); // 3.3\n    bigdecimal num3 = num1.setscale(1, bigdecimal.round_half_up);\n    system.out.println(num3); // 3.4\n}\n\n\n\n# bigdecimal 判等问题\n\nprivate static void wrong() {\n    system.out.println(new bigdecimal("1.0").equals(new bigdecimal("1")));\n}\n\nprivate static void right() {\n    system.out.println(new bigdecimal("1.0").compareto(new bigdecimal("1")) == 0);\n}\n\n\nbigdecimal 的 equals 方法的注释中说明了原因，equals 比较的是 bigdecimal 的 value 和 scale，1.0 的 scale 是 1，1 的 scale 是 0，所以结果一定是 false。\n\n如果我们希望只比较 bigdecimal 的 value，可以使用 compareto 方法。\n\nbigdecimal 的 equals 和 hashcode 方法会同时考虑 value 和 scale，如果结合 hashset 或 hashmap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 bigdecimal 加入 hashset，然后判断其是否存在值为 1 的 bigdecimal，得到的结果是 false。\n\nset<bigdecimal> hashset1 = new hashset<>();\nhashset1.add(new bigdecimal("1.0"));\nsystem.out.println(hashset1.contains(new bigdecimal("1")));//返回false\n\n\n\n\n解决办法有两个：\n\n第一个方法是，使用 treeset 替换 hashset。treeset 不使用 hashcode 方法，也不使用 equals 比较元素，而是使用 compareto 方法，所以不会有问题。\n\n第二个方法是，把 bigdecimal 存入 hashset 或 hashmap 前，先使用 striptrailingzeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 bigdecimal，scale 也是一致的。\n\nset<bigdecimal> hashset2 = new hashset<>();\nhashset2.add(new bigdecimal("1.0").striptrailingzeros());\nsystem.out.println(hashset2.contains(new bigdecimal("1.000").striptrailingzeros()));//返回true\n\nset<bigdecimal> treeset = new treeset<>();\ntreeset.add(new bigdecimal("1.0"));\nsystem.out.println(treeset.contains(new bigdecimal("1")));//返回true\n\n\n\n# 数值溢出\n\n数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。\n\nlong l = long.max_value;\nsystem.out.println(l + 1); // -9223372036854775808\nsystem.out.println(l + 1 == long.min_value); // true\n\n\n显然这是发生了溢出，而且是默默的溢出，并没有任何异常。这类问题非常容易被忽略，改进方式有下面 2 种。\n\n方法一是，考虑使用 math 类的 addexact、subtractexact 等 xxexact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。\n\ntry {\n    long l = long.max_value;\n    system.out.println(math.addexact(l, 1));\n} catch (exception ex) {\n    ex.printstacktrace();\n}\n\n\n方法二是，使用大数类 biginteger。bigdecimal 是处理浮点数的专家，而 biginteger 则是对大数进行科学计算的专家。\n\nbiginteger i = new biginteger(string.valueof(long.max_value));\nsystem.out.println(i.add(biginteger.one).tostring());\n\ntry {\n    long l = i.add(biginteger.one).longvalueexact();\n} catch (exception ex) {\n    ex.printstacktrace();\n}\n\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * 《java 业务开发常见错误 100 例》\n * java 基本数据类型和引用类型\n * 深入剖析 java 中的装箱和拆箱',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 数组",frontmatter:{title:"深入理解 Java 数组",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","数组"],permalink:"/pages/155518/",abbrlink:"14f8ff28"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05.Java%E6%95%B0%E7%BB%84.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/05.Java数组.md",key:"v-bba527d6",path:"/pages/155518/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:19},{level:3,title:"数组的特性",slug:"数组的特性",normalizedTitle:"数组的特性",charIndex:26},{level:3,title:"数组和容器",slug:"数组和容器",normalizedTitle:"数组和容器",charIndex:220},{level:3,title:"Java 数组的本质是对象",slug:"java-数组的本质是对象",normalizedTitle:"java 数组的本质是对象",charIndex:402},{level:3,title:"Java 数组和内存",slug:"java-数组和内存",normalizedTitle:"java 数组和内存",charIndex:608},{level:2,title:"声明数组",slug:"声明数组",normalizedTitle:"声明数组",charIndex:763},{level:2,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:828},{level:3,title:"数组维度的形式",slug:"数组维度的形式",normalizedTitle:"数组维度的形式",charIndex:2400},{level:3,title:"数组维度的大小",slug:"数组维度的大小",normalizedTitle:"数组维度的大小",charIndex:3469},{level:2,title:"访问数组",slug:"访问数组",normalizedTitle:"访问数组",charIndex:3580},{level:2,title:"数组的引用",slug:"数组的引用",normalizedTitle:"数组的引用",charIndex:4026},{level:2,title:"泛型和数组",slug:"泛型和数组",normalizedTitle:"泛型和数组",charIndex:4710},{level:2,title:"多维数组",slug:"多维数组",normalizedTitle:"多维数组",charIndex:5699},{level:2,title:"Arrays 类",slug:"arrays-类",normalizedTitle:"arrays 类",charIndex:6775},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:6998},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7007}],headersStr:"简介 数组的特性 数组和容器 Java 数组的本质是对象 Java 数组和内存 声明数组 创建数组 数组维度的形式 数组维度的大小 访问数组 数组的引用 泛型和数组 多维数组 Arrays 类 小结 参考资料",content:'# 深入理解 Java 数组\n\n\n# 简介\n\n\n# 数组的特性\n\n数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。\n\n数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。\n\n数组的定义和使用需要通过方括号 []。\n\n> Java 中，数组是一种引用类型。\n> \n> Java 中，数组是用来存储固定大小的同类型元素。\n\n\n# 数组和容器\n\nJava 中，既然有了强大的容器，是不是就不需要数组了？\n\n答案是不。\n\n诚然，大多数情况下，应该选择容器存储数据。\n\n但是，数组也不是毫无是处：\n\n * Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组的效率要高于容器（如 ArrayList）。\n * 数组可以持有值类型，而容器则不能（这时，就必须用到包装类）。\n\n\n# Java 数组的本质是对象\n\nJava 数组的本质是对象。它具有 Java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。\n\n如果有两个类 A 和 B，如果 B 继承（extends）了 A，那么 A[] 类型的引用就可以指向 B[] 类型的对象。\n\n> 扩展阅读：Java 中数组的特性\n> \n> 如果想要论证 Java 数组本质是对象，不妨一读这篇文章。\n\n\n# Java 数组和内存\n\nJava 数组在内存中的存储是这样的：\n\n数组对象（这里可以看成一个指针）存储在栈中。\n\n数组元素存储在堆中。\n\n如下图所示：只有当 JVM 执行 new String[] 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。\n\n\n\n\n# 声明数组\n\n声明数组变量的语法如下：\n\nint[] arr1; // 推荐风格\nint arr2[]; // 效果相同\n\n\n\n# 创建数组\n\nJava 语言使用 new 操作符来创建数组。有两种创建数组方式：\n\n * 指定数组维度\n   * 为数组开辟指定大小的数组维度。\n   * 如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 null。\n * 不指定数组维度\n   * 用花括号中的实际元素初始化数组，数组大小与元素数相同。\n\n示例 1：\n\npublic class ArrayDemo {\n    public static void main(String[] args) {\n        int[] array1 = new int[2]; // 指定数组维度\n        int[] array2 = new int[] { 1, 2 }; // 不指定数组维度\n\n        System.out.println("array1 size is " + array1.length);\n        for (int item : array1) {\n            System.out.println(item);\n        }\n\n        System.out.println("array2 size is " + array1.length);\n        for (int item : array2) {\n            System.out.println(item);\n        }\n    }\n}\n// Output:\n// array1 size is 2\n// 0\n// 0\n// array2 size is 2\n// 1\n// 2\n\n\n> 💡 说明 请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存。\n> \n> 数组 array1 中的元素都被设为默认值。\n\n示例 2：\n\npublic class ArrayDemo2 {\n    static class User {}\n\n    public static void main(String[] args) {\n        User[] array1 = new User[2]; // 指定数组维度\n        User[] array2 = new User[] {new User(), new User()}; // 不指定数组维度\n\n        System.out.println("array1: ");\n        for (User item : array1) {\n            System.out.println(item);\n        }\n\n        System.out.println("array2: ");\n        for (User item : array2) {\n            System.out.println(item);\n        }\n    }\n}\n// Output:\n// array1:\n// null\n// null\n// array2:\n// io.github.dunwu.javacore.array.ArrayDemo2$User@4141d797\n// io.github.dunwu.javacore.array.ArrayDemo2$User@68f7aae2\n\n\n> 💡 说明\n> \n> 请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 null。\n\n\n# 数组维度的形式\n\n创建数组时，指定的数组维度可以有多种形式：\n\n * 数组维度可以是整数、字符。\n * 数组维度可以是整数型、字符型变量。\n * 数组维度可以是计算结果为整数或字符的表达式。\n\n示例：\n\npublic class ArrayDemo3 {\n    public static void main(String[] args) {\n        int length = 3;\n        // 放开被注掉的代码，编译器会报错\n        // int[] array = new int[4.0];\n        // int[] array2 = new int["test"];\n        int[] array3 = new int[\'a\'];\n        int[] array4 = new int[length];\n        int[] array5 = new int[length + 2];\n        int[] array6 = new int[\'a\' + 2];\n        // int[] array7 = new int[length + 2.1];\n        System.out.println("array3.length = [" + array3.length + "]");\n        System.out.println("array4.length = [" + array4.length + "]");\n        System.out.println("array5.length = [" + array5.length + "]");\n        System.out.println("array6.length = [" + array6.length + "]");\n    }\n}\n// Output:\n// array3.length = [97]\n// array4.length = [3]\n// array5.length = [5]\n// array6.length = [99]\n\n\n> 💡 说明\n> \n> 当指定的数组维度是字符时，Java 会将其转为整数。如字符 a 的 ASCII 码是 97。\n> \n> 综上，Java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可。\n> \n> 请留意，有些编程语言则不支持这点，如 C/C++ 语言，只允许数组维度是常量。\n\n\n# 数组维度的大小\n\n数组维度并非没有上限的，如果数值过大，编译时会报错。\n\nint[] array = new int[6553612431]; // 数组维度过大，编译报错\n\n\n此外，数组过大，可能会导致栈溢出。\n\n\n# 访问数组\n\nJava 中，可以通过在 [] 中指定下标，访问数组元素，下标位置从 0 开始。\n\npublic class ArrayDemo4 {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3};\n        for (int i = 0; i < array.length; i++) {\n            array[i]++;\n            System.out.println(String.format("array[%d] = %d", i, array[i]));\n        }\n    }\n}\n// Output:\n// array[0] = 2\n// array[1] = 3\n// array[2] = 4\n\n\n> 💡 说明\n> \n> 上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。\n\n\n# 数组的引用\n\nJava 中，数组类型是一种引用类型。\n\n因此，它可以作为引用，被 Java 函数作为函数入参或返回值。\n\n数组作为函数入参的示例：\n\npublic class ArrayRefDemo {\n    private static void fun(int[] array) {\n        for (int i : array) {\n            System.out.print(i + "\\t");\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] array = new int[] {1, 3, 5};\n        fun(array);\n    }\n}\n// Output:\n// 1\t3\t5\n\n\n数组作为函数返回值的示例：\n\npublic class ArrayRefDemo2 {\n    /**\n     * 返回一个数组\n     */\n    private static int[] fun() {\n        return new int[] {1, 3, 5};\n    }\n\n    public static void main(String[] args) {\n        int[] array = fun();\n        System.out.println(Arrays.toString(array));\n    }\n}\n// Output:\n// [1, 3, 5]\n\n\n\n# 泛型和数组\n\n通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。\n\nPeel<Banana>[] peels = new Pell<Banana>[10]; // 这行代码非法\n\n\nJava 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。\n\npublic class GenericArrayDemo<T> {\n\n    static class GenericArray<T> {\n        private T[] array;\n\n        public GenericArray(int num) {\n            array = (T[]) new Object[num];\n        }\n\n        public void put(int index, T item) {\n            array[index] = item;\n        }\n\n        public T get(int index) { return array[index]; }\n\n        public T[] array() { return array; }\n    }\n\n\n\n    public static void main(String[] args) {\n        GenericArray<Integer> genericArray = new GenericArray<Integer>(4);\n        genericArray.put(0, 0);\n        genericArray.put(1, 1);\n        Object[] array = genericArray.array();\n        System.out.println(Arrays.deepToString(array));\n    }\n}\n// Output:\n// [0, 1, null, null]\n\n\n> 扩展阅读：https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n> \n> 我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\nJava 可以支持二维数组、三维数组、四维数组、五维数组。。。\n\n但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。\n\n多维数组使用示例：\n\npublic class MultiArrayDemo {\n    public static void main(String[] args) {\n        Integer[][] a1 = { // 自动装箱\n            {1, 2, 3,},\n            {4, 5, 6,},\n        };\n        Double[][][] a2 = { // 自动装箱\n            { {1.1, 2.2}, {3.3, 4.4} },\n            { {5.5, 6.6}, {7.7, 8.8} },\n            { {9.9, 1.2}, {2.3, 3.4} },\n        };\n        String[][] a3 = {\n            {"The", "Quick", "Sly", "Fox"},\n            {"Jumped", "Over"},\n            {"The", "Lazy", "Brown", "Dog", "and", "friend"},\n        };\n        System.out.println("a1: " + Arrays.deepToString(a1));\n        System.out.println("a2: " + Arrays.deepToString(a2));\n        System.out.println("a3: " + Arrays.deepToString(a3));\n    }\n}\n// Output:\n// a1: [[1, 2, 3], [4, 5, 6]]\n// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]\n// a3: [[The, Quick, Sly, Fox], [Jumped, Over], [The, Lazy, Brown, Dog, and, friend]]\n\n\n\n# Arrays 类\n\nJava 中，提供了一个很有用的数组工具类：Arrays。\n\n它提供的主要操作有：\n\n * sort - 排序\n * binarySearch - 查找\n * equals - 比较\n * fill - 填充\n * asList - 转列表\n * hash - 哈希\n * toString - 转字符串\n\n> 扩展阅读：https://juejin.im/post/5a6ade5c518825733e60acb8\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Java 中数组的特性\n * https://juejin.im/post/59cae3de6fb9a00a4551915b\n * https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n * https://juejin.im/post/5a6ade5c518825733e60acb8',normalizedContent:'# 深入理解 java 数组\n\n\n# 简介\n\n\n# 数组的特性\n\n数组对于每一门编程语言来说都是重要的数据结构之一，当然不同语言对数组的实现及处理也不尽相同。几乎所有程序设计语言都支持数组。\n\n数组代表一系列对象或者基本数据类型，所有相同的类型都封装到一起，采用一个统一的标识符名称。\n\n数组的定义和使用需要通过方括号 []。\n\n> java 中，数组是一种引用类型。\n> \n> java 中，数组是用来存储固定大小的同类型元素。\n\n\n# 数组和容器\n\njava 中，既然有了强大的容器，是不是就不需要数组了？\n\n答案是不。\n\n诚然，大多数情况下，应该选择容器存储数据。\n\n但是，数组也不是毫无是处：\n\n * java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组的效率要高于容器（如 arraylist）。\n * 数组可以持有值类型，而容器则不能（这时，就必须用到包装类）。\n\n\n# java 数组的本质是对象\n\njava 数组的本质是对象。它具有 java 中其他对象的一些基本特点：封装了一些数据，可以访问属性，也可以调用方法。所以，数组是对象。\n\n如果有两个类 a 和 b，如果 b 继承（extends）了 a，那么 a[] 类型的引用就可以指向 b[] 类型的对象。\n\n> 扩展阅读：java 中数组的特性\n> \n> 如果想要论证 java 数组本质是对象，不妨一读这篇文章。\n\n\n# java 数组和内存\n\njava 数组在内存中的存储是这样的：\n\n数组对象（这里可以看成一个指针）存储在栈中。\n\n数组元素存储在堆中。\n\n如下图所示：只有当 jvm 执行 new string[] 时，才会在堆中开辟相应的内存区域。数组对象 array 可以视为一个指针，指向这块内存的存储地址。\n\n\n\n\n# 声明数组\n\n声明数组变量的语法如下：\n\nint[] arr1; // 推荐风格\nint arr2[]; // 效果相同\n\n\n\n# 创建数组\n\njava 语言使用 new 操作符来创建数组。有两种创建数组方式：\n\n * 指定数组维度\n   * 为数组开辟指定大小的数组维度。\n   * 如果数组元素是基础数据类型，会将每个元素设为默认值；如果是引用类型，元素值为 null。\n * 不指定数组维度\n   * 用花括号中的实际元素初始化数组，数组大小与元素数相同。\n\n示例 1：\n\npublic class arraydemo {\n    public static void main(string[] args) {\n        int[] array1 = new int[2]; // 指定数组维度\n        int[] array2 = new int[] { 1, 2 }; // 不指定数组维度\n\n        system.out.println("array1 size is " + array1.length);\n        for (int item : array1) {\n            system.out.println(item);\n        }\n\n        system.out.println("array2 size is " + array1.length);\n        for (int item : array2) {\n            system.out.println(item);\n        }\n    }\n}\n// output:\n// array1 size is 2\n// 0\n// 0\n// array2 size is 2\n// 1\n// 2\n\n\n> 💡 说明 请注意数组 array1 中的元素虽然没有初始化，但是 length 和指定的数组维度是一样的。这表明指定数组维度后，无论后面是否初始化数组中的元素，数组都已经开辟了相应的内存。\n> \n> 数组 array1 中的元素都被设为默认值。\n\n示例 2：\n\npublic class arraydemo2 {\n    static class user {}\n\n    public static void main(string[] args) {\n        user[] array1 = new user[2]; // 指定数组维度\n        user[] array2 = new user[] {new user(), new user()}; // 不指定数组维度\n\n        system.out.println("array1: ");\n        for (user item : array1) {\n            system.out.println(item);\n        }\n\n        system.out.println("array2: ");\n        for (user item : array2) {\n            system.out.println(item);\n        }\n    }\n}\n// output:\n// array1:\n// null\n// null\n// array2:\n// io.github.dunwu.javacore.array.arraydemo2$user@4141d797\n// io.github.dunwu.javacore.array.arraydemo2$user@68f7aae2\n\n\n> 💡 说明\n> \n> 请将本例与示例 1 比较，可以发现：如果使用指定数组维度方式创建数组，且数组元素为引用类型，则数组中的元素元素值为 null。\n\n\n# 数组维度的形式\n\n创建数组时，指定的数组维度可以有多种形式：\n\n * 数组维度可以是整数、字符。\n * 数组维度可以是整数型、字符型变量。\n * 数组维度可以是计算结果为整数或字符的表达式。\n\n示例：\n\npublic class arraydemo3 {\n    public static void main(string[] args) {\n        int length = 3;\n        // 放开被注掉的代码，编译器会报错\n        // int[] array = new int[4.0];\n        // int[] array2 = new int["test"];\n        int[] array3 = new int[\'a\'];\n        int[] array4 = new int[length];\n        int[] array5 = new int[length + 2];\n        int[] array6 = new int[\'a\' + 2];\n        // int[] array7 = new int[length + 2.1];\n        system.out.println("array3.length = [" + array3.length + "]");\n        system.out.println("array4.length = [" + array4.length + "]");\n        system.out.println("array5.length = [" + array5.length + "]");\n        system.out.println("array6.length = [" + array6.length + "]");\n    }\n}\n// output:\n// array3.length = [97]\n// array4.length = [3]\n// array5.length = [5]\n// array6.length = [99]\n\n\n> 💡 说明\n> \n> 当指定的数组维度是字符时，java 会将其转为整数。如字符 a 的 ascii 码是 97。\n> \n> 综上，java 数组的数组维度可以是常量、变量、表达式，只要转换为整数即可。\n> \n> 请留意，有些编程语言则不支持这点，如 c/c++ 语言，只允许数组维度是常量。\n\n\n# 数组维度的大小\n\n数组维度并非没有上限的，如果数值过大，编译时会报错。\n\nint[] array = new int[6553612431]; // 数组维度过大，编译报错\n\n\n此外，数组过大，可能会导致栈溢出。\n\n\n# 访问数组\n\njava 中，可以通过在 [] 中指定下标，访问数组元素，下标位置从 0 开始。\n\npublic class arraydemo4 {\n    public static void main(string[] args) {\n        int[] array = {1, 2, 3};\n        for (int i = 0; i < array.length; i++) {\n            array[i]++;\n            system.out.println(string.format("array[%d] = %d", i, array[i]));\n        }\n    }\n}\n// output:\n// array[0] = 2\n// array[1] = 3\n// array[2] = 4\n\n\n> 💡 说明\n> \n> 上面的示例中，从 0 开始，使用下标遍历数组 array 的所有元素，为每个元素值加 1 。\n\n\n# 数组的引用\n\njava 中，数组类型是一种引用类型。\n\n因此，它可以作为引用，被 java 函数作为函数入参或返回值。\n\n数组作为函数入参的示例：\n\npublic class arrayrefdemo {\n    private static void fun(int[] array) {\n        for (int i : array) {\n            system.out.print(i + "\\t");\n        }\n    }\n\n    public static void main(string[] args) {\n        int[] array = new int[] {1, 3, 5};\n        fun(array);\n    }\n}\n// output:\n// 1\t3\t5\n\n\n数组作为函数返回值的示例：\n\npublic class arrayrefdemo2 {\n    /**\n     * 返回一个数组\n     */\n    private static int[] fun() {\n        return new int[] {1, 3, 5};\n    }\n\n    public static void main(string[] args) {\n        int[] array = fun();\n        system.out.println(arrays.tostring(array));\n    }\n}\n// output:\n// [1, 3, 5]\n\n\n\n# 泛型和数组\n\n通常，数组和泛型不能很好地结合。你不能实例化具有参数化类型的数组。\n\npeel<banana>[] peels = new pell<banana>[10]; // 这行代码非法\n\n\njava 中不允许直接创建泛型数组。但是，可以通过创建一个类型擦除的数组，然后转型的方式来创建泛型数组。\n\npublic class genericarraydemo<t> {\n\n    static class genericarray<t> {\n        private t[] array;\n\n        public genericarray(int num) {\n            array = (t[]) new object[num];\n        }\n\n        public void put(int index, t item) {\n            array[index] = item;\n        }\n\n        public t get(int index) { return array[index]; }\n\n        public t[] array() { return array; }\n    }\n\n\n\n    public static void main(string[] args) {\n        genericarray<integer> genericarray = new genericarray<integer>(4);\n        genericarray.put(0, 0);\n        genericarray.put(1, 1);\n        object[] array = genericarray.array();\n        system.out.println(arrays.deeptostring(array));\n    }\n}\n// output:\n// [0, 1, null, null]\n\n\n> 扩展阅读：https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n> \n> 我认为，对于泛型数组的理解，点到为止即可。实际上，真的需要存储泛型，还是使用容器更合适。\n\n\n# 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n\njava 可以支持二维数组、三维数组、四维数组、五维数组。。。\n\n但是，以正常人的理解能力，一般也就最多能理解三维数组。所以，请不要做反人类的事，去定义过多维度的数组。\n\n多维数组使用示例：\n\npublic class multiarraydemo {\n    public static void main(string[] args) {\n        integer[][] a1 = { // 自动装箱\n            {1, 2, 3,},\n            {4, 5, 6,},\n        };\n        double[][][] a2 = { // 自动装箱\n            { {1.1, 2.2}, {3.3, 4.4} },\n            { {5.5, 6.6}, {7.7, 8.8} },\n            { {9.9, 1.2}, {2.3, 3.4} },\n        };\n        string[][] a3 = {\n            {"the", "quick", "sly", "fox"},\n            {"jumped", "over"},\n            {"the", "lazy", "brown", "dog", "and", "friend"},\n        };\n        system.out.println("a1: " + arrays.deeptostring(a1));\n        system.out.println("a2: " + arrays.deeptostring(a2));\n        system.out.println("a3: " + arrays.deeptostring(a3));\n    }\n}\n// output:\n// a1: [[1, 2, 3], [4, 5, 6]]\n// a2: [[[1.1, 2.2], [3.3, 4.4]], [[5.5, 6.6], [7.7, 8.8]], [[9.9, 1.2], [2.3, 3.4]]]\n// a3: [[the, quick, sly, fox], [jumped, over], [the, lazy, brown, dog, and, friend]]\n\n\n\n# arrays 类\n\njava 中，提供了一个很有用的数组工具类：arrays。\n\n它提供的主要操作有：\n\n * sort - 排序\n * binarysearch - 查找\n * equals - 比较\n * fill - 填充\n * aslist - 转列表\n * hash - 哈希\n * tostring - 转字符串\n\n> 扩展阅读：https://juejin.im/post/5a6ade5c518825733e60acb8\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * java 中数组的特性\n * https://juejin.im/post/59cae3de6fb9a00a4551915b\n * https://www.cnblogs.com/jiangzhaowei/p/7399522.html\n * https://juejin.im/post/5a6ade5c518825733e60acb8',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 方法",frontmatter:{title:"深入理解 Java 方法",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","方法"],permalink:"/pages/7a3ffc/",abbrlink:"8dfb0abf"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04.Java%E6%96%B9%E6%B3%95.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/04.Java方法.md",key:"v-4fdbef37",path:"/pages/7a3ffc/",headers:[{level:2,title:"方法的使用",slug:"方法的使用",normalizedTitle:"方法的使用",charIndex:46},{level:3,title:"方法定义",slug:"方法定义",normalizedTitle:"方法定义",charIndex:56},{level:3,title:"方法的调用",slug:"方法的调用",normalizedTitle:"方法的调用",charIndex:601},{level:4,title:"递归调用",slug:"递归调用",normalizedTitle:"递归调用",charIndex:846},{level:2,title:"方法参数",slug:"方法参数",normalizedTitle:"方法参数",charIndex:1336},{level:2,title:"方法修饰符",slug:"方法修饰符",normalizedTitle:"方法修饰符",charIndex:2559},{level:3,title:"访问控制修饰符",slug:"访问控制修饰符",normalizedTitle:"访问控制修饰符",charIndex:2647},{level:3,title:"static",slug:"static",normalizedTitle:"static",charIndex:158},{level:3,title:"final",slug:"final",normalizedTitle:"final",charIndex:3131},{level:3,title:"default",slug:"default",normalizedTitle:"default",charIndex:3719},{level:3,title:"abstract",slug:"abstract",normalizedTitle:"abstract",charIndex:4424},{level:3,title:"synchronized",slug:"synchronized",normalizedTitle:"synchronized",charIndex:4922},{level:2,title:"特殊方法",slug:"特殊方法",normalizedTitle:"特殊方法",charIndex:5127},{level:3,title:"main 方法",slug:"main-方法",normalizedTitle:"main 方法",charIndex:5167},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:5631},{level:3,title:"变参方法",slug:"变参方法",normalizedTitle:"变参方法",charIndex:6358},{level:3,title:"finalize() 方法",slug:"finalize-方法",normalizedTitle:"finalize() 方法",charIndex:7078},{level:2,title:"覆写和重载",slug:"覆写和重载",normalizedTitle:"覆写和重载",charIndex:7549},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:8637},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8646}],headersStr:"方法的使用 方法定义 方法的调用 递归调用 方法参数 方法修饰符 访问控制修饰符 static final default abstract synchronized 特殊方法 main 方法 构造方法 变参方法 finalize() 方法 覆写和重载 小结 参考资料",content:'# 深入理解 Java 方法\n\n> 方法（有的人喜欢叫函数）是一段可重用的代码段。\n\n\n# 方法的使用\n\n\n# 方法定义\n\n方法定义语法格式：\n\n[修饰符] 返回值类型 方法名([参数类型 参数名]){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n示例：\n\npublic static void main(String[] args) {\n    System.out.println("Hello World");\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符 - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n * 返回值类型 - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。\n * 方法名 - 是方法的实际名称。方法名和参数表共同构成方法签名。\n * 参数类型 - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * 方法体 - 方法体包含具体的语句，定义该方法的功能。\n * return - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 return; 这种形式。\n\n\n# 方法的调用\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\nJava 支持两种调用方法的方式，根据方法是否有返回值来选择。\n\n * 有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。\n\nint larger = max(30, 40);\n\n\n * 无返回值方法 - 无返回值方法只能是一条语句。\n\nSystem.out.println("Hello World");\n\n\n# 递归调用\n\nJava 支持方法的递归调用（即方法调用自身）。\n\n> 🔔 注意：\n> \n>  * 递归方法必须有明确的结束条件。\n>  * 尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。\n\n斐波那契数列（一个典型的递归算法）示例：\n\npublic class RecursionMethodDemo {\n    public static int fib(int num) {\n        if (num == 1 || num == 2) {\n            return 1;\n        } else {\n            return fib(num - 2) + fib(num - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 1; i < 10; i++) {\n            System.out.print(fib(i) + "\\t");\n        }\n    }\n}\n\n\n\n# 方法参数\n\n在 C/C++ 等编程语言中，方法的参数传递一般有两种形式：\n\n * 值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。\n * 引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。\n\n那么，Java 中是怎样的呢？\n\nJava 中只有值传递。\n\n示例一：\n\npublic class MethodParamDemo {\n    public static void method(int value) {\n        value =  value + 1;\n    }\n    public static void main(String[] args) {\n        int num = 0;\n        method(num);\n        System.out.println("num = [" + num + "]");\n        method(num);\n        System.out.println("num = [" + num + "]");\n    }\n}\n// Output:\n// num = [0]\n// num = [0]\n\n\n示例二：\n\npublic class MethodParamDemo2 {\n    public static void method(StringBuilder sb) {\n        sb = new StringBuilder("B");\n    }\n\n    public static void main(String[] args) {\n        StringBuilder sb = new StringBuilder("A");\n        System.out.println("sb = [" + sb.toString() + "]");\n        method(sb);\n        System.out.println("sb = [" + sb.toString() + "]");\n        sb = new StringBuilder("C");\n        System.out.println("sb = [" + sb.toString() + "]");\n    }\n}\n// Output:\n// sb = [A]\n// sb = [A]\n// sb = [C]\n\n\n说明：\n\n以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。\n\nJava 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。\n\n> 扩展阅读：\n> \n> 图解 Java 中的参数传递\n\n\n# 方法修饰符\n\n前面提到了，Java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n\nJava 方法有好几个修饰符，让我们一一来认识一下：\n\n\n# 访问控制修饰符\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# static\n\n被 static 修饰的方法被称为静态方法。\n\n静态方法相比于普通的实例方法，主要有以下区别：\n\n * 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n\n * 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\n\n静态方法常被用于各种工具类、工厂方法类。\n\n\n# final\n\n被 final 修饰的方法不能被子类覆写（Override）。\n\nfinal 方法示例：\n\npublic class FinalMethodDemo {\n    static class Father {\n        protected final void print() {\n            System.out.println("call Father print()");\n        };\n    }\n\n    static class Son extends Father {\n        @Override\n        protected void print() {\n            System.out.println("call print()");\n        }\n    }\n\n    public static void main(String[] args) {\n        Father demo = new Son();\n        demo.print();\n    }\n}\n// 编译时会报错\n\n\n> 说明：\n> \n> 上面示例中，父类 Father 中定义了一个 final 方法 print()，则其子类不能 Override 这个 final 方法，否则会编译报错。\n\n\n# default\n\nJDK8 开始，支持在接口 Interface 中定义 default 方法。default 方法只能出现在接口 Interface 中。\n\n接口中被 default 修饰的方法被称为默认方法，实现此接口的类如果没 Override 此方法，则直接继承这个方法，不再强制必须实现此方法。\n\ndefault 方法语法的出现，是为了既有的成千上万的 Java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，JDK8 中 Collection 类中有一个非常方便的 stream() 方法，就是被修饰为 default，Collection 的一大堆 List、Set 子类就直接继承了这个方法 I，不必再为每个子类都注意添加这个方法。\n\ndefault 方法示例：\n\npublic class DefaultMethodDemo {\n    interface MyInterface {\n        default void print() {\n            System.out.println("Hello World");\n        }\n    }\n\n\n    static class MyClass implements MyInterface {}\n\n    public static void main(String[] args) {\n        MyInterface obj = new MyClass();\n        obj.print();\n    }\n}\n// Output:\n// Hello World\n\n\n\n# abstract\n\n被 abstract 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。\n\n抽象方法示例：\n\npublic class AbstractMethodDemo {\n    static abstract class AbstractClass {\n        abstract void print();\n    }\n\n    static class ConcreteClass extends AbstractClass {\n        @Override\n        void print() {\n            System.out.println("call print()");\n        }\n    }\n\n    public static void main(String[] args) {\n        AbstractClass demo = new ConcreteClass();\n        demo.print();\n    }\n\n}\n// Outpu:\n// call print()\n\n\n\n# synchronized\n\nsynchronized 用于并发编程。被 synchronized 修饰的方法在一个时刻，只允许一个线程执行。\n\n在 Java 的同步容器（Vector、Stack、HashTable）中，你会见到大量的 synchronized 方法。不过，请记住：在 Java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。\n\n\n# 特殊方法\n\nJava 中，有一些较为特殊的方法，分别使用于特殊的场景。\n\n\n# main 方法\n\nJava 中的 main 方法是一种特殊的静态方法，因为所有的 Java 程序都是由 public static void main(String[] args) 方法开始执行。\n\n有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。\n\n示例：\n\npublic class MainMethodDemo {\n    public static void main(String[] args) {\n        for (String arg : args) {\n            System.out.println("arg = [" + arg + "]");\n        }\n    }\n}\n\n\n依次执行\n\njavac MainMethodDemo.java\njava MainMethodDemo A B C\n\n\n控制台会打印输出参数：\n\narg = [A]\narg = [B]\narg = [C]\n\n\n\n# 构造方法\n\n任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class ConstructorMethodDemo {\n\n    static class Person {\n        private String name;\n\n        public Person(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(String[] args) {\n        Person person = new Person("jack");\n        System.out.println("person name is " + person.getName());\n    }\n}\n\n\n注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。\n\n\n# 变参方法\n\nJDK5 开始，Java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 ...。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n变参方法示例：\n\npublic class VarargsDemo {\n    public static void method(String... params) {\n        System.out.println("params.length = " + params.length);\n        for (String param : params) {\n            System.out.println("params = [" + param + "]");\n        }\n    }\n\n    public static void main(String[] args) {\n        method("red");\n        method("red", "yellow");\n        method("red", "yellow", "blue");\n    }\n}\n// Output:\n// params.length = 1\n// params = [red]\n// params.length = 2\n// params = [red]\n// params = [yellow]\n// params.length = 3\n// params = [red]\n// params = [yellow]\n// params = [blue]\n\n\n\n# finalize() 方法\n\nfinalize 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。\n\nfinalize 是在 java.lang.Object 里定义的，也就是说每一个对象都有这么个方法。这个方法在 GC 启动，该对象被回收的时候被调用。\n\nfinalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。\n\n请记住：应该尽量避免使用 finalizer()。千万不要把它当成是 C/C++ 中的析构函数来用。原因是：Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 CPU 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 OutOfMemoryError 异常。\n\n> 扩展阅读：\n> \n> 下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。\n> \n>  * Java 的 Finalizer 引发的内存溢出\n>  * 重载 Finalize 引发的内存泄露\n\n\n# 覆写和重载\n\n覆写（Override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。\n\n子类要覆写的方法如果要访问父类的方法，可以使用 super 关键字。\n\n覆写示例：\n\npublic class MethodOverrideDemo {\n    static class Animal {\n        public void move() {\n            System.out.println("会动");\n        }\n    }\n    static class Dog extends Animal {\n        @Override\n        public void move() {\n            super.move();\n            System.out.println("会跑");\n        }\n    }\n\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        dog.move();\n    }\n}\n// Output:\n// 会动\n// 会跑\n\n\n方法的重载（Overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。\n\n> 🔔 注意：\n> \n> 重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，Java 是无法编译通过的。\n\n重载示例：\n\npublic class MethodOverloadDemo {\n    public static void add(int x, int y) {\n        System.out.println("x + y = " + (x + y));\n    }\n\n    public static void add(double x, double y) {\n        System.out.println("x + y = " + (x + y));\n    }\n\n    public static void main(String[] args) {\n        add(10, 20);\n        add(1.0, 2.0);\n    }\n}\n// Output:\n// x + y = 30\n// x + y = 3.0\n\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Head First Java\n * 图解 Java 中的参数传递\n * Java 的 Finalizer 引发的内存溢出\n * 重载 Finalize 引发的内存泄露',normalizedContent:'# 深入理解 java 方法\n\n> 方法（有的人喜欢叫函数）是一段可重用的代码段。\n\n\n# 方法的使用\n\n\n# 方法定义\n\n方法定义语法格式：\n\n[修饰符] 返回值类型 方法名([参数类型 参数名]){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n示例：\n\npublic static void main(string[] args) {\n    system.out.println("hello world");\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * 修饰符 - 修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n * 返回值类型 - 返回值类型表示方法执行结束后，返回结果的数据类型。如果没有返回值，应设为 void。\n * 方法名 - 是方法的实际名称。方法名和参数表共同构成方法签名。\n * 参数类型 - 参数像是一个占位符。当方法被调用时，传递值给参数。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * 方法体 - 方法体包含具体的语句，定义该方法的功能。\n * return - 必须返回声明方法时返回值类型相同的数据类型。在 void 方法中，return 语句可有可无，如果要写 return，则只能是 return; 这种形式。\n\n\n# 方法的调用\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\njava 支持两种调用方法的方式，根据方法是否有返回值来选择。\n\n * 有返回值方法 - 有返回值方法通常被用来给一个变量赋值或代入到运算表达式中进行计算。\n\nint larger = max(30, 40);\n\n\n * 无返回值方法 - 无返回值方法只能是一条语句。\n\nsystem.out.println("hello world");\n\n\n# 递归调用\n\njava 支持方法的递归调用（即方法调用自身）。\n\n> 🔔 注意：\n> \n>  * 递归方法必须有明确的结束条件。\n>  * 尽量避免使用递归调用。因为递归调用如果处理不当，可能导致栈溢出。\n\n斐波那契数列（一个典型的递归算法）示例：\n\npublic class recursionmethoddemo {\n    public static int fib(int num) {\n        if (num == 1 || num == 2) {\n            return 1;\n        } else {\n            return fib(num - 2) + fib(num - 1);\n        }\n    }\n\n    public static void main(string[] args) {\n        for (int i = 1; i < 10; i++) {\n            system.out.print(fib(i) + "\\t");\n        }\n    }\n}\n\n\n\n# 方法参数\n\n在 c/c++ 等编程语言中，方法的参数传递一般有两种形式：\n\n * 值传递 - 值传递的参数被称为形参。值传递时，传入的参数，在方法中的修改，不会在方法外部生效。\n * 引用传递 - 引用传递的参数被称为实参。引用传递时，传入的参数，在方法中的修改，会在方法外部生效。\n\n那么，java 中是怎样的呢？\n\njava 中只有值传递。\n\n示例一：\n\npublic class methodparamdemo {\n    public static void method(int value) {\n        value =  value + 1;\n    }\n    public static void main(string[] args) {\n        int num = 0;\n        method(num);\n        system.out.println("num = [" + num + "]");\n        method(num);\n        system.out.println("num = [" + num + "]");\n    }\n}\n// output:\n// num = [0]\n// num = [0]\n\n\n示例二：\n\npublic class methodparamdemo2 {\n    public static void method(stringbuilder sb) {\n        sb = new stringbuilder("b");\n    }\n\n    public static void main(string[] args) {\n        stringbuilder sb = new stringbuilder("a");\n        system.out.println("sb = [" + sb.tostring() + "]");\n        method(sb);\n        system.out.println("sb = [" + sb.tostring() + "]");\n        sb = new stringbuilder("c");\n        system.out.println("sb = [" + sb.tostring() + "]");\n    }\n}\n// output:\n// sb = [a]\n// sb = [a]\n// sb = [c]\n\n\n说明：\n\n以上两个示例，无论向方法中传入的是基础数据类型，还是引用类型，在方法中修改的值，在外部都未生效。\n\njava 对于基本数据类型，会直接拷贝值传递到方法中；对于引用数据类型，拷贝当前对象的引用地址，然后把该地址传递过去，所以也是值传递。\n\n> 扩展阅读：\n> \n> 图解 java 中的参数传递\n\n\n# 方法修饰符\n\n前面提到了，java 方法的修饰符是可选的，它告诉编译器如何调用该方法。定义了该方法的访问类型。\n\njava 方法有好几个修饰符，让我们一一来认识一下：\n\n\n# 访问控制修饰符\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# static\n\n被 static 修饰的方法被称为静态方法。\n\n静态方法相比于普通的实例方法，主要有以下区别：\n\n * 在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象名.方法名 的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n\n * 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。\n\n静态方法常被用于各种工具类、工厂方法类。\n\n\n# final\n\n被 final 修饰的方法不能被子类覆写（override）。\n\nfinal 方法示例：\n\npublic class finalmethoddemo {\n    static class father {\n        protected final void print() {\n            system.out.println("call father print()");\n        };\n    }\n\n    static class son extends father {\n        @override\n        protected void print() {\n            system.out.println("call print()");\n        }\n    }\n\n    public static void main(string[] args) {\n        father demo = new son();\n        demo.print();\n    }\n}\n// 编译时会报错\n\n\n> 说明：\n> \n> 上面示例中，父类 father 中定义了一个 final 方法 print()，则其子类不能 override 这个 final 方法，否则会编译报错。\n\n\n# default\n\njdk8 开始，支持在接口 interface 中定义 default 方法。default 方法只能出现在接口 interface 中。\n\n接口中被 default 修饰的方法被称为默认方法，实现此接口的类如果没 override 此方法，则直接继承这个方法，不再强制必须实现此方法。\n\ndefault 方法语法的出现，是为了既有的成千上万的 java 类库的类增加新的功能， 且不必对这些类重新进行设计。 举例来说，jdk8 中 collection 类中有一个非常方便的 stream() 方法，就是被修饰为 default，collection 的一大堆 list、set 子类就直接继承了这个方法 i，不必再为每个子类都注意添加这个方法。\n\ndefault 方法示例：\n\npublic class defaultmethoddemo {\n    interface myinterface {\n        default void print() {\n            system.out.println("hello world");\n        }\n    }\n\n\n    static class myclass implements myinterface {}\n\n    public static void main(string[] args) {\n        myinterface obj = new myclass();\n        obj.print();\n    }\n}\n// output:\n// hello world\n\n\n\n# abstract\n\n被 abstract 修饰的方法被称为抽象方法，方法不能有实体。抽象方法只能出现抽象类中。\n\n抽象方法示例：\n\npublic class abstractmethoddemo {\n    static abstract class abstractclass {\n        abstract void print();\n    }\n\n    static class concreteclass extends abstractclass {\n        @override\n        void print() {\n            system.out.println("call print()");\n        }\n    }\n\n    public static void main(string[] args) {\n        abstractclass demo = new concreteclass();\n        demo.print();\n    }\n\n}\n// outpu:\n// call print()\n\n\n\n# synchronized\n\nsynchronized 用于并发编程。被 synchronized 修饰的方法在一个时刻，只允许一个线程执行。\n\n在 java 的同步容器（vector、stack、hashtable）中，你会见到大量的 synchronized 方法。不过，请记住：在 java 并发编程中，synchronized 方法并不是一个好的选择，大多数情况下，我们会选择更加轻量级的锁 。\n\n\n# 特殊方法\n\njava 中，有一些较为特殊的方法，分别使用于特殊的场景。\n\n\n# main 方法\n\njava 中的 main 方法是一种特殊的静态方法，因为所有的 java 程序都是由 public static void main(string[] args) 方法开始执行。\n\n有很多新手虽然一直用 main 方法，却不知道 main 方法中的 args 有什么用。实际上，这是用来接收接收命令行输入参数的。\n\n示例：\n\npublic class mainmethoddemo {\n    public static void main(string[] args) {\n        for (string arg : args) {\n            system.out.println("arg = [" + arg + "]");\n        }\n    }\n}\n\n\n依次执行\n\njavac mainmethoddemo.java\njava mainmethoddemo a b c\n\n\n控制台会打印输出参数：\n\narg = [a]\narg = [b]\narg = [c]\n\n\n\n# 构造方法\n\n任何类都有构造方法，构造方法的作用就是在初始化类实例时，设置实例的状态。\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class constructormethoddemo {\n\n    static class person {\n        private string name;\n\n        public person(string name) {\n            this.name = name;\n        }\n\n        public string getname() {\n            return name;\n        }\n\n        public void setname(string name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(string[] args) {\n        person person = new person("jack");\n        system.out.println("person name is " + person.getname());\n    }\n}\n\n\n注意，构造方法除了使用 public，也可以使用 private 修饰，这种情况下，类无法调用此构造方法去实例化对象，这常常用于设计模式中的单例模式。\n\n\n# 变参方法\n\njdk5 开始，java 支持传递同类型的可变参数给一个方法。在方法声明中，在指定参数类型后加一个省略号 ...。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n变参方法示例：\n\npublic class varargsdemo {\n    public static void method(string... params) {\n        system.out.println("params.length = " + params.length);\n        for (string param : params) {\n            system.out.println("params = [" + param + "]");\n        }\n    }\n\n    public static void main(string[] args) {\n        method("red");\n        method("red", "yellow");\n        method("red", "yellow", "blue");\n    }\n}\n// output:\n// params.length = 1\n// params = [red]\n// params.length = 2\n// params = [red]\n// params = [yellow]\n// params.length = 3\n// params = [red]\n// params = [yellow]\n// params = [blue]\n\n\n\n# finalize() 方法\n\nfinalize 在对象被垃圾收集器析构(回收)之前调用，用来清除回收对象。\n\nfinalize 是在 java.lang.object 里定义的，也就是说每一个对象都有这么个方法。这个方法在 gc 启动，该对象被回收的时候被调用。\n\nfinalizer() 通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题。\n\n请记住：应该尽量避免使用 finalizer()。千万不要把它当成是 c/c++ 中的析构函数来用。原因是：finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的 cpu 时间较少，因此它永远也赶不上主线程的步伐。所以最后可能会发生 outofmemoryerror 异常。\n\n> 扩展阅读：\n> \n> 下面两篇文章比较详细的讲述了 finalizer() 可能会造成的问题及原因。\n> \n>  * java 的 finalizer 引发的内存溢出\n>  * 重载 finalize 引发的内存泄露\n\n\n# 覆写和重载\n\n覆写（override）是指子类定义了与父类中同名的方法，但是在方法覆写时必须考虑到访问权限，子类覆写的方法不能拥有比父类更加严格的访问权限。\n\n子类要覆写的方法如果要访问父类的方法，可以使用 super 关键字。\n\n覆写示例：\n\npublic class methodoverridedemo {\n    static class animal {\n        public void move() {\n            system.out.println("会动");\n        }\n    }\n    static class dog extends animal {\n        @override\n        public void move() {\n            super.move();\n            system.out.println("会跑");\n        }\n    }\n\n    public static void main(string[] args) {\n        animal dog = new dog();\n        dog.move();\n    }\n}\n// output:\n// 会动\n// 会跑\n\n\n方法的重载（overload）是指方法名称相同，但参数的类型或参数的个数不同。通过传递参数的个数及类型的不同可以完成不同功能的方法调用。\n\n> 🔔 注意：\n> \n> 重载一定是方法的参数不完全相同。如果方法的参数完全相同，仅仅是返回值不同，java 是无法编译通过的。\n\n重载示例：\n\npublic class methodoverloaddemo {\n    public static void add(int x, int y) {\n        system.out.println("x + y = " + (x + y));\n    }\n\n    public static void add(double x, double y) {\n        system.out.println("x + y = " + (x + y));\n    }\n\n    public static void main(string[] args) {\n        add(10, 20);\n        add(1.0, 2.0);\n    }\n}\n// output:\n// x + y = 30\n// x + y = 3.0\n\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * head first java\n * 图解 java 中的参数传递\n * java 的 finalizer 引发的内存溢出\n * 重载 finalize 引发的内存泄露',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 枚举",frontmatter:{title:"深入理解 Java 枚举",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","枚举"],permalink:"/pages/979887/",abbrlink:"43c0b54b"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/06.Java%E6%9E%9A%E4%B8%BE.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/06.Java枚举.md",key:"v-3d7150a1",path:"/pages/979887/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:19},{level:2,title:"枚举的本质",slug:"枚举的本质",normalizedTitle:"枚举的本质",charIndex:185},{level:2,title:"枚举的方法",slug:"枚举的方法",normalizedTitle:"枚举的方法",charIndex:1295},{level:2,title:"枚举的特性",slug:"枚举的特性",normalizedTitle:"枚举的特性",charIndex:3237},{level:3,title:"基本特性",slug:"基本特性",normalizedTitle:"基本特性",charIndex:3320},{level:3,title:"枚举可以添加方法",slug:"枚举可以添加方法",normalizedTitle:"枚举可以添加方法",charIndex:3446},{level:3,title:"枚举可以实现接口",slug:"枚举可以实现接口",normalizedTitle:"枚举可以实现接口",charIndex:5006},{level:3,title:"枚举不可以继承",slug:"枚举不可以继承",normalizedTitle:"枚举不可以继承",charIndex:5613},{level:2,title:"枚举的应用",slug:"枚举的应用",normalizedTitle:"枚举的应用",charIndex:5744},{level:3,title:"组织常量",slug:"组织常量",normalizedTitle:"组织常量",charIndex:5754},{level:3,title:"switch 状态机",slug:"switch-状态机",normalizedTitle:"switch 状态机",charIndex:5986},{level:3,title:"错误码",slug:"错误码",normalizedTitle:"错误码",charIndex:171},{level:3,title:"组织枚举",slug:"组织枚举",normalizedTitle:"组织枚举",charIndex:8136},{level:3,title:"策略枚举",slug:"策略枚举",normalizedTitle:"策略枚举",charIndex:10264},{level:3,title:"枚举实现单例模式",slug:"枚举实现单例模式",normalizedTitle:"枚举实现单例模式",charIndex:11727},{level:2,title:"枚举工具类",slug:"枚举工具类",normalizedTitle:"枚举工具类",charIndex:12386},{level:3,title:"EnumSet",slug:"enumset",normalizedTitle:"enumset",charIndex:12420},{level:3,title:"EnumMap",slug:"enummap",normalizedTitle:"enummap",charIndex:12430},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:14158},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:14167}],headersStr:"简介 枚举的本质 枚举的方法 枚举的特性 基本特性 枚举可以添加方法 枚举可以实现接口 枚举不可以继承 枚举的应用 组织常量 switch 状态机 错误码 组织枚举 策略枚举 枚举实现单例模式 枚举工具类 EnumSet EnumMap 小结 参考资料",content:'# 深入理解 Java 枚举\n\n\n# 简介\n\nenum 的全称为 enumeration， 是 JDK5 中引入的特性。\n\n在 Java 中，被 enum 关键字修饰的类型就是枚举类型。形式如下：\n\nenum ColorEn { RED, GREEN, BLUE }\n\n\n枚举的好处：可以将常量组织起来，统一进行管理。\n\n枚举的典型应用场景：错误码、状态机等。\n\n\n# 枚举的本质\n\njava.lang.Enum类声明\n\npublic abstract class Enum<E extends Enum<E>>\n        implements Comparable<E>, Serializable { ... }\n\n\n新建一个 ColorEn.java 文件，内容如下：\n\npackage io.github.dunwu.javacore.enumeration;\n\npublic enum ColorEn {\n    RED,YELLOW,BLUE\n}\n\n\n执行 javac ColorEn.java 命令，生成 ColorEn.class 文件。\n\n然后执行 javap ColorEn.class 命令，输出如下内容：\n\nCompiled from "ColorEn.java"\npublic final class io.github.dunwu.javacore.enumeration.ColorEn extends java.lang.Enum<io.github.dunwu.javacore.enumeration.ColorEn> {\n  public static final io.github.dunwu.javacore.enumeration.ColorEn RED;\n  public static final io.github.dunwu.javacore.enumeration.ColorEn YELLOW;\n  public static final io.github.dunwu.javacore.enumeration.ColorEn BLUE;\n  public static io.github.dunwu.javacore.enumeration.ColorEn[] values();\n  public static io.github.dunwu.javacore.enumeration.ColorEn valueOf(java.lang.String);\n  static {};\n}\n\n\n> 💡 说明：\n> \n> 从上面的例子可以看出：\n> \n> 枚举的本质是 java.lang.Enum 的子类。\n> \n> 尽管 enum 看起来像是一种新的数据类型，事实上，enum 是一种受限制的类，并且具有自己的方法。枚举这种特殊的类因为被修饰为 final，所以不能继承其他类。\n> \n> 定义的枚举值，会被默认修饰为 public static final ，从修饰关键字，即可看出枚举值本质上是静态常量。\n\n\n# 枚举的方法\n\n在 enum 中，提供了一些基本方法：\n\n * values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。\n * name()：返回实例名。\n * ordinal()：返回实例声明时的次序，从 0 开始。\n * getDeclaringClass()：返回实例所属的 enum 类型。\n * equals() ：判断是否为同一个对象。\n\n可以使用 == 来比较enum实例。\n\n此外，java.lang.Enum实现了Comparable和 Serializable 接口，所以也提供 compareTo() 方法。\n\n例：展示 enum 的基本方法\n\npublic class EnumMethodDemo {\n    enum Color {RED, GREEN, BLUE;}\n    enum Size {BIG, MIDDLE, SMALL;}\n    public static void main(String args[]) {\n        System.out.println("=========== Print all Color ===========");\n        for (Color c : Color.values()) {\n            System.out.println(c + " ordinal: " + c.ordinal());\n        }\n        System.out.println("=========== Print all Size ===========");\n        for (Size s : Size.values()) {\n            System.out.println(s + " ordinal: " + s.ordinal());\n        }\n\n        Color green = Color.GREEN;\n        System.out.println("green name(): " + green.name());\n        System.out.println("green getDeclaringClass(): " + green.getDeclaringClass());\n        System.out.println("green hashCode(): " + green.hashCode());\n        System.out.println("green compareTo Color.GREEN: " + green.compareTo(Color.GREEN));\n        System.out.println("green equals Color.GREEN: " + green.equals(Color.GREEN));\n        System.out.println("green equals Size.MIDDLE: " + green.equals(Size.MIDDLE));\n        System.out.println("green equals 1: " + green.equals(1));\n        System.out.format("green == Color.BLUE: %b\\n", green == Color.BLUE);\n    }\n}\n\n\n输出\n\n=========== Print all Color ===========\nRED ordinal: 0\nGREEN ordinal: 1\nBLUE ordinal: 2\n=========== Print all Size ===========\nBIG ordinal: 0\nMIDDLE ordinal: 1\nSMALL ordinal: 2\ngreen name(): GREEN\ngreen getDeclaringClass(): class org.zp.javase.enumeration.EnumDemo$Color\ngreen hashCode(): 460141958\ngreen compareTo Color.GREEN: 0\ngreen equals Color.GREEN: true\ngreen equals Size.MIDDLE: false\ngreen equals 1: false\ngreen == Color.BLUE: false\n\n\n\n# 枚举的特性\n\n枚举的特性，归结起来就是一句话：\n\n> 除了不能继承，基本上可以将 enum 看做一个常规的类。\n\n但是这句话需要拆分去理解，让我们细细道来。\n\n\n# 基本特性\n\n如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。\n\n如果枚举中没有定义方法，枚举值默认为从 0 开始的有序数值。以 Color 枚举类型举例，它的枚举常量依次为 RED：0，GREEN：1，BLUE：2。\n\n\n# 枚举可以添加方法\n\n在概念章节提到了，枚举值默认为从 0 开始的有序数值 。那么问题来了：如何为枚举显式的赋值。\n\n（1）Java 不允许使用 = 为枚举常量赋值\n\n如果你接触过 C/C++，你肯定会很自然的想到赋值符号 = 。在 C/C++语言中的 enum，可以用赋值符号=显式的为枚举常量赋值；但是 ，很遗憾，Java 语法中却不允许使用赋值符号 = 为枚举常量赋值。\n\n例：C/C++ 语言中的枚举声明\n\ntypedef enum {\n    ONE = 1,\n    TWO,\n    THREE = 3,\n    TEN = 10\n} Number;\n\n\n（2）枚举可以添加普通方法、静态方法、抽象方法、构造方法\n\nJava 虽然不能直接为实例赋值，但是它有更优秀的解决方案：为 enum 添加方法来间接实现显式赋值。\n\n创建 enum 时，可以为其添加多种方法，甚至可以为其添加构造方法。\n\n注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。\n\n例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法\n\npublic enum ErrorCodeEn {\n    OK(0) {\n        @Override\n        public String getDescription() {\n            return "成功";\n        }\n    },\n    ERROR_A(100) {\n        @Override\n        public String getDescription() {\n            return "错误A";\n        }\n    },\n    ERROR_B(200) {\n        @Override\n        public String getDescription() {\n            return "错误B";\n        }\n    };\n\n    private int code;\n\n    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限\n    private ErrorCodeEn(int number) { // 构造方法\n        this.code = number;\n    }\n\n    public int getCode() { // 普通方法\n        return code;\n    } // 普通方法\n\n    public abstract String getDescription(); // 抽象方法\n\n    public static void main(String args[]) { // 静态方法\n        for (ErrorCodeEn s : ErrorCodeEn.values()) {\n            System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());\n        }\n    }\n}\n// Output:\n// code: 0, description: 成功\n// code: 100, description: 错误A\n// code: 200, description: 错误B\n\n\n注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况错误码示例\n\n\n# 枚举可以实现接口\n\nenum 可以像一般类一样实现接口。\n\n同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。\n\npublic interface INumberEnum {\n    int getCode();\n    String getDescription();\n}\n\npublic enum ErrorCodeEn2 implements INumberEnum {\n    OK(0, "成功"),\n    ERROR_A(100, "错误A"),\n    ERROR_B(200, "错误B");\n\n    ErrorCodeEn2(int number, String description) {\n        this.code = number;\n        this.description = description;\n    }\n\n    private int code;\n    private String description;\n\n    @Override\n    public int getCode() {\n        return code;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n}\n\n\n\n# 枚举不可以继承\n\nenum 不可以继承另外一个类，当然，也不能继承另一个 enum 。\n\n因为 enum 实际上都继承自 java.lang.Enum 类，而 Java 不支持多重继承，所以 enum 不能再继承其他类，当然也不能继承另一个 enum。\n\n\n# 枚举的应用\n\n\n# 组织常量\n\n在 JDK5 之前，在 Java 中定义常量都是public static final TYPE a; 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。\n\n下面三种声明方式是等价的：\n\nenum Color { RED, GREEN, BLUE }\nenum Color { RED, GREEN, BLUE, }\nenum Color { RED, GREEN, BLUE; }\n\n\n\n# switch 状态机\n\n我们经常使用 switch 语句来写状态机。JDK7 以后，switch 已经支持 int、char、String、enum 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。\n\npublic class StateMachineDemo {\n    public enum Signal {\n        GREEN, YELLOW, RED\n    }\n\n    public static String getTrafficInstruct(Signal signal) {\n        String instruct = "信号灯故障";\n        switch (signal) {\n            case RED:\n                instruct = "红灯停";\n                break;\n            case YELLOW:\n                instruct = "黄灯请注意";\n                break;\n            case GREEN:\n                instruct = "绿灯行";\n                break;\n            default:\n                break;\n        }\n        return instruct;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getTrafficInstruct(Signal.RED));\n    }\n}\n// Output:\n// 红灯停\n\n\n\n# 错误码\n\n枚举常被用于定义程序错误码。下面是一个简单示例：\n\npublic class ErrorCodeEnumDemo {\n    enum ErrorCodeEn {\n        OK(0, "成功"),\n        ERROR_A(100, "错误A"),\n        ERROR_B(200, "错误B");\n\n        ErrorCodeEn(int number, String msg) {\n            this.code = number;\n            this.msg = msg;\n        }\n\n        private int code;\n        private String msg;\n\n        public int getCode() {\n            return code;\n        }\n\n        public String getMsg() {\n            return msg;\n        }\n\n        @Override\n        public String toString() {\n            return "ErrorCodeEn{" + "code=" + code + ", msg=\'" + msg + \'\\\'\' + \'}\';\n        }\n\n        public static String toStringAll() {\n            StringBuilder sb = new StringBuilder();\n            sb.append("ErrorCodeEn All Elements: [");\n            for (ErrorCodeEn code : ErrorCodeEn.values()) {\n                sb.append(code.getCode()).append(", ");\n            }\n            sb.append("]");\n            return sb.toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(ErrorCodeEn.toStringAll());\n        for (ErrorCodeEn s : ErrorCodeEn.values()) {\n            System.out.println(s);\n        }\n    }\n}\n// Output:\n// ErrorCodeEn All Elements: [0, 100, 200, ]\n// ErrorCodeEn{code=0, msg=\'成功\'}\n// ErrorCodeEn{code=100, msg=\'错误A\'}\n// ErrorCodeEn{code=200, msg=\'错误B\'}\n\n\n\n# 组织枚举\n\n可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。\n\n原因是：Java 接口在编译时会自动为 enum 类型加上public static修饰符；Java 类在编译时会自动为 enum 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 enum，如果你不给它修饰为 public，那么只能在本包中进行访问。\n\n例：在接口中组织 enum\n\npublic class EnumInInterfaceDemo {\n    public interface INumberEnum {\n        int getCode();\n        String getDescription();\n    }\n\n\n    public interface Plant {\n        enum Vegetable implements INumberEnum {\n            POTATO(0, "土豆"),\n            TOMATO(0, "西红柿");\n\n            Vegetable(int number, String description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private String description;\n\n            @Override\n            public int getCode() {\n                return this.code;\n            }\n\n            @Override\n            public String getDescription() {\n                return this.description;\n            }\n        }\n\n\n        enum Fruit implements INumberEnum {\n            APPLE(0, "苹果"),\n            ORANGE(0, "桔子"),\n            BANANA(0, "香蕉");\n\n            Fruit(int number, String description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private String description;\n\n            @Override\n            public int getCode() {\n                return this.code;\n            }\n\n            @Override\n            public String getDescription() {\n                return this.description;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (Plant.Fruit f : Plant.Fruit.values()) {\n            System.out.println(f.getDescription());\n        }\n    }\n}\n// Output:\n// 苹果\n// 桔子\n// 香蕉\n\n\n例：在类中组织 enum\n\n本例和上例效果相同。\n\npublic class EnumInClassDemo {\n    public interface INumberEnum {\n        int getCode();\n        String getDescription();\n    }\n\n    public static class Plant2 {\n        enum Vegetable implements INumberEnum {\n            // 略，与上面完全相同\n        }\n        enum Fruit implements INumberEnum {\n            // 略，与上面完全相同\n        }\n    }\n\n    // 略\n}\n// Output:\n// 土豆\n// 西红柿\n\n\n\n# 策略枚举\n\nEffective Java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。\n\n这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。\n\n例：EffectvieJava 中的策略枚举范例\n\nenum PayrollDay {\n    MONDAY(PayType.WEEKDAY), TUESDAY(PayType.WEEKDAY), WEDNESDAY(\n            PayType.WEEKDAY), THURSDAY(PayType.WEEKDAY), FRIDAY(PayType.WEEKDAY), SATURDAY(\n            PayType.WEEKEND), SUNDAY(PayType.WEEKEND);\n\n    private final PayType payType;\n\n    PayrollDay(PayType payType) {\n        this.payType = payType;\n    }\n\n    double pay(double hoursWorked, double payRate) {\n        return payType.pay(hoursWorked, payRate);\n    }\n\n    // 策略枚举\n    private enum PayType {\n        WEEKDAY {\n            double overtimePay(double hours, double payRate) {\n                return hours <= HOURS_PER_SHIFT ? 0 : (hours - HOURS_PER_SHIFT)\n                        * payRate / 2;\n            }\n        },\n        WEEKEND {\n            double overtimePay(double hours, double payRate) {\n                return hours * payRate / 2;\n            }\n        };\n        private static final int HOURS_PER_SHIFT = 8;\n\n        abstract double overtimePay(double hrs, double payRate);\n\n        double pay(double hoursWorked, double payRate) {\n            double basePay = hoursWorked * payRate;\n            return basePay + overtimePay(hoursWorked, payRate);\n        }\n    }\n}\n\n\n测试\n\nSystem.out.println("时薪100的人在周五工作8小时的收入：" + PayrollDay.FRIDAY.pay(8.0, 100));\nSystem.out.println("时薪100的人在周六工作8小时的收入：" + PayrollDay.SATURDAY.pay(8.0, 100));\n\n\n\n# 枚举实现单例模式\n\n单例模式是最常用的设计模式。\n\n单例模式在并发环境下存在线程安全问题。\n\n为了线程安全问题，传统做法有以下几种：\n\n * 饿汉式加载\n * 懒汉式 synchronize 和双重检查\n * 利用 java 的静态加载机制\n\n相比上述的方法，使用枚举也可以实现单例，而且还更加简单：\n\npublic class SingleEnumDemo {\n    public enum SingleEn {\n\n        INSTANCE;\n\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(String[] args) {\n        SingleEn.INSTANCE.setName("zp");\n        System.out.println(SingleEn.INSTANCE.getName());\n    }\n}\n\n\n> 扩展阅读：深入理解 Java 枚举类型(enum)\n> \n> 这篇文章对于 Java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。\n\n\n# 枚举工具类\n\nJava 中提供了两个方便操作 enum 的工具类——EnumSet 和 EnumMap。\n\n\n# EnumSet\n\nEnumSet 是枚举类型的高性能 Set 实现。它要求放入它的枚举常量必须属于同一枚举类型。\n\n主要接口：\n\n * noneOf - 创建一个具有指定元素类型的空 EnumSet\n * allOf - 创建一个指定元素类型并包含所有枚举值的 EnumSet\n * range - 创建一个包括枚举值中指定范围元素的 EnumSet\n * complementOf - 初始集合包括指定集合的补集\n * of - 创建一个包括参数中所有元素的 EnumSet\n * copyOf - 创建一个包含参数容器中的所有元素的 EnumSet\n\n示例：\n\npublic class EnumSetDemo {\n    public static void main(String[] args) {\n        System.out.println("EnumSet展示");\n        EnumSet<ErrorCodeEn> errSet = EnumSet.allOf(ErrorCodeEn.class);\n        for (ErrorCodeEn e : errSet) {\n            System.out.println(e.name() + " : " + e.ordinal());\n        }\n    }\n}\n\n\n\n# EnumMap\n\nEnumMap 是专门为枚举类型量身定做的 Map 实现。虽然使用其它的 Map 实现（如 HashMap）也能完成枚举类型实例到值得映射，但是使用 EnumMap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值。这使得 EnumMap 的效率非常高。\n\n主要接口：\n\n * size - 返回键值对数\n * containsValue - 是否存在指定的 value\n * containsKey - 是否存在指定的 key\n * get - 根据指定 key 获取 value\n * put - 取出指定的键值对\n * remove - 删除指定 key\n * putAll - 批量取出键值对\n * clear - 清除数据\n * keySet - 获取 key 集合\n * values - 返回所有\n\n示例：\n\npublic class EnumMapDemo {\n    public enum Signal {\n        GREEN, YELLOW, RED\n    }\n\n    public static void main(String[] args) {\n        System.out.println("EnumMap展示");\n        EnumMap<Signal, String> errMap = new EnumMap(Signal.class);\n        errMap.put(Signal.RED, "红灯");\n        errMap.put(Signal.YELLOW, "黄灯");\n        errMap.put(Signal.GREEN, "绿灯");\n        for (Iterator<Map.Entry<Signal, String>> iter = errMap.entrySet().iterator(); iter.hasNext();) {\n            Map.Entry<Signal, String> entry = iter.next();\n            System.out.println(entry.getKey().name() + " : " + entry.getValue());\n        }\n    }\n}\n\n\n> 扩展阅读：深入理解 Java 枚举类型(enum)\n> \n> 这篇文章中对 EnumSet 和 EnumMap 原理做了较为详细的介绍。\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * 深入理解 Java 枚举类型(enum)\n * https://droidyue.com/blog/2016/11/29/dive-into-enum/',normalizedContent:'# 深入理解 java 枚举\n\n\n# 简介\n\nenum 的全称为 enumeration， 是 jdk5 中引入的特性。\n\n在 java 中，被 enum 关键字修饰的类型就是枚举类型。形式如下：\n\nenum coloren { red, green, blue }\n\n\n枚举的好处：可以将常量组织起来，统一进行管理。\n\n枚举的典型应用场景：错误码、状态机等。\n\n\n# 枚举的本质\n\njava.lang.enum类声明\n\npublic abstract class enum<e extends enum<e>>\n        implements comparable<e>, serializable { ... }\n\n\n新建一个 coloren.java 文件，内容如下：\n\npackage io.github.dunwu.javacore.enumeration;\n\npublic enum coloren {\n    red,yellow,blue\n}\n\n\n执行 javac coloren.java 命令，生成 coloren.class 文件。\n\n然后执行 javap coloren.class 命令，输出如下内容：\n\ncompiled from "coloren.java"\npublic final class io.github.dunwu.javacore.enumeration.coloren extends java.lang.enum<io.github.dunwu.javacore.enumeration.coloren> {\n  public static final io.github.dunwu.javacore.enumeration.coloren red;\n  public static final io.github.dunwu.javacore.enumeration.coloren yellow;\n  public static final io.github.dunwu.javacore.enumeration.coloren blue;\n  public static io.github.dunwu.javacore.enumeration.coloren[] values();\n  public static io.github.dunwu.javacore.enumeration.coloren valueof(java.lang.string);\n  static {};\n}\n\n\n> 💡 说明：\n> \n> 从上面的例子可以看出：\n> \n> 枚举的本质是 java.lang.enum 的子类。\n> \n> 尽管 enum 看起来像是一种新的数据类型，事实上，enum 是一种受限制的类，并且具有自己的方法。枚举这种特殊的类因为被修饰为 final，所以不能继承其他类。\n> \n> 定义的枚举值，会被默认修饰为 public static final ，从修饰关键字，即可看出枚举值本质上是静态常量。\n\n\n# 枚举的方法\n\n在 enum 中，提供了一些基本方法：\n\n * values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。\n * name()：返回实例名。\n * ordinal()：返回实例声明时的次序，从 0 开始。\n * getdeclaringclass()：返回实例所属的 enum 类型。\n * equals() ：判断是否为同一个对象。\n\n可以使用 == 来比较enum实例。\n\n此外，java.lang.enum实现了comparable和 serializable 接口，所以也提供 compareto() 方法。\n\n例：展示 enum 的基本方法\n\npublic class enummethoddemo {\n    enum color {red, green, blue;}\n    enum size {big, middle, small;}\n    public static void main(string args[]) {\n        system.out.println("=========== print all color ===========");\n        for (color c : color.values()) {\n            system.out.println(c + " ordinal: " + c.ordinal());\n        }\n        system.out.println("=========== print all size ===========");\n        for (size s : size.values()) {\n            system.out.println(s + " ordinal: " + s.ordinal());\n        }\n\n        color green = color.green;\n        system.out.println("green name(): " + green.name());\n        system.out.println("green getdeclaringclass(): " + green.getdeclaringclass());\n        system.out.println("green hashcode(): " + green.hashcode());\n        system.out.println("green compareto color.green: " + green.compareto(color.green));\n        system.out.println("green equals color.green: " + green.equals(color.green));\n        system.out.println("green equals size.middle: " + green.equals(size.middle));\n        system.out.println("green equals 1: " + green.equals(1));\n        system.out.format("green == color.blue: %b\\n", green == color.blue);\n    }\n}\n\n\n输出\n\n=========== print all color ===========\nred ordinal: 0\ngreen ordinal: 1\nblue ordinal: 2\n=========== print all size ===========\nbig ordinal: 0\nmiddle ordinal: 1\nsmall ordinal: 2\ngreen name(): green\ngreen getdeclaringclass(): class org.zp.javase.enumeration.enumdemo$color\ngreen hashcode(): 460141958\ngreen compareto color.green: 0\ngreen equals color.green: true\ngreen equals size.middle: false\ngreen equals 1: false\ngreen == color.blue: false\n\n\n\n# 枚举的特性\n\n枚举的特性，归结起来就是一句话：\n\n> 除了不能继承，基本上可以将 enum 看做一个常规的类。\n\n但是这句话需要拆分去理解，让我们细细道来。\n\n\n# 基本特性\n\n如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。\n\n如果枚举中没有定义方法，枚举值默认为从 0 开始的有序数值。以 color 枚举类型举例，它的枚举常量依次为 red：0，green：1，blue：2。\n\n\n# 枚举可以添加方法\n\n在概念章节提到了，枚举值默认为从 0 开始的有序数值 。那么问题来了：如何为枚举显式的赋值。\n\n（1）java 不允许使用 = 为枚举常量赋值\n\n如果你接触过 c/c++，你肯定会很自然的想到赋值符号 = 。在 c/c++语言中的 enum，可以用赋值符号=显式的为枚举常量赋值；但是 ，很遗憾，java 语法中却不允许使用赋值符号 = 为枚举常量赋值。\n\n例：c/c++ 语言中的枚举声明\n\ntypedef enum {\n    one = 1,\n    two,\n    three = 3,\n    ten = 10\n} number;\n\n\n（2）枚举可以添加普通方法、静态方法、抽象方法、构造方法\n\njava 虽然不能直接为实例赋值，但是它有更优秀的解决方案：为 enum 添加方法来间接实现显式赋值。\n\n创建 enum 时，可以为其添加多种方法，甚至可以为其添加构造方法。\n\n注意一个细节：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。\n\n例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法\n\npublic enum errorcodeen {\n    ok(0) {\n        @override\n        public string getdescription() {\n            return "成功";\n        }\n    },\n    error_a(100) {\n        @override\n        public string getdescription() {\n            return "错误a";\n        }\n    },\n    error_b(200) {\n        @override\n        public string getdescription() {\n            return "错误b";\n        }\n    };\n\n    private int code;\n\n    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限\n    private errorcodeen(int number) { // 构造方法\n        this.code = number;\n    }\n\n    public int getcode() { // 普通方法\n        return code;\n    } // 普通方法\n\n    public abstract string getdescription(); // 抽象方法\n\n    public static void main(string args[]) { // 静态方法\n        for (errorcodeen s : errorcodeen.values()) {\n            system.out.println("code: " + s.getcode() + ", description: " + s.getdescription());\n        }\n    }\n}\n// output:\n// code: 0, description: 成功\n// code: 100, description: 错误a\n// code: 200, description: 错误b\n\n\n注：上面的例子并不可取，仅仅是为了展示枚举支持定义各种方法。正确的例子情况错误码示例\n\n\n# 枚举可以实现接口\n\nenum 可以像一般类一样实现接口。\n\n同样是实现上一节中的错误码枚举类，通过实现接口，可以约束它的方法。\n\npublic interface inumberenum {\n    int getcode();\n    string getdescription();\n}\n\npublic enum errorcodeen2 implements inumberenum {\n    ok(0, "成功"),\n    error_a(100, "错误a"),\n    error_b(200, "错误b");\n\n    errorcodeen2(int number, string description) {\n        this.code = number;\n        this.description = description;\n    }\n\n    private int code;\n    private string description;\n\n    @override\n    public int getcode() {\n        return code;\n    }\n\n    @override\n    public string getdescription() {\n        return description;\n    }\n}\n\n\n\n# 枚举不可以继承\n\nenum 不可以继承另外一个类，当然，也不能继承另一个 enum 。\n\n因为 enum 实际上都继承自 java.lang.enum 类，而 java 不支持多重继承，所以 enum 不能再继承其他类，当然也不能继承另一个 enum。\n\n\n# 枚举的应用\n\n\n# 组织常量\n\n在 jdk5 之前，在 java 中定义常量都是public static final type a; 这样的形式。有了枚举，你可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。\n\n下面三种声明方式是等价的：\n\nenum color { red, green, blue }\nenum color { red, green, blue, }\nenum color { red, green, blue; }\n\n\n\n# switch 状态机\n\n我们经常使用 switch 语句来写状态机。jdk7 以后，switch 已经支持 int、char、string、enum 类型的参数。这几种类型的参数比较起来，使用枚举的 switch 代码更具有可读性。\n\npublic class statemachinedemo {\n    public enum signal {\n        green, yellow, red\n    }\n\n    public static string gettrafficinstruct(signal signal) {\n        string instruct = "信号灯故障";\n        switch (signal) {\n            case red:\n                instruct = "红灯停";\n                break;\n            case yellow:\n                instruct = "黄灯请注意";\n                break;\n            case green:\n                instruct = "绿灯行";\n                break;\n            default:\n                break;\n        }\n        return instruct;\n    }\n\n    public static void main(string[] args) {\n        system.out.println(gettrafficinstruct(signal.red));\n    }\n}\n// output:\n// 红灯停\n\n\n\n# 错误码\n\n枚举常被用于定义程序错误码。下面是一个简单示例：\n\npublic class errorcodeenumdemo {\n    enum errorcodeen {\n        ok(0, "成功"),\n        error_a(100, "错误a"),\n        error_b(200, "错误b");\n\n        errorcodeen(int number, string msg) {\n            this.code = number;\n            this.msg = msg;\n        }\n\n        private int code;\n        private string msg;\n\n        public int getcode() {\n            return code;\n        }\n\n        public string getmsg() {\n            return msg;\n        }\n\n        @override\n        public string tostring() {\n            return "errorcodeen{" + "code=" + code + ", msg=\'" + msg + \'\\\'\' + \'}\';\n        }\n\n        public static string tostringall() {\n            stringbuilder sb = new stringbuilder();\n            sb.append("errorcodeen all elements: [");\n            for (errorcodeen code : errorcodeen.values()) {\n                sb.append(code.getcode()).append(", ");\n            }\n            sb.append("]");\n            return sb.tostring();\n        }\n    }\n\n    public static void main(string[] args) {\n        system.out.println(errorcodeen.tostringall());\n        for (errorcodeen s : errorcodeen.values()) {\n            system.out.println(s);\n        }\n    }\n}\n// output:\n// errorcodeen all elements: [0, 100, 200, ]\n// errorcodeen{code=0, msg=\'成功\'}\n// errorcodeen{code=100, msg=\'错误a\'}\n// errorcodeen{code=200, msg=\'错误b\'}\n\n\n\n# 组织枚举\n\n可以将类型相近的枚举通过接口或类组织起来，但是一般用接口方式进行组织。\n\n原因是：java 接口在编译时会自动为 enum 类型加上public static修饰符；java 类在编译时会自动为 enum 类型加上 static 修饰符。看出差异了吗？没错，就是说，在类中组织 enum，如果你不给它修饰为 public，那么只能在本包中进行访问。\n\n例：在接口中组织 enum\n\npublic class enumininterfacedemo {\n    public interface inumberenum {\n        int getcode();\n        string getdescription();\n    }\n\n\n    public interface plant {\n        enum vegetable implements inumberenum {\n            potato(0, "土豆"),\n            tomato(0, "西红柿");\n\n            vegetable(int number, string description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private string description;\n\n            @override\n            public int getcode() {\n                return this.code;\n            }\n\n            @override\n            public string getdescription() {\n                return this.description;\n            }\n        }\n\n\n        enum fruit implements inumberenum {\n            apple(0, "苹果"),\n            orange(0, "桔子"),\n            banana(0, "香蕉");\n\n            fruit(int number, string description) {\n                this.code = number;\n                this.description = description;\n            }\n\n            private int code;\n            private string description;\n\n            @override\n            public int getcode() {\n                return this.code;\n            }\n\n            @override\n            public string getdescription() {\n                return this.description;\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        for (plant.fruit f : plant.fruit.values()) {\n            system.out.println(f.getdescription());\n        }\n    }\n}\n// output:\n// 苹果\n// 桔子\n// 香蕉\n\n\n例：在类中组织 enum\n\n本例和上例效果相同。\n\npublic class enuminclassdemo {\n    public interface inumberenum {\n        int getcode();\n        string getdescription();\n    }\n\n    public static class plant2 {\n        enum vegetable implements inumberenum {\n            // 略，与上面完全相同\n        }\n        enum fruit implements inumberenum {\n            // 略，与上面完全相同\n        }\n    }\n\n    // 略\n}\n// output:\n// 土豆\n// 西红柿\n\n\n\n# 策略枚举\n\neffective java 中展示了一种策略枚举。这种枚举通过枚举嵌套枚举的方式，将枚举常量分类处理。\n\n这种做法虽然没有 switch 语句简洁，但是更加安全、灵活。\n\n例：effectviejava 中的策略枚举范例\n\nenum payrollday {\n    monday(paytype.weekday), tuesday(paytype.weekday), wednesday(\n            paytype.weekday), thursday(paytype.weekday), friday(paytype.weekday), saturday(\n            paytype.weekend), sunday(paytype.weekend);\n\n    private final paytype paytype;\n\n    payrollday(paytype paytype) {\n        this.paytype = paytype;\n    }\n\n    double pay(double hoursworked, double payrate) {\n        return paytype.pay(hoursworked, payrate);\n    }\n\n    // 策略枚举\n    private enum paytype {\n        weekday {\n            double overtimepay(double hours, double payrate) {\n                return hours <= hours_per_shift ? 0 : (hours - hours_per_shift)\n                        * payrate / 2;\n            }\n        },\n        weekend {\n            double overtimepay(double hours, double payrate) {\n                return hours * payrate / 2;\n            }\n        };\n        private static final int hours_per_shift = 8;\n\n        abstract double overtimepay(double hrs, double payrate);\n\n        double pay(double hoursworked, double payrate) {\n            double basepay = hoursworked * payrate;\n            return basepay + overtimepay(hoursworked, payrate);\n        }\n    }\n}\n\n\n测试\n\nsystem.out.println("时薪100的人在周五工作8小时的收入：" + payrollday.friday.pay(8.0, 100));\nsystem.out.println("时薪100的人在周六工作8小时的收入：" + payrollday.saturday.pay(8.0, 100));\n\n\n\n# 枚举实现单例模式\n\n单例模式是最常用的设计模式。\n\n单例模式在并发环境下存在线程安全问题。\n\n为了线程安全问题，传统做法有以下几种：\n\n * 饿汉式加载\n * 懒汉式 synchronize 和双重检查\n * 利用 java 的静态加载机制\n\n相比上述的方法，使用枚举也可以实现单例，而且还更加简单：\n\npublic class singleenumdemo {\n    public enum singleen {\n\n        instance;\n\n        private string name;\n\n        public string getname() {\n            return name;\n        }\n\n        public void setname(string name) {\n            this.name = name;\n        }\n    }\n\n    public static void main(string[] args) {\n        singleen.instance.setname("zp");\n        system.out.println(singleen.instance.getname());\n    }\n}\n\n\n> 扩展阅读：深入理解 java 枚举类型(enum)\n> \n> 这篇文章对于 java 枚举的特性讲解很仔细，其中对于枚举实现单例和传统单例实现方式说的尤为细致。\n\n\n# 枚举工具类\n\njava 中提供了两个方便操作 enum 的工具类——enumset 和 enummap。\n\n\n# enumset\n\nenumset 是枚举类型的高性能 set 实现。它要求放入它的枚举常量必须属于同一枚举类型。\n\n主要接口：\n\n * noneof - 创建一个具有指定元素类型的空 enumset\n * allof - 创建一个指定元素类型并包含所有枚举值的 enumset\n * range - 创建一个包括枚举值中指定范围元素的 enumset\n * complementof - 初始集合包括指定集合的补集\n * of - 创建一个包括参数中所有元素的 enumset\n * copyof - 创建一个包含参数容器中的所有元素的 enumset\n\n示例：\n\npublic class enumsetdemo {\n    public static void main(string[] args) {\n        system.out.println("enumset展示");\n        enumset<errorcodeen> errset = enumset.allof(errorcodeen.class);\n        for (errorcodeen e : errset) {\n            system.out.println(e.name() + " : " + e.ordinal());\n        }\n    }\n}\n\n\n\n# enummap\n\nenummap 是专门为枚举类型量身定做的 map 实现。虽然使用其它的 map 实现（如 hashmap）也能完成枚举类型实例到值得映射，但是使用 enummap 会更加高效：它只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 enummap 使用数组来存放与枚举类型对应的值。这使得 enummap 的效率非常高。\n\n主要接口：\n\n * size - 返回键值对数\n * containsvalue - 是否存在指定的 value\n * containskey - 是否存在指定的 key\n * get - 根据指定 key 获取 value\n * put - 取出指定的键值对\n * remove - 删除指定 key\n * putall - 批量取出键值对\n * clear - 清除数据\n * keyset - 获取 key 集合\n * values - 返回所有\n\n示例：\n\npublic class enummapdemo {\n    public enum signal {\n        green, yellow, red\n    }\n\n    public static void main(string[] args) {\n        system.out.println("enummap展示");\n        enummap<signal, string> errmap = new enummap(signal.class);\n        errmap.put(signal.red, "红灯");\n        errmap.put(signal.yellow, "黄灯");\n        errmap.put(signal.green, "绿灯");\n        for (iterator<map.entry<signal, string>> iter = errmap.entryset().iterator(); iter.hasnext();) {\n            map.entry<signal, string> entry = iter.next();\n            system.out.println(entry.getkey().name() + " : " + entry.getvalue());\n        }\n    }\n}\n\n\n> 扩展阅读：深入理解 java 枚举类型(enum)\n> \n> 这篇文章中对 enumset 和 enummap 原理做了较为详细的介绍。\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * 深入理解 java 枚举类型(enum)\n * https://droidyue.com/blog/2016/11/29/dive-into-enum/',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Java 面向对象",frontmatter:{title:"Java 面向对象",date:"2020-08-06T18:20:39.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","面向对象"],permalink:"/pages/3e1661/",abbrlink:"e4502010"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03.Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/03.Java面向对象.md",key:"v-39e1a6ba",path:"/pages/3e1661/",headers:[{level:2,title:"面向对象",slug:"面向对象",normalizedTitle:"面向对象",charIndex:7},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:708},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:343},{level:4,title:"继承类型",slug:"继承类型",normalizedTitle:"继承类型",charIndex:1214},{level:4,title:"继承的特性",slug:"继承的特性",normalizedTitle:"继承的特性",charIndex:1224},{level:4,title:"继承关键字",slug:"继承关键字",normalizedTitle:"继承关键字",charIndex:1520},{level:3,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:1664},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:25},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:756},{level:3,title:"方法定义",slug:"方法定义",normalizedTitle:"方法定义",charIndex:2327},{level:3,title:"方法调用",slug:"方法调用",normalizedTitle:"方法调用",charIndex:2761},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:1256},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:888},{level:3,title:"变量修饰符",slug:"变量修饰符",normalizedTitle:"变量修饰符",charIndex:5223},{level:3,title:"创建对象",slug:"创建对象",normalizedTitle:"创建对象",charIndex:399},{level:3,title:"访问实例变量和方法",slug:"访问实例变量和方法",normalizedTitle:"访问实例变量和方法",charIndex:5777},{level:2,title:"访问权限控制",slug:"访问权限控制",normalizedTitle:"访问权限控制",charIndex:5930},{level:3,title:"代码组织",slug:"代码组织",normalizedTitle:"代码组织",charIndex:5941},{level:4,title:"package",slug:"package",normalizedTitle:"package",charIndex:6523},{level:4,title:"import",slug:"import",normalizedTitle:"import",charIndex:1648},{level:3,title:"访问权限修饰关键字",slug:"访问权限修饰关键字",normalizedTitle:"访问权限修饰关键字",charIndex:7501},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:739},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:8007},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8470}],headersStr:"面向对象 封装 继承 继承类型 继承的特性 继承关键字 多态 类 方法 方法定义 方法调用 构造方法 变量 变量修饰符 创建对象 访问实例变量和方法 访问权限控制 代码组织 package import 访问权限修饰关键字 接口 抽象类 参考资料",content:'# Java 面向对象\n\n> 在Java 基本数据类型 中我们了解 Java 中支持的基本数据类型（值类型）。本文开始讲解 Java 中重要的引用类型——类。\n\n\n# 面向对象\n\n每种编程语言，都有自己的操纵内存中元素的方式。\n\nJava 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，Java 中，允许开发者通过类（类的机制下面会讲到）创建自定义类型。\n\n有了自定义类型，那么数据类型自然会千变万化，所以，必须要有一定的机制，使得它们仍然保持一些必要的、通用的特性。\n\nJava 世界有一句名言：一切皆为对象。这句话，你可能第一天学 Java 时，就听过了。这不仅仅是一句口号，也体现在 Java 的设计上。\n\n * 首先，所有 Java 类都继承自 Object 类（从这个名字，就可见一斑）。\n * 几乎所有 Java 对象初始化时，都要使用 new 创建对象（基本数据类型、String、枚举特殊处理），对象存储在堆中。\n\n// 下面两\nString s = "abc";\nString s = new String("abc");\n\n\n其中，String s 定义了一个名为 s 的引用，它指向一个 String 类型的对象，而实际的对象是 “abc” 字符串。这就像是，使用遥控器（引用）来操纵电视机（对象）。\n\n与 C/C++ 这类语言不同，程序员只需要通过 new 创建一个对象，但不必负责销毁或结束一个对象。负责运行 Java 程序的 Java 虚拟机有一个垃圾回收器，它会监视 new 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。\n\n\n# 封装\n\n封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n\n封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n封装的优点：\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n实现封装的步骤：\n\n 1. 修改属性的可见性来限制对属性的访问（一般限制为 private）。\n 2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。\n\n\n# 继承\n\n继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n现实中的例子：\n\n狗和鸟都是动物。如果将狗、鸟作为类，它们可以继承动物类。\n\n\n\n类的继承形式：\n\nclass 父类 {}\n\nclass 子类 extends 父类 {}\n\n\n# 继承类型\n\n\n\n# 继承的特性\n\n * 子类可以继承父类的属性和方法。需要注意的是，构造方法除外，构造方法只能被调用，而不能被继承。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# 多态\n\n刚开始学习面向对象编程时，容易被各种术语弄得云里雾里。所以，很多人会死记硬背书中对于术语的定义。\n\n但是，随着应用和理解的深入，应该会渐渐有更进一步的认识，将其融汇贯通的理解。\n\n学习类之前，先让我们思考一个问题：Java 中为什么要引入类机制，设计的初衷是什么？\n\nJava 中提供的基本数据类型，只能表示单一的数值，这用于数值计算，还 OK。但是，如果要抽象模拟现实中更复杂的事物，则无法做到。\n\n试想，如果要让你抽象狗的数据模型，怎么做？狗有眼耳口鼻等器官，有腿，狗有大小，毛色，这些都是它的状态，狗会跑、会叫、会吃东西，这些是它的行为。\n\n类的引入，就是为了抽象这种相对复杂的事物。\n\n对象是用于计算机语言对问题域中事物的描述。对象通过方法和属性来分别描述事物所具有的行为和状态。\n\n类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的行为和状态。\n\n类可以看成是创建 Java 对象的模板。\n\n什么是方法？扩展阅读：面向对象编程的弊端是什么？ - invalid s 的回答\n\n\n# 类\n\n与大多数面向对象编程语言一样，Java 使用 class （类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。\n\n在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。\n\n * 属性（有的人喜欢称为成员、字段） - 属性抽象的是事物的状态。类属性可以是任何类型的对象。\n * 方法（有的人喜欢称为函数） - 方法抽象的是事物的行为。\n\n类的形式如下：\n\n\n\n\n# 方法\n\n\n# 方法定义\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n * **返回值类型 ：**方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。\n * **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n * **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n示例：\n\npublic static int add(int x, int y) {\n   return x + y;\n}\n\n\n\n# 方法调用\n\nJava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n如果方法返回值是 void，方法调用一定是一条语句。例如，方法 println 返回 void。下面的调用是个语句：\n\nSystem.out.println("Hello World");\n\n\n\n# 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，Java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class Puppy{\n    public Puppy(){\n    }\n\n    public Puppy(String name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n\n\n\n# 变量\n\nJava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。   静态变量可以通过：ClassName.VariableName 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n\n# 变量修饰符\n\n * 访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符 - 如果变量是类变量，需要添加 static 修饰\n * final - 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 创建对象\n\n对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n * 声明：声明一个对象，包括对象名称和对象类型。\n * 实例化：使用关键字 new 来创建一个对象。\n * 初始化：使用 new 创建对象时，会调用构造方法初始化对象。\n\npublic class Puppy{\n   public Puppy(String name){\n      //这个构造器仅有一个参数：name\n      System.out.println("小狗的名字是 : " + name );\n   }\n   public static void main(String[] args){\n      // 下面的语句将创建一个Puppy对象\n      Puppy myPuppy = new Puppy( "tommy" );\n   }\n}\n\n\n\n# 访问实例变量和方法\n\n/* 实例化对象 */\nObjectReference = new Constructor();\n/* 访问类中的变量 */\nObjectReference.variableName;\n/* 访问类中的方法 */\nObjectReference.methodName();\n\n\n\n# 访问权限控制\n\n\n# 代码组织\n\n当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。\n\nMultiClassDemo.java 示例：\n\nclass MultiClass1 {}\n\nclass MultiClass2 {}\n\nclass MultiClass3 {}\n\npublic class MultiClassDemo {}\n\n\n执行 javac MultiClassDemo.java 命令，本地会生成 MultiClass1.class、MultiClass2.class、MultiClass3.class、MultiClassDemo.class 四个文件。\n\nJava 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件。Java 解释器负责这些文件的查找、装载和解释。Java 类库实际上是一组类文件（.java 文件）。\n\n * 其中每个文件允许有一个 public 类，以及任意数量的非 public 类。\n * public 类名必须和 .java 文件名完全相同，包括大小写。\n\n程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名/接口名，这就是命名冲突。\n\nJava 中为了解决命名冲突问题，提供了包（package）和导入（import）机制。\n\n# package\n\n包（package）的原则：\n\n * 包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个有层次的树形结构，包也类似。\n * 包名以逗号 . 分隔，表示层次结构。\n * Java 中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是：apache.org，包名就以 org.apache 开头。\n * **包名和文件目录结构必须完全匹配。**Java 解释器运行过程如下：\n   * 找出环境变量 CLASSPATH，作为 .class 文件的根目录。\n   * 从根目录开始，获取包名称，并将逗号 . 替换为文件分隔符（反斜杠 /），通过这个路径名称去查找 Java 类。\n\n# import\n\n同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：\n\n * 通过类的完全限定名\n * 通过 import 将用到的类引入到当前类\n\n通过类的完全限定名示例：\n\npublic class PackageDemo {\n    public static void main (String[]args){\n        System.out.println(new java.util.Date());\n        System.out.println(new java.util.Date());\n    }\n}\n\n\n通过 import 导入其它包的类到当前类：\n\nimport java.util.Date;\n\npublic class PackageDemo2 {\n    public static void main(String[] args) {\n        System.out.println(new Date());\n        System.out.println(new Date());\n    }\n}\n\n\n> 说明：以上两个示例比较起来，显然是 import 方式，代码更加整洁。\n\n> 扩展阅读：https://www.cnblogs.com/swiftma/p/5628762.html\n\n\n# 访问权限修饰关键字\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# 接口\n\n接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。\n\n接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。\n\nJava 标准类库中，定义了非常多的接口，比如 java.util.List。\n\npublic interface Comparable<T> {\n    public int compareTo(T o);\n}\n\n\n\n# 抽象类\n\n抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。\n\nJava 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。\n\n 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n# 参考资料\n\n * 书籍\n   * Java 编程思想\n   * Java 核心技术（卷 1）\n   * Head First Java\n * 文章\n   * 面向对象编程的弊端是什么？ - invalid s 的回答\n   * https://www.cnblogs.com/swiftma/p/5628762.html',normalizedContent:'# java 面向对象\n\n> 在java 基本数据类型 中我们了解 java 中支持的基本数据类型（值类型）。本文开始讲解 java 中重要的引用类型——类。\n\n\n# 面向对象\n\n每种编程语言，都有自己的操纵内存中元素的方式。\n\njava 中提供了基本数据类型，但这还不能满足编写程序时，需要抽象更加复杂数据类型的需要。因此，java 中，允许开发者通过类（类的机制下面会讲到）创建自定义类型。\n\n有了自定义类型，那么数据类型自然会千变万化，所以，必须要有一定的机制，使得它们仍然保持一些必要的、通用的特性。\n\njava 世界有一句名言：一切皆为对象。这句话，你可能第一天学 java 时，就听过了。这不仅仅是一句口号，也体现在 java 的设计上。\n\n * 首先，所有 java 类都继承自 object 类（从这个名字，就可见一斑）。\n * 几乎所有 java 对象初始化时，都要使用 new 创建对象（基本数据类型、string、枚举特殊处理），对象存储在堆中。\n\n// 下面两\nstring s = "abc";\nstring s = new string("abc");\n\n\n其中，string s 定义了一个名为 s 的引用，它指向一个 string 类型的对象，而实际的对象是 “abc” 字符串。这就像是，使用遥控器（引用）来操纵电视机（对象）。\n\n与 c/c++ 这类语言不同，程序员只需要通过 new 创建一个对象，但不必负责销毁或结束一个对象。负责运行 java 程序的 java 虚拟机有一个垃圾回收器，它会监视 new 创建的对象，一旦发现对象不再被引用，则会释放对象的内存空间。\n\n\n# 封装\n\n封装（encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。\n\n封装最主要的作用在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。\n\n适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。\n\n封装的优点：\n\n * 良好的封装能够减少耦合。\n * 类内部的结构可以自由修改。\n * 可以对成员变量进行更精确的控制。\n * 隐藏信息，实现细节。\n\n实现封装的步骤：\n\n 1. 修改属性的可见性来限制对属性的访问（一般限制为 private）。\n 2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问。\n\n\n# 继承\n\n继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。\n\n继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。\n\n现实中的例子：\n\n狗和鸟都是动物。如果将狗、鸟作为类，它们可以继承动物类。\n\n\n\n类的继承形式：\n\nclass 父类 {}\n\nclass 子类 extends 父类 {}\n\n\n# 继承类型\n\n\n\n# 继承的特性\n\n * 子类可以继承父类的属性和方法。需要注意的是，构造方法除外，构造方法只能被调用，而不能被继承。\n * 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n * 子类可以用自己的方式实现父类的方法。\n * java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 a 类继承 b 类，b 类继承 c 类，所以按照关系就是 c 类是 b 类的父类，b 类是 a 类的父类，这是 java 继承区别于 c++ 继承的一个特性。\n * 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n# 继承关键字\n\n继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 java.lang 包中，所以不需要 import）祖先类。\n\n\n# 多态\n\n刚开始学习面向对象编程时，容易被各种术语弄得云里雾里。所以，很多人会死记硬背书中对于术语的定义。\n\n但是，随着应用和理解的深入，应该会渐渐有更进一步的认识，将其融汇贯通的理解。\n\n学习类之前，先让我们思考一个问题：java 中为什么要引入类机制，设计的初衷是什么？\n\njava 中提供的基本数据类型，只能表示单一的数值，这用于数值计算，还 ok。但是，如果要抽象模拟现实中更复杂的事物，则无法做到。\n\n试想，如果要让你抽象狗的数据模型，怎么做？狗有眼耳口鼻等器官，有腿，狗有大小，毛色，这些都是它的状态，狗会跑、会叫、会吃东西，这些是它的行为。\n\n类的引入，就是为了抽象这种相对复杂的事物。\n\n对象是用于计算机语言对问题域中事物的描述。对象通过方法和属性来分别描述事物所具有的行为和状态。\n\n类是用于描述同一类的对象的一个抽象的概念，类中定义了这一类对象所具有的行为和状态。\n\n类可以看成是创建 java 对象的模板。\n\n什么是方法？扩展阅读：面向对象编程的弊端是什么？ - invalid s 的回答\n\n\n# 类\n\n与大多数面向对象编程语言一样，java 使用 class （类）关键字来表示自定义类型。自定义类型是为了更容易抽象现实事物。\n\n在一个类中，可以设置一静一动两种元素：属性（静）和方法（动）。\n\n * 属性（有的人喜欢称为成员、字段） - 属性抽象的是事物的状态。类属性可以是任何类型的对象。\n * 方法（有的人喜欢称为函数） - 方法抽象的是事物的行为。\n\n类的形式如下：\n\n\n\n\n# 方法\n\n\n# 方法定义\n\n修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}\n\n\n方法包含一个方法头和一个方法体。下面是一个方法的所有部分：\n\n * **修饰符：**修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n * **返回值类型 ：**方法可能有返回值。如果没有返回值，这种情况下，返回值类型应设为 void。\n * **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。\n * **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n * **方法体：**方法体包含具体的语句，定义该方法的功能。\n\n示例：\n\npublic static int add(int x, int y) {\n   return x + y;\n}\n\n\n\n# 方法调用\n\njava 支持两种调用方法的方式，根据方法是否返回值来选择。\n\n当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。\n\n当方法返回一个值的时候，方法调用通常被当做一个值。例如：\n\nint larger = max(30, 40);\n\n\n如果方法返回值是 void，方法调用一定是一条语句。例如，方法 println 返回 void。下面的调用是个语句：\n\nsystem.out.println("hello world");\n\n\n\n# 构造方法\n\n每个类都有构造方法。如果没有显式地为类定义任何构造方法，java 编译器将会为该类提供一个默认构造方法。\n\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。\n\npublic class puppy{\n    public puppy(){\n    }\n\n    public puppy(string name){\n        // 这个构造器仅有一个参数：name\n    }\n}\n\n\n\n# 变量\n\njava 支持的变量类型有：\n\n * 局部变量 - 类方法中的变量。\n * 实例变量（也叫成员变量） - 类方法外的变量，不过没有 static 修饰。\n * 类变量（也叫静态变量） - 类方法外的变量，用 static 修饰。\n\n特性对比：\n\n局部变量                                                            实例变量（也叫成员变量）                                                             类变量（也叫静态变量）\n局部变量声明在方法、构造方法或者语句块中。                                           实例变量声明在方法、构造方法和语句块之外。                                                    类变量声明在方法、构造方法和语句块之外。并且以 static 修饰。\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。                    实例变量在对象创建的时候创建，在对象被销毁的时候销毁。                                              类变量在第一次被访问时创建，在程序结束时销毁。\n局部变量没有默认值，所以必须经过初始化，才可以使用。                                      实例变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是                      类变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是\n                                                                null。变量的值可以在声明时指定，也可以在构造方法中指定。                                           null。变量的值可以在声明时指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。   实例变量存储在堆。                                                                类变量存储在静态存储区。\n访问修饰符不能用于局部变量。                                                  访问修饰符可以用于实例变量。                                                           访问修饰符可以用于类变量。\n局部变量只在声明它的方法、构造方法或者语句块中可见。                                      实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见。        与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n                                                                实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：obejectreference.variablename。   静态变量可以通过：classname.variablename 的方式访问。\n                                                                                                                                         无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n                                                                                                                                         类变量除了被声明为常量外很少使用。\n\n\n# 变量修饰符\n\n * 访问级别修饰符 - 如果变量是实例变量或类变量，可以添加访问级别修饰符（public/protected/private）\n * 静态修饰符 - 如果变量是类变量，需要添加 static 修饰\n * final - 如果变量使用 fianl 修饰符，就表示这是一个常量，不能被修改。\n\n\n# 创建对象\n\n对象是根据类创建的。在 java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：\n\n * 声明：声明一个对象，包括对象名称和对象类型。\n * 实例化：使用关键字 new 来创建一个对象。\n * 初始化：使用 new 创建对象时，会调用构造方法初始化对象。\n\npublic class puppy{\n   public puppy(string name){\n      //这个构造器仅有一个参数：name\n      system.out.println("小狗的名字是 : " + name );\n   }\n   public static void main(string[] args){\n      // 下面的语句将创建一个puppy对象\n      puppy mypuppy = new puppy( "tommy" );\n   }\n}\n\n\n\n# 访问实例变量和方法\n\n/* 实例化对象 */\nobjectreference = new constructor();\n/* 访问类中的变量 */\nobjectreference.variablename;\n/* 访问类中的方法 */\nobjectreference.methodname();\n\n\n\n# 访问权限控制\n\n\n# 代码组织\n\n当编译一个 .java 文件时，在 .java 文件中的每个类都会输出一个与类同名的 .class 文件。\n\nmulticlassdemo.java 示例：\n\nclass multiclass1 {}\n\nclass multiclass2 {}\n\nclass multiclass3 {}\n\npublic class multiclassdemo {}\n\n\n执行 javac multiclassdemo.java 命令，本地会生成 multiclass1.class、multiclass2.class、multiclass3.class、multiclassdemo.class 四个文件。\n\njava 可运行程序是由一组 .class 文件打包并压缩成的一个 .jar 文件。java 解释器负责这些文件的查找、装载和解释。java 类库实际上是一组类文件（.java 文件）。\n\n * 其中每个文件允许有一个 public 类，以及任意数量的非 public 类。\n * public 类名必须和 .java 文件名完全相同，包括大小写。\n\n程序一般不止一个人编写，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人因为不同的目的可能定义同样的类名/接口名，这就是命名冲突。\n\njava 中为了解决命名冲突问题，提供了包（package）和导入（import）机制。\n\n# package\n\n包（package）的原则：\n\n * 包类似于文件夹，文件放在文件夹中，类和接口则放在包中。为了便于组织，文件夹一般是一个有层次的树形结构，包也类似。\n * 包名以逗号 . 分隔，表示层次结构。\n * java 中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是：apache.org，包名就以 org.apache 开头。\n * **包名和文件目录结构必须完全匹配。**java 解释器运行过程如下：\n   * 找出环境变量 classpath，作为 .class 文件的根目录。\n   * 从根目录开始，获取包名称，并将逗号 . 替换为文件分隔符（反斜杠 /），通过这个路径名称去查找 java 类。\n\n# import\n\n同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包，使用有两种方式：\n\n * 通过类的完全限定名\n * 通过 import 将用到的类引入到当前类\n\n通过类的完全限定名示例：\n\npublic class packagedemo {\n    public static void main (string[]args){\n        system.out.println(new java.util.date());\n        system.out.println(new java.util.date());\n    }\n}\n\n\n通过 import 导入其它包的类到当前类：\n\nimport java.util.date;\n\npublic class packagedemo2 {\n    public static void main(string[] args) {\n        system.out.println(new date());\n        system.out.println(new date());\n    }\n}\n\n\n> 说明：以上两个示例比较起来，显然是 import 方式，代码更加整洁。\n\n> 扩展阅读：https://www.cnblogs.com/swiftma/p/5628762.html\n\n\n# 访问权限修饰关键字\n\n访问权限控制的等级，从最大权限到最小权限依次为：\n\npublic > protected > 包访问权限（没有任何关键字）> private\n\n\n * public - 表示任何类都可以访问；\n * 包访问权限 - 包访问权限，没有任何关键字。它表示当前包中的所有其他类都可以访问，但是其它包的类无法访问。\n * protected - 表示子类可以访问，此外，同一个包内的其他类也可以访问，即使这些类不是子类。\n * private - 表示其它任何类都无法访问。\n\n\n# 接口\n\n接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 api 定义和实现分离的目的。\n\n接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说要么是抽象方法，要么是静态方法。\n\njava 标准类库中，定义了非常多的接口，比如 java.util.list。\n\npublic interface comparable<t> {\n    public int compareto(t o);\n}\n\n\n\n# 抽象类\n\n抽象类是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。\n\njava 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.abstractlist。\n\n 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。\n 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n 4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。\n\n\n# 参考资料\n\n * 书籍\n   * java 编程思想\n   * java 核心技术（卷 1）\n   * head first java\n * 文章\n   * 面向对象编程的弊端是什么？ - invalid s 的回答\n   * https://www.cnblogs.com/swiftma/p/5628762.html',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Java 控制语句",frontmatter:{title:"Java 控制语句",date:"2020-10-17T19:13:25.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","控制语句"],permalink:"/pages/fb4f8c/",abbrlink:"cf286442"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/07.Java%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/07.Java控制语句.md",key:"v-4cadd5a4",path:"/pages/fb4f8c/",headers:[{level:2,title:"选择语句",slug:"选择语句",normalizedTitle:"选择语句",charIndex:42},{level:3,title:"if 语句",slug:"if-语句",normalizedTitle:"if 语句",charIndex:219},{level:3,title:"if...else 语句",slug:"if-else-语句",normalizedTitle:"if...else 语句",charIndex:523},{level:3,title:"if...else if...else 语句",slug:"if-else-if-else-语句",normalizedTitle:"if...else if...else 语句",charIndex:933},{level:3,title:"嵌套的 if…else 语句",slug:"嵌套的-if-else-语句",normalizedTitle:"嵌套的 if…else 语句",charIndex:1744},{level:3,title:"switch 语句",slug:"switch-语句",normalizedTitle:"switch 语句",charIndex:2227},{level:2,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:91},{level:3,title:"while 循环",slug:"while-循环",normalizedTitle:"while 循环",charIndex:3635},{level:3,title:"do while 循环",slug:"do-while-循环",normalizedTitle:"do while 循环",charIndex:4161},{level:3,title:"for 循环",slug:"for-循环",normalizedTitle:"for 循环",charIndex:4832},{level:3,title:"foreach 循环",slug:"foreach-循环",normalizedTitle:"foreach 循环",charIndex:5564},{level:2,title:"中断语句",slug:"中断语句",normalizedTitle:"中断语句",charIndex:158},{level:3,title:"break 关键字",slug:"break-关键字",normalizedTitle:"break 关键字",charIndex:6263},{level:3,title:"continue 关键字",slug:"continue-关键字",normalizedTitle:"continue 关键字",charIndex:6737},{level:3,title:"return 关键字",slug:"return-关键字",normalizedTitle:"return 关键字",charIndex:7223},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:7675},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7876}],headersStr:"选择语句 if 语句 if...else 语句 if...else if...else 语句 嵌套的 if…else 语句 switch 语句 循环语句 while 循环 do while 循环 for 循环 foreach 循环 中断语句 break 关键字 continue 关键字 return 关键字 最佳实践 参考资料",content:'# Java 控制语句\n\n> Java 控制语句大致可分为三大类：\n> \n>  * 选择语句\n>    * if, else-if, else\n>    * switch\n>  * 循环语句\n>    * while\n>    * do...while\n>    * for\n>    * foreach\n>  * 中断语句\n>    * break\n>    * continue\n>    * return\n\n\n# 选择语句\n\n\n# if 语句\n\nif 语句会判断括号中的条件是否成立，如果成立则执行 if 语句中的代码块，否则跳过代码块继续执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式为true将执行的语句\n}\n\n\n示例\n\npublic class IfDemo {\n    public static void main(String args[]) {\n        int x = 10;\n        if (x < 20) {\n            System.out.print("这是 if 语句");\n        }\n    }\n}\n// output:\n// 这是 if 语句\n\n\n\n# if...else 语句\n\nif 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式的值为true\n} else {\n   //如果布尔表达式的值为false\n}\n\n\n示例\n\npublic class IfElseDemo {\n    public static void main(String args[]) {\n        int x = 30;\n        if (x < 20) {\n            System.out.print("这是 if 语句");\n        } else {\n            System.out.print("这是 else 语句");\n        }\n    }\n}\n// output:\n// 这是 else 语句\n\n\n\n# if...else if...else 语句\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n语法\n\nif (布尔表达式 1) {\n   //如果布尔表达式 1的值为true执行代码\n} else if (布尔表达式 2) {\n   //如果布尔表达式 2的值为true执行代码\n} else if (布尔表达式 3) {\n   //如果布尔表达式 3的值为true执行代码\n} else {\n   //如果以上布尔表达式都不为true执行代码\n}\n\n\n示例\n\npublic class IfElseifElseDemo {\n    public static void main(String args[]) {\n        int x = 3;\n\n        if (x == 1) {\n            System.out.print("Value of X is 1");\n        } else if (x == 2) {\n            System.out.print("Value of X is 2");\n        } else if (x == 3) {\n            System.out.print("Value of X is 3");\n        } else {\n            System.out.print("This is else statement");\n        }\n    }\n}\n// output:\n// Value of X is 3\n\n\n\n# 嵌套的 if…else 语句\n\n使用嵌套的 if else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。\n\n语法\n\nif (布尔表达式 1) {\n   ////如果布尔表达式 1的值为true执行代码\n   if (布尔表达式 2) {\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n\n\n示例\n\npublic class IfNestDemo {\n    public static void main(String args[]) {\n        int x = 30;\n        int y = 10;\n\n        if (x == 30) {\n            if (y == 10) {\n                System.out.print("X = 30 and Y = 10");\n            }\n        }\n    }\n}\n// output:\n// X = 30 and Y = 10\n\n\n\n# switch 语句\n\nswitch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch 语句有如下规则：\n\n * switch 语句中的变量类型只能为 byte、short、int、char 或者 String。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\n语法\n\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n       break; //可选，但一般建议加上\n}\n\n\n示例\n\npublic class SwitchDemo {\n    public static void main(String args[]) {\n        char grade = \'C\';\n\n        switch (grade) {\n        case \'A\':\n            System.out.println("Excellent!");\n            break;\n        case \'B\':\n        case \'C\':\n            System.out.println("Well done");\n            break;\n        case \'D\':\n            System.out.println("You passed");\n        case \'F\':\n            System.out.println("Better try again");\n            break;\n        default:\n            System.out.println("Invalid grade");\n            break;\n        }\n        System.out.println("Your grade is " + grade);\n    }\n}\n// output:\n// Well done\n// Your grade is C\n\n\n\n# 循环语句\n\n\n# while 循环\n\n只要布尔表达式为 true，while 循环体会一直执行下去。\n\n语法\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n示例\n\npublic class WhileDemo {\n    public static void main(String args[]) {\n        int x = 10;\n        while (x < 20) {\n            System.out.print("value of x : " + x);\n            x++;\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# do while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo while 循环和 while 循环相似，不同的是，do while 循环至少会执行一次。\n\n语法\n\ndo {\n    //代码语句\n} while (布尔表达式);\n\n\n布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n示例\n\npublic class DoWhileDemo {\n    public static void main(String args[]) {\n        int x = 10;\n\n        do {\n            System.out.print("value of x : " + x);\n            x++;\n            System.out.print("\\n");\n        } while (x < 20);\n    }\n}\n// output:\n// value of x:10\n// value of x:11\n// value of x:12\n// value of x:13\n// value of x:14\n// value of x:15\n// value of x:16\n// value of x:17\n// value of x:18\n// value of x:19\n\n\n\n# for 循环\n\n虽然所有循环结构都可以用 while 或者 do while 表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。\n\n语法\n\nfor (初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n示例\n\npublic class ForDemo {\n    public static void main(String args[]) {\n        for (int x = 10; x < 20; x = x + 1) {\n            System.out.print("value of x : " + x);\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# foreach 循环\n\nJava5 引入了一种主要用于数组的增强型 for 循环。\n\n语法\n\nfor (声明语句 : 表达式) {\n    //代码句子\n}\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n示例\n\npublic class ForeachDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            System.out.print(x);\n            System.out.print(",");\n        }\n\n        System.out.print("\\n");\n        String[] names = { "James", "Larry", "Tom", "Lacy" };\n\n        for (String name : names) {\n            System.out.print(name);\n            System.out.print(",");\n        }\n    }\n}\n// output:\n// 10,20,30,40,50,\n// James,Larry,Tom,Lacy,\n\n\n\n# 中断语句\n\n\n# break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n示例\n\npublic class BreakDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                break;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n\n        System.out.println("break 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n// break 示例结束\n\n\n\n# continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n示例\n\npublic class ContinueDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                continue;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n    }\n}\n// output:\n// 10\n// 20\n// 40\n// 50\n\n\n\n# return 关键字\n\n跳出整个函数体，函数体后面的部分不再执行。\n\n示例\n\npublic class ReturnDemo {\n    public static void main(String args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                return;\n            }\n            System.out.print(x);\n            System.out.print("\\n");\n        }\n\n        System.out.println("return 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n\n\n> 🔔 注意：请仔细体会一下 return 和 break 的区别。\n\n\n# 最佳实践\n\n * 选择分支特别多的情况下，switch 语句优于 if...else if...else 语句。\n * switch 语句不要吝啬使用 default。\n * switch 语句中的 default 要放在最后。\n * foreach 循环优先于传统的 for 循环\n * 不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（Iterator），删除元素。\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）',normalizedContent:'# java 控制语句\n\n> java 控制语句大致可分为三大类：\n> \n>  * 选择语句\n>    * if, else-if, else\n>    * switch\n>  * 循环语句\n>    * while\n>    * do...while\n>    * for\n>    * foreach\n>  * 中断语句\n>    * break\n>    * continue\n>    * return\n\n\n# 选择语句\n\n\n# if 语句\n\nif 语句会判断括号中的条件是否成立，如果成立则执行 if 语句中的代码块，否则跳过代码块继续执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式为true将执行的语句\n}\n\n\n示例\n\npublic class ifdemo {\n    public static void main(string args[]) {\n        int x = 10;\n        if (x < 20) {\n            system.out.print("这是 if 语句");\n        }\n    }\n}\n// output:\n// 这是 if 语句\n\n\n\n# if...else 语句\n\nif 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。\n\n语法\n\nif(布尔表达式) {\n   //如果布尔表达式的值为true\n} else {\n   //如果布尔表达式的值为false\n}\n\n\n示例\n\npublic class ifelsedemo {\n    public static void main(string args[]) {\n        int x = 30;\n        if (x < 20) {\n            system.out.print("这是 if 语句");\n        } else {\n            system.out.print("这是 else 语句");\n        }\n    }\n}\n// output:\n// 这是 else 语句\n\n\n\n# if...else if...else 语句\n\n * if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。\n * if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。\n * 一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。\n\n语法\n\nif (布尔表达式 1) {\n   //如果布尔表达式 1的值为true执行代码\n} else if (布尔表达式 2) {\n   //如果布尔表达式 2的值为true执行代码\n} else if (布尔表达式 3) {\n   //如果布尔表达式 3的值为true执行代码\n} else {\n   //如果以上布尔表达式都不为true执行代码\n}\n\n\n示例\n\npublic class ifelseifelsedemo {\n    public static void main(string args[]) {\n        int x = 3;\n\n        if (x == 1) {\n            system.out.print("value of x is 1");\n        } else if (x == 2) {\n            system.out.print("value of x is 2");\n        } else if (x == 3) {\n            system.out.print("value of x is 3");\n        } else {\n            system.out.print("this is else statement");\n        }\n    }\n}\n// output:\n// value of x is 3\n\n\n\n# 嵌套的 if…else 语句\n\n使用嵌套的 if else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。\n\n语法\n\nif (布尔表达式 1) {\n   ////如果布尔表达式 1的值为true执行代码\n   if (布尔表达式 2) {\n      ////如果布尔表达式 2的值为true执行代码\n   }\n}\n\n\n示例\n\npublic class ifnestdemo {\n    public static void main(string args[]) {\n        int x = 30;\n        int y = 10;\n\n        if (x == 30) {\n            if (y == 10) {\n                system.out.print("x = 30 and y = 10");\n            }\n        }\n    }\n}\n// output:\n// x = 30 and y = 10\n\n\n\n# switch 语句\n\nswitch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。\n\nswitch 语句有如下规则：\n\n * switch 语句中的变量类型只能为 byte、short、int、char 或者 string。\n * switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n * case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n * 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n * 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n * switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。\n\n语法\n\nswitch(expression){\n    case value :\n       //语句\n       break; //可选\n    case value :\n       //语句\n       break; //可选\n    //你可以有任意数量的case语句\n    default : //可选\n       //语句\n       break; //可选，但一般建议加上\n}\n\n\n示例\n\npublic class switchdemo {\n    public static void main(string args[]) {\n        char grade = \'c\';\n\n        switch (grade) {\n        case \'a\':\n            system.out.println("excellent!");\n            break;\n        case \'b\':\n        case \'c\':\n            system.out.println("well done");\n            break;\n        case \'d\':\n            system.out.println("you passed");\n        case \'f\':\n            system.out.println("better try again");\n            break;\n        default:\n            system.out.println("invalid grade");\n            break;\n        }\n        system.out.println("your grade is " + grade);\n    }\n}\n// output:\n// well done\n// your grade is c\n\n\n\n# 循环语句\n\n\n# while 循环\n\n只要布尔表达式为 true，while 循环体会一直执行下去。\n\n语法\n\nwhile( 布尔表达式 ) {\n    //循环内容\n}\n\n\n示例\n\npublic class whiledemo {\n    public static void main(string args[]) {\n        int x = 10;\n        while (x < 20) {\n            system.out.print("value of x : " + x);\n            x++;\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# do while 循环\n\n对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n\ndo while 循环和 while 循环相似，不同的是，do while 循环至少会执行一次。\n\n语法\n\ndo {\n    //代码语句\n} while (布尔表达式);\n\n\n布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。\n\n示例\n\npublic class dowhiledemo {\n    public static void main(string args[]) {\n        int x = 10;\n\n        do {\n            system.out.print("value of x : " + x);\n            x++;\n            system.out.print("\\n");\n        } while (x < 20);\n    }\n}\n// output:\n// value of x:10\n// value of x:11\n// value of x:12\n// value of x:13\n// value of x:14\n// value of x:15\n// value of x:16\n// value of x:17\n// value of x:18\n// value of x:19\n\n\n\n# for 循环\n\n虽然所有循环结构都可以用 while 或者 do while 表示，但 java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。 for 循环执行的次数是在执行前就确定的。\n\n语法\n\nfor (初始化; 布尔表达式; 更新) {\n    //代码语句\n}\n\n\n * 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n * 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为 false，循环终止，开始执行循环体后面的语句。\n * 执行一次循环后，更新循环控制变量。\n * 再次检测布尔表达式。循环执行上面的过程。\n\n示例\n\npublic class fordemo {\n    public static void main(string args[]) {\n        for (int x = 10; x < 20; x = x + 1) {\n            system.out.print("value of x : " + x);\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// value of x : 10\n// value of x : 11\n// value of x : 12\n// value of x : 13\n// value of x : 14\n// value of x : 15\n// value of x : 16\n// value of x : 17\n// value of x : 18\n// value of x : 19\n\n\n\n# foreach 循环\n\njava5 引入了一种主要用于数组的增强型 for 循环。\n\n语法\n\nfor (声明语句 : 表达式) {\n    //代码句子\n}\n\n\n声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n\n表达式：表达式是要访问的数组名，或者是返回值为数组的方法。\n\n示例\n\npublic class foreachdemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            system.out.print(x);\n            system.out.print(",");\n        }\n\n        system.out.print("\\n");\n        string[] names = { "james", "larry", "tom", "lacy" };\n\n        for (string name : names) {\n            system.out.print(name);\n            system.out.print(",");\n        }\n    }\n}\n// output:\n// 10,20,30,40,50,\n// james,larry,tom,lacy,\n\n\n\n# 中断语句\n\n\n# break 关键字\n\nbreak 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。\n\nbreak 跳出最里层的循环，并且继续执行该循环下面的语句。\n\n示例\n\npublic class breakdemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                break;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n\n        system.out.println("break 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n// break 示例结束\n\n\n\n# continue 关键字\n\ncontinue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do while 循环中，程序立即跳转到布尔表达式的判断语句。\n\n示例\n\npublic class continuedemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                continue;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n    }\n}\n// output:\n// 10\n// 20\n// 40\n// 50\n\n\n\n# return 关键字\n\n跳出整个函数体，函数体后面的部分不再执行。\n\n示例\n\npublic class returndemo {\n    public static void main(string args[]) {\n        int[] numbers = { 10, 20, 30, 40, 50 };\n\n        for (int x : numbers) {\n            if (x == 30) {\n                return;\n            }\n            system.out.print(x);\n            system.out.print("\\n");\n        }\n\n        system.out.println("return 示例结束");\n    }\n}\n// output:\n// 10\n// 20\n\n\n> 🔔 注意：请仔细体会一下 return 和 break 的区别。\n\n\n# 最佳实践\n\n * 选择分支特别多的情况下，switch 语句优于 if...else if...else 语句。\n * switch 语句不要吝啬使用 default。\n * switch 语句中的 default 要放在最后。\n * foreach 循环优先于传统的 for 循环\n * 不要循环遍历容器元素，然后删除特定元素。正确姿势应该是遍历容器的迭代器（iterator），删除元素。\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 异常",frontmatter:{title:"深入理解 Java 异常",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","异常"],permalink:"/pages/37415c/",abbrlink:"3590bf3"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08.Java%E5%BC%82%E5%B8%B8.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/08.Java异常.md",key:"v-1a49289b",path:"/pages/37415c/",headers:[{level:2,title:"异常框架",slug:"异常框架",normalizedTitle:"异常框架",charIndex:21},{level:3,title:"Throwable",slug:"throwable",normalizedTitle:"throwable",charIndex:30},{level:3,title:"Error",slug:"error",normalizedTitle:"error",charIndex:68},{level:3,title:"Exception",slug:"exception",normalizedTitle:"exception",charIndex:78},{level:3,title:"RuntimeException",slug:"runtimeexception",normalizedTitle:"runtimeexception",charIndex:1915},{level:2,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:3479},{level:2,title:"抛出异常",slug:"抛出异常",normalizedTitle:"抛出异常",charIndex:4005},{level:2,title:"捕获异常",slug:"捕获异常",normalizedTitle:"捕获异常",charIndex:5730},{level:2,title:"异常链",slug:"异常链",normalizedTitle:"异常链",charIndex:7145},{level:2,title:"异常注意事项",slug:"异常注意事项",normalizedTitle:"异常注意事项",charIndex:8814},{level:3,title:"finally 覆盖异常",slug:"finally-覆盖异常",normalizedTitle:"finally 覆盖异常",charIndex:8825},{level:3,title:"覆盖抛出异常的方法",slug:"覆盖抛出异常的方法",normalizedTitle:"覆盖抛出异常的方法",charIndex:9472},{level:3,title:"异常和线程",slug:"异常和线程",normalizedTitle:"异常和线程",charIndex:10315},{level:2,title:"最佳实践",slug:"最佳实践",normalizedTitle:"最佳实践",charIndex:10411},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:11058}],headersStr:"异常框架 Throwable Error Exception RuntimeException 自定义异常 抛出异常 捕获异常 异常链 异常注意事项 finally 覆盖异常 覆盖抛出异常的方法 异常和线程 最佳实践 参考资料",content:'# 深入理解 Java 异常\n\n\n\n\n# 异常框架\n\n\n# Throwable\n\n**Throwable 是 Java 语言中所有错误（Error）和异常（Exception）的超类。**在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。\n\nThrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。\n\n主要方法：\n\n * fillInStackTrace - 用当前的调用栈层次填充 Throwable 对象栈层次，添加到栈层次任何先前信息中。\n * getMessage - 返回关于发生的异常的详细信息。这个消息在 Throwable 类的构造函数中初始化了。\n * getCause - 返回一个 Throwable 对象代表异常原因。\n * getStackTrace - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n * printStackTrace - 打印 toString() 结果和栈层次到 System.err，即错误输出流。\n * toString - 使用 getMessage 的结果返回代表 Throwable 对象的字符串。\n\n\n# Error\n\nError 是 Throwable 的一个子类。Error 表示正常情况下，不大可能出现的严重问题。编译器不会检查 Error。绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。\n\n常见 Error：\n\n * AssertionError - 断言错误。\n * VirtualMachineError - 虚拟机错误。\n * UnsupportedClassVersionError - Java 类版本错误。\n * StackOverflowError - 栈溢出错误。\n * OutOfMemoryError - 内存溢出错误。\n\n\n# Exception\n\nException 是 Throwable 的一个子类。**Exception 表示合理的应用程序可能想要捕获的条件。**Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。\n\nException 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。\n\n**编译器会检查 Exception 异常。**此类异常，要么通过 throws 进行声明抛出，要么通过 try catch 进行捕获处理，否则不能通过编译。\n\n常见 Exception：\n\n * ClassNotFoundException - 应用程序试图加载类时，找不到相应的类，抛出该异常。\n * CloneNotSupportedException - 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。\n * IllegalAccessException - 拒绝访问一个类的时候，抛出该异常。\n * InstantiationException - 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\n * InterruptedException - 一个线程被另一个线程中断，抛出该异常。\n * NoSuchFieldException - 请求的变量不存在。\n * NoSuchMethodException - 请求的方法不存在。\n\n示例：\n\npublic class ExceptionDemo {\n    public static void main(String[] args) {\n        Method method = String.class.getMethod("toString", int.class);\n    }\n};\n\n\n试图编译运行时会报错：\n\nError:(7, 47) java: 未报告的异常错误java.lang.NoSuchMethodException; 必须对其进行捕获或声明以便抛出\n\n\n\n# RuntimeException\n\nRuntimeException 是 Exception 的一个子类。RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。\n\n**编译器不会检查 RuntimeException 异常。**当程序中可能出现这类异常时，倘若既没有通过 throws 声明抛出它，也没有用 try catch 语句捕获它，程序还是会编译通过。\n\n示例：\n\npublic class RuntimeExceptionDemo {\n    public static void main(String[] args) {\n        // 此处产生了异常\n        int result = 10 / 0;\n        System.out.println("两个数字相除的结果：" + result);\n        System.out.println("----------------------------");\n    }\n};\n\n\n运行时输出：\n\nException in thread "main" java.lang.ArithmeticException: / by zero\n\tat io.github.dunwu.javacore.exception.RumtimeExceptionDemo01.main(RumtimeExceptionDemo01.java:6)\n\n\n常见 RuntimeException：\n\n * ArrayIndexOutOfBoundsException - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\n * ArrayStoreException - 试图将错误类型的对象存储到一个对象数组时抛出的异常。\n * ClassCastException - 当试图将对象强制转换为不是实例的子类时，抛出该异常。\n * IllegalArgumentException - 抛出的异常表明向方法传递了一个不合法或不正确的参数。\n * IllegalMonitorStateException - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\n * IllegalStateException - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。\n * IllegalThreadStateException - 线程没有处于请求操作所要求的适当状态时抛出的异常。\n * IndexOutOfBoundsException - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\n * NegativeArraySizeException - 如果应用程序试图创建大小为负的数组，则抛出该异常。\n * NullPointerException - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常\n * NumberFormatException - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\n * SecurityException - 由安全管理器抛出的异常，指示存在安全侵犯。\n * StringIndexOutOfBoundsException - 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。\n * UnsupportedOperationException - 当不支持请求的操作时，抛出该异常。\n\n\n# 自定义异常\n\n\n\n自定义一个异常类，只需要继承 Exception 或 RuntimeException 即可。\n\n示例：\n\npublic class MyExceptionDemo {\n    public static void main(String[] args) {\n        throw new MyException("自定义异常");\n    }\n\n    static class MyException extends RuntimeException {\n        public MyException(String message) {\n            super(message);\n        }\n    }\n}\n\n\n输出：\n\nException in thread "main" io.github.dunwu.javacore.exception.MyExceptionDemo$MyException: 自定义异常\n\tat io.github.dunwu.javacore.exception.MyExceptionDemo.main(MyExceptionDemo.java:9)\n\n\n\n# 抛出异常\n\n如果想在程序中明确地抛出异常，需要用到 throw 和 throws 。\n\n如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\nthrow 示例：\n\npublic class ThrowDemo {\n    public static void f() {\n        try {\n            throw new RuntimeException("抛出一个异常");\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        f();\n    }\n};\n\n\n输出：\n\njava.lang.RuntimeException: 抛出一个异常\n\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\nthrows 示例：\n\npublic class ThrowsDemo {\n    public static void f1() throws NoSuchMethodException, NoSuchFieldException {\n        Field field = Integer.class.getDeclaredField("digits");\n        if (field != null) {\n            System.out.println("反射获取 digits 方法成功");\n        }\n        Method method = String.class.getMethod("toString", int.class);\n        if (method != null) {\n            System.out.println("反射获取 toString 方法成功");\n        }\n    }\n\n    public static void f2() {\n        try {\n            // 调用 f1 处，如果不用 try catch ，编译时会报错\n            f1();\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        f2();\n    }\n};\n\n\n输出：\n\n反射获取 digits 方法成功\njava.lang.NoSuchMethodException: java.lang.String.toString(int)\n\tat java.lang.Class.getMethod(Class.java:1786)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.f1(ThrowsDemo.java:12)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.f2(ThrowsDemo.java:21)\n\tat io.github.dunwu.javacore.exception.ThrowsDemo.main(ThrowsDemo.java:30)\n\n\nthrow 和 throws 的区别：\n\n * throws 使用在函数上，throw 使用在函数内。\n * throws 后面跟异常类，可以跟多个，用逗号区别；throw 后面跟的是异常对象。\n\n\n# 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try catch 代码块放在异常可能发生的地方。\n\n它的语法形式如下：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (Exception e1) {\n    // 捕获并处理try抛出的异常类型Exception\n} catch (Exception2 e2) {\n    // 捕获并处理try抛出的异常类型Exception2\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n此外，JDK7 以后，catch 多种异常时，也可以像下面这样简化代码：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (Exception | Exception2 e) {\n    // 捕获并处理try抛出的异常类型\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n * try - try 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n * catch - catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。\n * finally - finally 语句块总是会被执行，无论是否出现异常。try catch 语句后不一定非要finally 语句。finally 常用于这样的场景：由于finally 语句块总是会被执行，所以那些在 try 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在finally 语句块中释放资源。\n * try、catch、finally 三个代码块中的局部变量不可共享使用。\n * catch 块尝试捕获异常时，是按照 catch 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 try 块下的多个 catch 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。\n\n示例：\n\npublic class TryCatchFinallyDemo {\n    public static void main(String[] args) {\n        try {\n            // 此处产生了异常\n            int temp = 10 / 0;\n            System.out.println("两个数字相除的结果：" + temp);\n            System.out.println("----------------------------");\n        } catch (ArithmeticException e) {\n            System.out.println("出现异常了：" + e);\n        } finally {\n            System.out.println("不管是否出现异常，都执行此代码");\n        }\n    }\n};\n\n\n运行时输出：\n\n出现异常了：java.lang.ArithmeticException: / by zero\n不管是否出现异常，都执行此代码\n\n\n\n# 异常链\n\n异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。\n\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n\n我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n\n【示例】\n\npublic class ExceptionChainDemo {\n    static class MyException1 extends Exception {\n        public MyException1(String message) {\n            super(message);\n        }\n    }\n\n    static class MyException2 extends Exception {\n        public MyException2(String message, Throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static void f1() throws MyException1 {\n        throw new MyException1("出现 MyException1");\n    }\n\n    public static void f2() throws MyException2 {\n        try {\n            f1();\n        } catch (MyException1 e) {\n            throw new MyException2("出现 MyException2", e);\n        }\n    }\n\n    public static void main(String[] args) throws MyException2 {\n        f2();\n    }\n}\n\n\n输出：\n\nException in thread "main" io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException2: 出现 MyException2\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:29)\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.main(ExceptionChainDemo.java:34)\nCaused by: io.github.dunwu.javacore.exception.ExceptionChainDemo$MyException1: 出现 MyException1\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f1(ExceptionChainDemo.java:22)\n\tat io.github.dunwu.javacore.exception.ExceptionChainDemo.f2(ExceptionChainDemo.java:27)\n\t... 1 more\n\n\n> 扩展阅读：https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10\n> \n> 这篇文章中对于异常链讲解比较详细。\n\n\n# 异常注意事项\n\n\n# finally 覆盖异常\n\nJava 异常处理中 finally 中的 return 会覆盖 catch 代码块中的 return 语句和 throw 语句，所以 Java 不建议在 finally 中使用 return 语句。\n\n此外 finally 中的 throw 语句也会覆盖 catch 代码块中的 return 语句和 throw 语句。\n\n示例：\n\npublic class FinallyOverrideExceptionDemo {\n    static void f() throws Exception {\n        try {\n            throw new Exception("A");\n        } catch (Exception e) {\n            throw new Exception("B");\n        } finally {\n            throw new Exception("C");\n        }\n    }\n\n    public static void main(String[] args) {\n        try {\n            f();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n\n\n输出：C\n\n\n# 覆盖抛出异常的方法\n\n当子类重写父类带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内——用于处理父类的 throws 方法的异常处理器，必须也适用于子类的这个带 throws 方法 。这是为了支持多态。\n\n示例：\n\npublic class ExceptionOverrideDemo {\n    static class Father {\n        public void start() throws IOException {\n            throw new IOException();\n        }\n    }\n\n    static class Son extends Father {\n        @Override\n        public void start() throws SQLException {\n            throw new SQLException();\n        }\n    }\n\n    public static void main(String[] args) {\n        Father obj1 = new Father();\n        Father obj2 = new Son();\n        try {\n            obj1.start();\n            obj2.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n> 上面的示例编译时会报错，原因在于：\n> \n> 因为 Son 类抛出异常的实质是 SQLException，而 IOException 无法处理它。那么这里的 try catch 就不能处理 Son 中的异常了。多态就不能实现了。\n\n\n# 异常和线程\n\n如果 Java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 Java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。\n\n\n# 最佳实践\n\n * 对可恢复的情况使用检查性异常（Exception），对编程错误使用运行时异常（RuntimeException）。\n * 优先使用 Java 标准的异常。\n * 抛出与抽象相对应的异常。\n * 在细节消息中包含能捕获失败的信息。\n * 尽可能减少 try 代码块的大小。\n * 尽量缩小异常范围。例如，如果明知尝试捕获的是一个 ArithmeticException，就应该 catch ArithmeticException，而不是 catch 范围较大的 RuntimeException，甚至是 Exception。\n * 尽量不要在 finally 块抛出异常或者返回值。\n * 不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。\n * 异常处理效率很低，所以不要用异常进行业务逻辑处理。\n * 各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。\n * 如何对异常进行分类：\n   * 逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。\n   * 代码错误，这类异常用于描述开发的代码错误，例如 NPE，ILLARG，都属于程序员制造的 BUG。\n   * 专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。\n\n> 扩展阅读：\n> \n>  * Effective java 中文版 之 第九章 异常\n>  * 优雅的处理你的 Java 异常\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java 中文版 之 第九章 异常\n * 优雅的处理你的 Java 异常\n * https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17\n * https://www.cnblogs.com/skywang12345/p/3544168.html\n * http://www.importnew.com/26613.html',normalizedContent:'# 深入理解 java 异常\n\n\n\n\n# 异常框架\n\n\n# throwable\n\n**throwable 是 java 语言中所有错误（error）和异常（exception）的超类。**在 java 中只有 throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。\n\nthrowable 包含了其线程创建时线程执行堆栈的快照，它提供了 printstacktrace() 等接口用于获取堆栈跟踪数据等信息。\n\n主要方法：\n\n * fillinstacktrace - 用当前的调用栈层次填充 throwable 对象栈层次，添加到栈层次任何先前信息中。\n * getmessage - 返回关于发生的异常的详细信息。这个消息在 throwable 类的构造函数中初始化了。\n * getcause - 返回一个 throwable 对象代表异常原因。\n * getstacktrace - 返回一个包含堆栈层次的数组。下标为 0 的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。\n * printstacktrace - 打印 tostring() 结果和栈层次到 system.err，即错误输出流。\n * tostring - 使用 getmessage 的结果返回代表 throwable 对象的字符串。\n\n\n# error\n\nerror 是 throwable 的一个子类。error 表示正常情况下，不大可能出现的严重问题。编译器不会检查 error。绝大部分的 error 都会导致程序（比如 jvm 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 outofmemoryerror 之类，都是 error 的子类。\n\n常见 error：\n\n * assertionerror - 断言错误。\n * virtualmachineerror - 虚拟机错误。\n * unsupportedclassversionerror - java 类版本错误。\n * stackoverflowerror - 栈溢出错误。\n * outofmemoryerror - 内存溢出错误。\n\n\n# exception\n\nexception 是 throwable 的一个子类。**exception 表示合理的应用程序可能想要捕获的条件。**exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。\n\nexception 又分为可检查（checked）异常和不检查（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。\n\n**编译器会检查 exception 异常。**此类异常，要么通过 throws 进行声明抛出，要么通过 try catch 进行捕获处理，否则不能通过编译。\n\n常见 exception：\n\n * classnotfoundexception - 应用程序试图加载类时，找不到相应的类，抛出该异常。\n * clonenotsupportedexception - 当调用 object 类中的 clone 方法克隆对象，但该对象的类无法实现 cloneable 接口时，抛出该异常。\n * illegalaccessexception - 拒绝访问一个类的时候，抛出该异常。\n * instantiationexception - 当试图使用 class 类中的 newinstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。\n * interruptedexception - 一个线程被另一个线程中断，抛出该异常。\n * nosuchfieldexception - 请求的变量不存在。\n * nosuchmethodexception - 请求的方法不存在。\n\n示例：\n\npublic class exceptiondemo {\n    public static void main(string[] args) {\n        method method = string.class.getmethod("tostring", int.class);\n    }\n};\n\n\n试图编译运行时会报错：\n\nerror:(7, 47) java: 未报告的异常错误java.lang.nosuchmethodexception; 必须对其进行捕获或声明以便抛出\n\n\n\n# runtimeexception\n\nruntimeexception 是 exception 的一个子类。runtimeexception 是那些可能在 java 虚拟机正常运行期间抛出的异常的超类。\n\n**编译器不会检查 runtimeexception 异常。**当程序中可能出现这类异常时，倘若既没有通过 throws 声明抛出它，也没有用 try catch 语句捕获它，程序还是会编译通过。\n\n示例：\n\npublic class runtimeexceptiondemo {\n    public static void main(string[] args) {\n        // 此处产生了异常\n        int result = 10 / 0;\n        system.out.println("两个数字相除的结果：" + result);\n        system.out.println("----------------------------");\n    }\n};\n\n\n运行时输出：\n\nexception in thread "main" java.lang.arithmeticexception: / by zero\n\tat io.github.dunwu.javacore.exception.rumtimeexceptiondemo01.main(rumtimeexceptiondemo01.java:6)\n\n\n常见 runtimeexception：\n\n * arrayindexoutofboundsexception - 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。\n * arraystoreexception - 试图将错误类型的对象存储到一个对象数组时抛出的异常。\n * classcastexception - 当试图将对象强制转换为不是实例的子类时，抛出该异常。\n * illegalargumentexception - 抛出的异常表明向方法传递了一个不合法或不正确的参数。\n * illegalmonitorstateexception - 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。\n * illegalstateexception - 在非法或不适当的时间调用方法时产生的信号。换句话说，即 java 环境或 java 应用程序没有处于请求操作所要求的适当状态下。\n * illegalthreadstateexception - 线程没有处于请求操作所要求的适当状态时抛出的异常。\n * indexoutofboundsexception - 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。\n * negativearraysizeexception - 如果应用程序试图创建大小为负的数组，则抛出该异常。\n * nullpointerexception - 当应用程序试图在需要对象的地方使用 null 时，抛出该异常\n * numberformatexception - 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\n * securityexception - 由安全管理器抛出的异常，指示存在安全侵犯。\n * stringindexoutofboundsexception - 此异常由 string 方法抛出，指示索引或者为负，或者超出字符串的大小。\n * unsupportedoperationexception - 当不支持请求的操作时，抛出该异常。\n\n\n# 自定义异常\n\n\n\n自定义一个异常类，只需要继承 exception 或 runtimeexception 即可。\n\n示例：\n\npublic class myexceptiondemo {\n    public static void main(string[] args) {\n        throw new myexception("自定义异常");\n    }\n\n    static class myexception extends runtimeexception {\n        public myexception(string message) {\n            super(message);\n        }\n    }\n}\n\n\n输出：\n\nexception in thread "main" io.github.dunwu.javacore.exception.myexceptiondemo$myexception: 自定义异常\n\tat io.github.dunwu.javacore.exception.myexceptiondemo.main(myexceptiondemo.java:9)\n\n\n\n# 抛出异常\n\n如果想在程序中明确地抛出异常，需要用到 throw 和 throws 。\n\n如果一个方法没有捕获一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\nthrow 示例：\n\npublic class throwdemo {\n    public static void f() {\n        try {\n            throw new runtimeexception("抛出一个异常");\n        } catch (exception e) {\n            system.out.println(e);\n        }\n    }\n\n    public static void main(string[] args) {\n        f();\n    }\n};\n\n\n输出：\n\njava.lang.runtimeexception: 抛出一个异常\n\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\nthrows 示例：\n\npublic class throwsdemo {\n    public static void f1() throws nosuchmethodexception, nosuchfieldexception {\n        field field = integer.class.getdeclaredfield("digits");\n        if (field != null) {\n            system.out.println("反射获取 digits 方法成功");\n        }\n        method method = string.class.getmethod("tostring", int.class);\n        if (method != null) {\n            system.out.println("反射获取 tostring 方法成功");\n        }\n    }\n\n    public static void f2() {\n        try {\n            // 调用 f1 处，如果不用 try catch ，编译时会报错\n            f1();\n        } catch (nosuchmethodexception e) {\n            e.printstacktrace();\n        } catch (nosuchfieldexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    public static void main(string[] args) {\n        f2();\n    }\n};\n\n\n输出：\n\n反射获取 digits 方法成功\njava.lang.nosuchmethodexception: java.lang.string.tostring(int)\n\tat java.lang.class.getmethod(class.java:1786)\n\tat io.github.dunwu.javacore.exception.throwsdemo.f1(throwsdemo.java:12)\n\tat io.github.dunwu.javacore.exception.throwsdemo.f2(throwsdemo.java:21)\n\tat io.github.dunwu.javacore.exception.throwsdemo.main(throwsdemo.java:30)\n\n\nthrow 和 throws 的区别：\n\n * throws 使用在函数上，throw 使用在函数内。\n * throws 后面跟异常类，可以跟多个，用逗号区别；throw 后面跟的是异常对象。\n\n\n# 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try catch 代码块放在异常可能发生的地方。\n\n它的语法形式如下：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (exception e1) {\n    // 捕获并处理try抛出的异常类型exception\n} catch (exception2 e2) {\n    // 捕获并处理try抛出的异常类型exception2\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n此外，jdk7 以后，catch 多种异常时，也可以像下面这样简化代码：\n\ntry {\n    // 可能会发生异常的代码块\n} catch (exception | exception2 e) {\n    // 捕获并处理try抛出的异常类型\n} finally {\n    // 无论是否发生异常，都将执行的代码块\n}\n\n\n * try - try 语句用于监听。将要被监听的代码(可能抛出异常的代码)放在 try 语句块之内，当 try 语句块内发生异常时，异常就被抛出。\n * catch - catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。\n * finally - finally 语句块总是会被执行，无论是否出现异常。try catch 语句后不一定非要finally 语句。finally 常用于这样的场景：由于finally 语句块总是会被执行，所以那些在 try 代码块中打开的，并且必须回收的物理资源(如数据库连接、网络连接和文件)，一般会放在finally 语句块中释放资源。\n * try、catch、finally 三个代码块中的局部变量不可共享使用。\n * catch 块尝试捕获异常时，是按照 catch 块的声明顺序从上往下寻找的，一旦匹配，就不会再向下执行。因此，如果同一个 try 块下的多个 catch 异常类型有父子关系，应该将子类异常放在前面，父类异常放在后面。\n\n示例：\n\npublic class trycatchfinallydemo {\n    public static void main(string[] args) {\n        try {\n            // 此处产生了异常\n            int temp = 10 / 0;\n            system.out.println("两个数字相除的结果：" + temp);\n            system.out.println("----------------------------");\n        } catch (arithmeticexception e) {\n            system.out.println("出现异常了：" + e);\n        } finally {\n            system.out.println("不管是否出现异常，都执行此代码");\n        }\n    }\n};\n\n\n运行时输出：\n\n出现异常了：java.lang.arithmeticexception: / by zero\n不管是否出现异常，都执行此代码\n\n\n\n# 异常链\n\n异常链是以一个异常对象为参数构造新的异常对象，新的异常对象将包含先前异常的信息。\n\n通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。\n\n我们有两种方式处理异常，一是 throws 抛出交给上级处理，二是 try…catch 做具体处理。try…catch 的 catch 块我们可以不需要做任何处理，仅仅只用 throw 这个关键字将我们封装异常信息主动抛出来。然后在通过关键字 throws 继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。\n\n【示例】\n\npublic class exceptionchaindemo {\n    static class myexception1 extends exception {\n        public myexception1(string message) {\n            super(message);\n        }\n    }\n\n    static class myexception2 extends exception {\n        public myexception2(string message, throwable cause) {\n            super(message, cause);\n        }\n    }\n\n    public static void f1() throws myexception1 {\n        throw new myexception1("出现 myexception1");\n    }\n\n    public static void f2() throws myexception2 {\n        try {\n            f1();\n        } catch (myexception1 e) {\n            throw new myexception2("出现 myexception2", e);\n        }\n    }\n\n    public static void main(string[] args) throws myexception2 {\n        f2();\n    }\n}\n\n\n输出：\n\nexception in thread "main" io.github.dunwu.javacore.exception.exceptionchaindemo$myexception2: 出现 myexception2\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f2(exceptionchaindemo.java:29)\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.main(exceptionchaindemo.java:34)\ncaused by: io.github.dunwu.javacore.exception.exceptionchaindemo$myexception1: 出现 myexception1\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f1(exceptionchaindemo.java:22)\n\tat io.github.dunwu.javacore.exception.exceptionchaindemo.f2(exceptionchaindemo.java:27)\n\t... 1 more\n\n\n> 扩展阅读：https://juejin.im/post/5b6d61e55188251b38129f9a#heading-10\n> \n> 这篇文章中对于异常链讲解比较详细。\n\n\n# 异常注意事项\n\n\n# finally 覆盖异常\n\njava 异常处理中 finally 中的 return 会覆盖 catch 代码块中的 return 语句和 throw 语句，所以 java 不建议在 finally 中使用 return 语句。\n\n此外 finally 中的 throw 语句也会覆盖 catch 代码块中的 return 语句和 throw 语句。\n\n示例：\n\npublic class finallyoverrideexceptiondemo {\n    static void f() throws exception {\n        try {\n            throw new exception("a");\n        } catch (exception e) {\n            throw new exception("b");\n        } finally {\n            throw new exception("c");\n        }\n    }\n\n    public static void main(string[] args) {\n        try {\n            f();\n        } catch (exception e) {\n            system.out.println(e.getmessage());\n        }\n    }\n}\n\n\n输出：c\n\n\n# 覆盖抛出异常的方法\n\n当子类重写父类带有 throws 声明的函数时，其 throws 声明的异常必须在父类异常的可控范围内——用于处理父类的 throws 方法的异常处理器，必须也适用于子类的这个带 throws 方法 。这是为了支持多态。\n\n示例：\n\npublic class exceptionoverridedemo {\n    static class father {\n        public void start() throws ioexception {\n            throw new ioexception();\n        }\n    }\n\n    static class son extends father {\n        @override\n        public void start() throws sqlexception {\n            throw new sqlexception();\n        }\n    }\n\n    public static void main(string[] args) {\n        father obj1 = new father();\n        father obj2 = new son();\n        try {\n            obj1.start();\n            obj2.start();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n> 上面的示例编译时会报错，原因在于：\n> \n> 因为 son 类抛出异常的实质是 sqlexception，而 ioexception 无法处理它。那么这里的 try catch 就不能处理 son 中的异常了。多态就不能实现了。\n\n\n# 异常和线程\n\n如果 java 程序只有一个线程，那么没有被任何代码处理的异常会导致程序终止。如果 java 程序是多线程的，那么没有被任何代码处理的异常仅仅会导致异常所在的线程结束。\n\n\n# 最佳实践\n\n * 对可恢复的情况使用检查性异常（exception），对编程错误使用运行时异常（runtimeexception）。\n * 优先使用 java 标准的异常。\n * 抛出与抽象相对应的异常。\n * 在细节消息中包含能捕获失败的信息。\n * 尽可能减少 try 代码块的大小。\n * 尽量缩小异常范围。例如，如果明知尝试捕获的是一个 arithmeticexception，就应该 catch arithmeticexception，而不是 catch 范围较大的 runtimeexception，甚至是 exception。\n * 尽量不要在 finally 块抛出异常或者返回值。\n * 不要忽略异常，一旦捕获异常，就应该处理，而非丢弃。\n * 异常处理效率很低，所以不要用异常进行业务逻辑处理。\n * 各类异常必须要有单独的日志记录，将异常分级，分类管理，因为有的时候仅仅想给第三方运维看到逻辑异常，而不是更细节的信息。\n * 如何对异常进行分类：\n   * 逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去，属于用户制造的意外。\n   * 代码错误，这类异常用于描述开发的代码错误，例如 npe，illarg，都属于程序员制造的 bug。\n   * 专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。\n\n> 扩展阅读：\n> \n>  * effective java 中文版 之 第九章 异常\n>  * 优雅的处理你的 java 异常\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java 中文版 之 第九章 异常\n * 优雅的处理你的 java 异常\n * https://juejin.im/post/5b6d61e55188251b38129f9a#heading-17\n * https://www.cnblogs.com/skywang12345/p/3544168.html\n * http://www.importnew.com/26613.html',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 泛型",frontmatter:{title:"深入理解 Java 泛型",date:"2020-10-17T19:13:25.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","泛型"],permalink:"/pages/33a820/",abbrlink:"568214ab"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/09.Java%E6%B3%9B%E5%9E%8B.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/09.Java泛型.md",key:"v-50c27a77",path:"/pages/33a820/",headers:[{level:2,title:"为什么需要泛型",slug:"为什么需要泛型",normalizedTitle:"为什么需要泛型",charIndex:19},{level:2,title:"泛型类型",slug:"泛型类型",normalizedTitle:"泛型类型",charIndex:1772},{level:3,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:1772},{level:3,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:4111},{level:2,title:"泛型方法",slug:"泛型方法",normalizedTitle:"泛型方法",charIndex:5069},{level:2,title:"类型擦除",slug:"类型擦除",normalizedTitle:"类型擦除",charIndex:6258},{level:2,title:"泛型和继承",slug:"泛型和继承",normalizedTitle:"泛型和继承",charIndex:7203},{level:2,title:"类型边界",slug:"类型边界",normalizedTitle:"类型边界",charIndex:6409},{level:2,title:"类型通配符",slug:"类型通配符",normalizedTitle:"类型通配符",charIndex:9090},{level:3,title:"上界通配符",slug:"上界通配符",normalizedTitle:"上界通配符",charIndex:9191},{level:3,title:"下界通配符",slug:"下界通配符",normalizedTitle:"下界通配符",charIndex:9680},{level:3,title:"无界通配符",slug:"无界通配符",normalizedTitle:"无界通配符",charIndex:10194},{level:3,title:"通配符和向上转型",slug:"通配符和向上转型",normalizedTitle:"通配符和向上转型",charIndex:10754},{level:2,title:"泛型的约束",slug:"泛型的约束",normalizedTitle:"泛型的约束",charIndex:11140},{level:2,title:"泛型最佳实践",slug:"泛型最佳实践",normalizedTitle:"泛型最佳实践",charIndex:12337},{level:3,title:"泛型命名",slug:"泛型命名",normalizedTitle:"泛型命名",charIndex:12348},{level:3,title:"使用泛型的建议",slug:"使用泛型的建议",normalizedTitle:"使用泛型的建议",charIndex:12473},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:12593},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:12602}],headersStr:"为什么需要泛型 泛型类型 泛型类 泛型接口 泛型方法 类型擦除 泛型和继承 类型边界 类型通配符 上界通配符 下界通配符 无界通配符 通配符和向上转型 泛型的约束 泛型最佳实践 泛型命名 使用泛型的建议 小结 参考资料",content:'# 深入理解 Java 泛型\n\n\n# 为什么需要泛型\n\nJDK5 引入了泛型机制。\n\n为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。\n\npublic class NoGenericsDemo {\n    public static void main(String[] args) {\n        List list = new ArrayList<>();\n        list.add("abc");\n        list.add(18);\n        list.add(new double[] {1.0, 2.0});\n        Object obj1 = list.get(0);\n        Object obj2 = list.get(1);\n        Object obj3 = list.get(2);\n        System.out.println("obj1 = [" + obj1 + "]");\n        System.out.println("obj2 = [" + obj2 + "]");\n        System.out.println("obj3 = [" + obj3 + "]");\n\n        int num1 = (int)list.get(0);\n        int num2 = (int)list.get(1);\n        int num3 = (int)list.get(2);\n        System.out.println("num1 = [" + num1 + "]");\n        System.out.println("num2 = [" + num2 + "]");\n        System.out.println("num3 = [" + num3 + "]");\n    }\n}\n// Output:\n// obj1 = [abc]\n// obj2 = [18]\n// obj3 = [[D@47089e5f]\n// Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\n// at io.github.dunwu.javacore.generics.NoGenericsDemo.main(NoGenericsDemo.java:23)\n\n\n> 示例说明：\n> \n> 在上面的示例中，List 容器没有指定存储数据类型，这种情况下，可以向 List 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 Object。\n> \n> 假设，最初我们希望向 List 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 List 当成 Object 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 List 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。\n\n而泛型的出现，解决了类型安全问题。\n\n泛型具有以下优点：\n\n * 编译时的强类型检查\n\n泛型要求在声明时指定实际数据类型，Java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。\n\n * 避免了类型转换\n\n未使用泛型：\n\nList list = new ArrayList();\nlist.add("hello");\nString s = (String) list.get(0);\n\n\n使用泛型：\n\nList<String> list = new ArrayList<String>();\nlist.add("hello");\nString s = list.get(0);   // no cast\n\n\n * 泛型编程可以实现通用算法\n\n通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。\n\n\n# 泛型类型\n\n泛型类型是被参数化的类或接口。\n\n\n# 泛型类\n\n泛型类的语法形式：\n\nclass name<T1, T2, ..., Tn> { /* ... */ }\n\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）T1，T2，...和 Tn。\n\n一般将泛型中的类名称为原型，而将 <> 指定的参数称为类型参数。\n\n * 未应用泛型的类\n\n在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 Object 做类型转换。示例如下：\n\npublic class Info {\n\tprivate Object value;\n\n\tpublic Object getValue() {\n\t\treturn value;\n\t}\n\n\tpublic void setValue(Object value) {\n\t\tthis.value = value;\n\t}\n}\n\n\n * 单类型参数的泛型类\n\npublic class Info<T> {\n    private T value;\n\n    public Info() { }\n\n    public Info(T value) {\n        this.value = value;\n    }\n\n    public T getValue() {\n        return value;\n    }\n\n    public void setValue(T value) {\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return "Info{" + "value=" + value + \'}\';\n    }\n}\n\npublic class GenericsClassDemo01 {\n    public static void main(String[] args) {\n        Info<Integer> info = new Info<>();\n        info.setValue(10);\n        System.out.println(info.getValue());\n\n        Info<String> info2 = new Info<>();\n        info2.setValue("xyz");\n        System.out.println(info2.getValue());\n    }\n}\n// Output:\n// 10\n// xyz\n\n\n在上面的例子中，在初始化一个泛型类时，使用 <> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。\n\n实际上，不使用 <> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：\n\npublic static void main(String[] args) {\n    Info info = new Info();\n    info.setValue(10);\n    System.out.println(info.getValue());\n    info.setValue("abc");\n    System.out.println(info.getValue());\n}\n\n\n> 示例说明：\n> \n> 上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。\n\n * 多个类型参数的泛型类\n\npublic class MyMap<K,V> {\n    private K key;\n    private V value;\n\n    public MyMap(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return "MyMap{" + "key=" + key + ", value=" + value + \'}\';\n    }\n}\n\npublic class GenericsClassDemo02 {\n    public static void main(String[] args) {\n        MyMap<Integer, String> map = new MyMap<>(1, "one");\n        System.out.println(map);\n    }\n}\n// Output:\n// MyMap{key=1, value=one}\n\n\n * 泛型类的类型嵌套\n\npublic class GenericsClassDemo03 {\n    public static void main(String[] args) {\n        Info<String> info = new Info("Hello");\n        MyMap<Integer, Info<String>> map = new MyMap<>(1, info);\n        System.out.println(map);\n    }\n}\n// Output:\n// MyMap{key=1, value=Info{value=Hello}}\n\n\n\n# 泛型接口\n\n接口也可以声明泛型。\n\n泛型接口语法形式：\n\npublic interface Content<T> {\n    T text();\n}\n\n\n泛型接口有两种实现方式：\n\n * 实现接口的子类明确声明泛型类型\n\n\n\npublic class GenericsInterfaceDemo01 implements Content<Integer> {\n    private int text;\n\n    public GenericsInterfaceDemo01(int text) {\n        this.text = text;\n    }\n\n    @Override\n    public Integer text() { return text; }\n\n    public static void main(String[] args) {\n        GenericsInterfaceDemo01 demo = new GenericsInterfaceDemo01(10);\n        System.out.print(demo.text());\n    }\n}\n// Output:\n// 10\n\n\n * 实现接口的子类不明确声明泛型类型\n\npublic class GenericsInterfaceDemo02<T> implements Content<T> {\n    private T text;\n\n    public GenericsInterfaceDemo02(T text) {\n        this.text = text;\n    }\n\n    @Override\n    public T text() { return text; }\n\n    public static void main(String[] args) {\n        GenericsInterfaceDemo02<String> gen = new GenericsInterfaceDemo02<>("ABC");\n        System.out.print(gen.text());\n    }\n}\n// Output:\n// ABC\n\n\n\n# 泛型方法\n\n泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。\n\n泛型方法语法形式如下：\n\npublic <T> T func(T obj) {}\n\n\n是否拥有泛型方法，与其所在的类是否是泛型没有关系。\n\n泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。\n\n使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用。如果将一个返回类型为 T 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 Object 类型的变量。\n\npublic class GenericsMethodDemo01 {\n    public static <T> void printClass(T obj) {\n        System.out.println(obj.getClass().toString());\n    }\n\n    public static void main(String[] args) {\n        printClass("abc");\n        printClass(10);\n    }\n}\n// Output:\n// class java.lang.String\n// class java.lang.Integer\n\n\n泛型方法中也可以使用可变参数列表\n\npublic class GenericVarargsMethodDemo {\n    public static <T> List<T> makeList(T... args) {\n        List<T> result = new ArrayList<T>();\n        Collections.addAll(result, args);\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> ls = makeList("A");\n        System.out.println(ls);\n        ls = makeList("A", "B", "C");\n        System.out.println(ls);\n    }\n}\n// Output:\n// [A]\n// [A, B, C]\n\n\n\n# 类型擦除\n\nJava 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 C++ 的模板机制，Java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。\n\n那么，类型擦除做了什么呢？它做了以下工作：\n\n * 把泛型中的所有类型参数替换为 Object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。\n * 擦除出现的类型声明，即去掉 <> 的内容。比如 T get() 方法声明就变成了 Object get() ；List<String> 就变成了 List。如有必要，插入类型转换以保持类型安全。\n * 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。\n\n让我们来看一个示例：\n\npublic class GenericsErasureTypeDemo {\n    public static void main(String[] args) {\n        List<Object> list1 = new ArrayList<Object>();\n        List<String> list2 = new ArrayList<String>();\n        System.out.println(list1.getClass());\n        System.out.println(list2.getClass());\n    }\n}\n// Output:\n// class java.util.ArrayList\n// class java.util.ArrayList\n\n\n> 示例说明：\n> \n> 上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。\n> \n> 这是因为：使用泛型时，任何具体的类型信息都被擦除了。这意味着：ArrayList<Object> 和 ArrayList<String> 在运行时，JVM 将它们视为同一类型。\n\nJava 泛型的实现方式不太优雅，但这是因为泛型是在 JDK5 时引入的，为了兼容老代码，必须在设计上做一定的折中。\n\n\n# 泛型和继承\n\n泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。\n\n正是由于泛型时基于类型擦除实现的，所以，泛型类型无法向上转型。\n\n> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。\n\n\n\nInteger 继承了 Object；ArrayList 继承了 List；但是 List<Interger> 却并非继承了 List<Object>。\n\n这是因为，泛型类并没有自己独有的 Class 类对象。比如：并不存在 List<Object>.class 或是 List<Interger>.class，Java 编译器会将二者都视为 List.class。\n\nList<Integer> list = new ArrayList<>();\nList<Object> list2 = list; // Erorr\n\n\n\n# 类型边界\n\n有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 Number 或其子类的实例。\n\n要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。\n\n类型边界的语法形式如下：\n\n<T extends XXX>\n\n\n示例：\n\npublic class GenericsExtendsDemo01 {\n    static <T extends Comparable<T>> T max(T x, T y, T z) {\n        T max = x; // 假设x是初始最大值\n        if (y.compareTo(max) > 0) {\n            max = y; //y 更大\n        }\n        if (z.compareTo(max) > 0) {\n            max = z; // 现在 z 更大\n        }\n        return max; // 返回最大对象\n    }\n\n    public static void main(String[] args) {\n        System.out.println(max(3, 4, 5));\n        System.out.println(max(6.6, 8.8, 7.7));\n        System.out.println(max("pear", "apple", "orange"));\n    }\n}\n// Output:\n// 5\n// 8.8\n// pear\n\n\n> 示例说明：\n> \n> 上面的示例声明了一个泛型方法，类型参数 T extends Comparable<T> 表明传入方法中的类型必须实现了 Comparable 接口。\n\n类型边界可以设置多个，语法形式如下：\n\n<T extends B1 & B2 & B3>\n\n\n> 🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。\n\n示例：\n\npublic class GenericsExtendsDemo02 {\n    static class A { /* ... */ }\n    interface B { /* ... */ }\n    interface C { /* ... */ }\n    static class D1 <T extends A & B & C> { /* ... */ }\n    static class D2 <T extends B & A & C> { /* ... */ } // 编译报错\n    static class E extends A implements B, C { /* ... */ }\n\n    public static void main(String[] args) {\n        D1<E> demo1 = new D1<>();\n        System.out.println(demo1.getClass().toString());\n        D1<String> demo2 = new D1<>(); // 编译报错\n    }\n}\n\n\n\n# 类型通配符\n\n类型通配符一般是使用 ? 代替具体的类型参数。例如 List<?> 在逻辑上是 List<String> ，List<Integer> 等所有 List<具体类型实参> 的父类。\n\n\n# 上界通配符\n\n可以使用**上界通配符**来缩小类型参数的类型范围。\n\n它的语法形式为：<? extends Number>\n\npublic class GenericsUpperBoundedWildcardDemo {\n    public static double sumOfList(List<? extends Number> list) {\n        double s = 0.0;\n        for (Number n : list) {\n            s += n.doubleValue();\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        List<Integer> li = Arrays.asList(1, 2, 3);\n        System.out.println("sum = " + sumOfList(li));\n    }\n}\n// Output:\n// sum = 6.0\n\n\n\n# 下界通配符\n\n**下界通配符**将未知类型限制为该类型的特定类型或超类类型。\n\n> 🔔 注意：上界通配符和下界通配符不能同时使用。\n\n它的语法形式为：<? super Number>\n\npublic class GenericsLowerBoundedWildcardDemo {\n    public static void addNumbers(List<? super Integer> list) {\n        for (int i = 1; i <= 5; i++) {\n            list.add(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = new ArrayList<>();\n        addNumbers(list);\n        System.out.println(Arrays.deepToString(list.toArray()));\n    }\n}\n// Output:\n// [1, 2, 3, 4, 5]\n\n\n\n# 无界通配符\n\n无界通配符有两种应用场景：\n\n * 可以使用 Object 类中提供的功能来实现的方法。\n * 使用不依赖于类型参数的泛型类中的方法。\n\n语法形式：<?>\n\npublic class GenericsUnboundedWildcardDemo {\n    public static void printList(List<?> list) {\n        for (Object elem : list) {\n            System.out.print(elem + " ");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> li = Arrays.asList(1, 2, 3);\n        List<String> ls = Arrays.asList("one", "two", "three");\n        printList(li);\n        printList(ls);\n    }\n}\n// Output:\n// 1 2 3\n// one two three\n\n\n\n# 通配符和向上转型\n\n前面，我们提到：泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。\n\npublic class GenericsWildcardDemo {\n    public static void main(String[] args) {\n        List<Integer> intList = new ArrayList<>();\n        List<Number> numList = intList;  // Error\n\n        List<? extends Integer> intList2 = new ArrayList<>();\n        List<? extends Number> numList2 = intList2;  // OK\n    }\n}\n\n\n> 扩展阅读：Oracle 泛型文档\n\n\n# 泛型的约束\n\n * 泛型类型的类型参数不能是值类型\n\nPair<int, char> p = new Pair<>(8, \'a\');  // 编译错误\n\n\n * 不能创建类型参数的实例\n\npublic static <E> void append(List<E> list) {\n    E elem = new E();  // 编译错误\n    list.add(elem);\n}\n\n\n * 不能声明类型为类型参数的静态成员\n\npublic class MobileDevice<T> {\n    private static T os; // error\n\n    // ...\n}\n\n\n * 类型参数不能使用类型转换或 instanceof\n\npublic static <E> void rtti(List<E> list) {\n    if (list instanceof ArrayList<Integer>) {  // 编译错误\n        // ...\n    }\n}\n\n\nList<Integer> li = new ArrayList<>();\nList<Number>  ln = (List<Number>) li;  // 编译错误\n\n\n * 不能创建类型参数的数组\n\nList<Integer>[] arrayOfLists = new List<Integer>[2];  // 编译错误\n\n\n * 不能创建、catch 或 throw 参数化类型对象\n\n// Extends Throwable indirectly\nclass MathException<T> extends Exception { /* ... */ }    // 编译错误\n\n// Extends Throwable directly\nclass QueueFullException<T> extends Throwable { /* ... */ // 编译错误\n\n\npublic static <T extends Exception, J> void execute(List<J> jobs) {\n    try {\n        for (J job : jobs)\n            // ...\n    } catch (T e) {   // compile-time error\n        // ...\n    }\n}\n\n\n * 仅仅是泛型类相同，而类型参数不同的方法不能重载\n\npublic class Example {\n    public void print(Set<String> strSet) { }\n    public void print(Set<Integer> intSet) { } // 编译错误\n}\n\n\n\n# 泛型最佳实践\n\n\n# 泛型命名\n\n泛型一些约定俗成的命名：\n\n * E - Element\n * K - Key\n * N - Number\n * T - Type\n * V - Value\n * S,U,V etc. - 2nd, 3rd, 4th types\n\n\n# 使用泛型的建议\n\n * 消除类型检查告警\n * List 优先于数组\n * 优先考虑使用泛型来提高代码通用性\n * 优先考虑泛型方法来限定泛型的范围\n * 利用有限制通配符来提升 API 的灵活性\n * 优先考虑类型安全的异构容器\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * Oracle 泛型文档\n * Java 泛型详解',normalizedContent:'# 深入理解 java 泛型\n\n\n# 为什么需要泛型\n\njdk5 引入了泛型机制。\n\n为什么需要泛型呢？回答这个问题前，先让我们来看一个示例。\n\npublic class nogenericsdemo {\n    public static void main(string[] args) {\n        list list = new arraylist<>();\n        list.add("abc");\n        list.add(18);\n        list.add(new double[] {1.0, 2.0});\n        object obj1 = list.get(0);\n        object obj2 = list.get(1);\n        object obj3 = list.get(2);\n        system.out.println("obj1 = [" + obj1 + "]");\n        system.out.println("obj2 = [" + obj2 + "]");\n        system.out.println("obj3 = [" + obj3 + "]");\n\n        int num1 = (int)list.get(0);\n        int num2 = (int)list.get(1);\n        int num3 = (int)list.get(2);\n        system.out.println("num1 = [" + num1 + "]");\n        system.out.println("num2 = [" + num2 + "]");\n        system.out.println("num3 = [" + num3 + "]");\n    }\n}\n// output:\n// obj1 = [abc]\n// obj2 = [18]\n// obj3 = [[d@47089e5f]\n// exception in thread "main" java.lang.classcastexception: java.lang.string cannot be cast to java.lang.integer\n// at io.github.dunwu.javacore.generics.nogenericsdemo.main(nogenericsdemo.java:23)\n\n\n> 示例说明：\n> \n> 在上面的示例中，list 容器没有指定存储数据类型，这种情况下，可以向 list 添加任意类型数据，编译器不会做类型检查，而是默默的将所有数据都转为 object。\n> \n> 假设，最初我们希望向 list 存储的是整形数据，假设，某个家伙不小心存入了其他数据类型。当你试图从容器中取整形数据时，由于 list 当成 object 类型来存储，你不得不使用类型强制转换。在运行时，才会发现 list 中数据不存储一致的问题，这就为程序运行带来了很大的风险（无形伤害最为致命）。\n\n而泛型的出现，解决了类型安全问题。\n\n泛型具有以下优点：\n\n * 编译时的强类型检查\n\n泛型要求在声明时指定实际数据类型，java 编译器在编译时会对泛型代码做强类型检查，并在代码违反类型安全时发出告警。早发现，早治理，把隐患扼杀于摇篮，在编译时发现并修复错误所付出的代价远比在运行时小。\n\n * 避免了类型转换\n\n未使用泛型：\n\nlist list = new arraylist();\nlist.add("hello");\nstring s = (string) list.get(0);\n\n\n使用泛型：\n\nlist<string> list = new arraylist<string>();\nlist.add("hello");\nstring s = list.get(0);   // no cast\n\n\n * 泛型编程可以实现通用算法\n\n通过使用泛型，程序员可以实现通用算法，这些算法可以处理不同类型的集合，可以自定义，并且类型安全且易于阅读。\n\n\n# 泛型类型\n\n泛型类型是被参数化的类或接口。\n\n\n# 泛型类\n\n泛型类的语法形式：\n\nclass name<t1, t2, ..., tn> { /* ... */ }\n\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。由尖括号（<>）分隔的类型参数部分跟在类名后面。它指定类型参数（也称为类型变量）t1，t2，...和 tn。\n\n一般将泛型中的类名称为原型，而将 <> 指定的参数称为类型参数。\n\n * 未应用泛型的类\n\n在泛型出现之前，如果一个类想持有一个可以为任意类型的数据，只能使用 object 做类型转换。示例如下：\n\npublic class info {\n\tprivate object value;\n\n\tpublic object getvalue() {\n\t\treturn value;\n\t}\n\n\tpublic void setvalue(object value) {\n\t\tthis.value = value;\n\t}\n}\n\n\n * 单类型参数的泛型类\n\npublic class info<t> {\n    private t value;\n\n    public info() { }\n\n    public info(t value) {\n        this.value = value;\n    }\n\n    public t getvalue() {\n        return value;\n    }\n\n    public void setvalue(t value) {\n        this.value = value;\n    }\n\n    @override\n    public string tostring() {\n        return "info{" + "value=" + value + \'}\';\n    }\n}\n\npublic class genericsclassdemo01 {\n    public static void main(string[] args) {\n        info<integer> info = new info<>();\n        info.setvalue(10);\n        system.out.println(info.getvalue());\n\n        info<string> info2 = new info<>();\n        info2.setvalue("xyz");\n        system.out.println(info2.getvalue());\n    }\n}\n// output:\n// 10\n// xyz\n\n\n在上面的例子中，在初始化一个泛型类时，使用 <> 指定了内部具体类型，在编译时就会根据这个类型做强类型检查。\n\n实际上，不使用 <> 指定内部具体类型，语法上也是支持的（不推荐这么做），如下所示：\n\npublic static void main(string[] args) {\n    info info = new info();\n    info.setvalue(10);\n    system.out.println(info.getvalue());\n    info.setvalue("abc");\n    system.out.println(info.getvalue());\n}\n\n\n> 示例说明：\n> \n> 上面的例子，不会产生编译错误，也能正常运行。但这样的调用就失去泛型类型的优势。\n\n * 多个类型参数的泛型类\n\npublic class mymap<k,v> {\n    private k key;\n    private v value;\n\n    public mymap(k key, v value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @override\n    public string tostring() {\n        return "mymap{" + "key=" + key + ", value=" + value + \'}\';\n    }\n}\n\npublic class genericsclassdemo02 {\n    public static void main(string[] args) {\n        mymap<integer, string> map = new mymap<>(1, "one");\n        system.out.println(map);\n    }\n}\n// output:\n// mymap{key=1, value=one}\n\n\n * 泛型类的类型嵌套\n\npublic class genericsclassdemo03 {\n    public static void main(string[] args) {\n        info<string> info = new info("hello");\n        mymap<integer, info<string>> map = new mymap<>(1, info);\n        system.out.println(map);\n    }\n}\n// output:\n// mymap{key=1, value=info{value=hello}}\n\n\n\n# 泛型接口\n\n接口也可以声明泛型。\n\n泛型接口语法形式：\n\npublic interface content<t> {\n    t text();\n}\n\n\n泛型接口有两种实现方式：\n\n * 实现接口的子类明确声明泛型类型\n\n\n\npublic class genericsinterfacedemo01 implements content<integer> {\n    private int text;\n\n    public genericsinterfacedemo01(int text) {\n        this.text = text;\n    }\n\n    @override\n    public integer text() { return text; }\n\n    public static void main(string[] args) {\n        genericsinterfacedemo01 demo = new genericsinterfacedemo01(10);\n        system.out.print(demo.text());\n    }\n}\n// output:\n// 10\n\n\n * 实现接口的子类不明确声明泛型类型\n\npublic class genericsinterfacedemo02<t> implements content<t> {\n    private t text;\n\n    public genericsinterfacedemo02(t text) {\n        this.text = text;\n    }\n\n    @override\n    public t text() { return text; }\n\n    public static void main(string[] args) {\n        genericsinterfacedemo02<string> gen = new genericsinterfacedemo02<>("abc");\n        system.out.print(gen.text());\n    }\n}\n// output:\n// abc\n\n\n\n# 泛型方法\n\n泛型方法是引入其自己的类型参数的方法。泛型方法可以是普通方法、静态方法以及构造方法。\n\n泛型方法语法形式如下：\n\npublic <t> t func(t obj) {}\n\n\n是否拥有泛型方法，与其所在的类是否是泛型没有关系。\n\n泛型方法的语法包括一个类型参数列表，在尖括号内，它出现在方法的返回类型之前。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际类型参数的占位符。\n\n使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。这称为类型参数推断（type argument inference）。类型推断只对赋值操作有效，其他时候并不起作用。如果将一个返回类型为 t 的泛型方法调用的结果作为参数，传递给另一个方法，这时编译器并不会执行推断。编译器会认为：调用泛型方法后，其返回值被赋给一个 object 类型的变量。\n\npublic class genericsmethoddemo01 {\n    public static <t> void printclass(t obj) {\n        system.out.println(obj.getclass().tostring());\n    }\n\n    public static void main(string[] args) {\n        printclass("abc");\n        printclass(10);\n    }\n}\n// output:\n// class java.lang.string\n// class java.lang.integer\n\n\n泛型方法中也可以使用可变参数列表\n\npublic class genericvarargsmethoddemo {\n    public static <t> list<t> makelist(t... args) {\n        list<t> result = new arraylist<t>();\n        collections.addall(result, args);\n        return result;\n    }\n\n    public static void main(string[] args) {\n        list<string> ls = makelist("a");\n        system.out.println(ls);\n        ls = makelist("a", "b", "c");\n        system.out.println(ls);\n    }\n}\n// output:\n// [a]\n// [a, b, c]\n\n\n\n# 类型擦除\n\njava 语言引入泛型是为了在编译时提供更严格的类型检查，并支持泛型编程。不同于 c++ 的模板机制，java 泛型是使用类型擦除来实现的，使用泛型时，任何具体的类型信息都被擦除了。\n\n那么，类型擦除做了什么呢？它做了以下工作：\n\n * 把泛型中的所有类型参数替换为 object，如果指定类型边界，则使用类型边界来替换。因此，生成的字节码仅包含普通的类，接口和方法。\n * 擦除出现的类型声明，即去掉 <> 的内容。比如 t get() 方法声明就变成了 object get() ；list<string> 就变成了 list。如有必要，插入类型转换以保持类型安全。\n * 生成桥接方法以保留扩展泛型类型中的多态性。类型擦除确保不为参数化类型创建新类；因此，泛型不会产生运行时开销。\n\n让我们来看一个示例：\n\npublic class genericserasuretypedemo {\n    public static void main(string[] args) {\n        list<object> list1 = new arraylist<object>();\n        list<string> list2 = new arraylist<string>();\n        system.out.println(list1.getclass());\n        system.out.println(list2.getclass());\n    }\n}\n// output:\n// class java.util.arraylist\n// class java.util.arraylist\n\n\n> 示例说明：\n> \n> 上面的例子中，虽然指定了不同的类型参数，但是 list1 和 list2 的类信息却是一样的。\n> \n> 这是因为：使用泛型时，任何具体的类型信息都被擦除了。这意味着：arraylist<object> 和 arraylist<string> 在运行时，jvm 将它们视为同一类型。\n\njava 泛型的实现方式不太优雅，但这是因为泛型是在 jdk5 时引入的，为了兼容老代码，必须在设计上做一定的折中。\n\n\n# 泛型和继承\n\n泛型不能用于显式地引用运行时类型的操作之中，例如：转型、instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了。当你在编写泛型代码时，必须时刻提醒自己，你只是看起来好像拥有有关参数的类型信息而已。\n\n正是由于泛型时基于类型擦除实现的，所以，泛型类型无法向上转型。\n\n> 向上转型是指用子类实例去初始化父类，这是面向对象中多态的重要表现。\n\n\n\ninteger 继承了 object；arraylist 继承了 list；但是 list<interger> 却并非继承了 list<object>。\n\n这是因为，泛型类并没有自己独有的 class 类对象。比如：并不存在 list<object>.class 或是 list<interger>.class，java 编译器会将二者都视为 list.class。\n\nlist<integer> list = new arraylist<>();\nlist<object> list2 = list; // erorr\n\n\n\n# 类型边界\n\n有时您可能希望限制可在参数化类型中用作类型参数的类型。类型边界可以对泛型的类型参数设置限制条件。例如，对数字进行操作的方法可能只想接受 number 或其子类的实例。\n\n要声明有界类型参数，请列出类型参数的名称，然后是 extends 关键字，后跟其限制类或接口。\n\n类型边界的语法形式如下：\n\n<t extends xxx>\n\n\n示例：\n\npublic class genericsextendsdemo01 {\n    static <t extends comparable<t>> t max(t x, t y, t z) {\n        t max = x; // 假设x是初始最大值\n        if (y.compareto(max) > 0) {\n            max = y; //y 更大\n        }\n        if (z.compareto(max) > 0) {\n            max = z; // 现在 z 更大\n        }\n        return max; // 返回最大对象\n    }\n\n    public static void main(string[] args) {\n        system.out.println(max(3, 4, 5));\n        system.out.println(max(6.6, 8.8, 7.7));\n        system.out.println(max("pear", "apple", "orange"));\n    }\n}\n// output:\n// 5\n// 8.8\n// pear\n\n\n> 示例说明：\n> \n> 上面的示例声明了一个泛型方法，类型参数 t extends comparable<t> 表明传入方法中的类型必须实现了 comparable 接口。\n\n类型边界可以设置多个，语法形式如下：\n\n<t extends b1 & b2 & b3>\n\n\n> 🔔 注意：extends 关键字后面的第一个类型参数可以是类或接口，其他类型参数只能是接口。\n\n示例：\n\npublic class genericsextendsdemo02 {\n    static class a { /* ... */ }\n    interface b { /* ... */ }\n    interface c { /* ... */ }\n    static class d1 <t extends a & b & c> { /* ... */ }\n    static class d2 <t extends b & a & c> { /* ... */ } // 编译报错\n    static class e extends a implements b, c { /* ... */ }\n\n    public static void main(string[] args) {\n        d1<e> demo1 = new d1<>();\n        system.out.println(demo1.getclass().tostring());\n        d1<string> demo2 = new d1<>(); // 编译报错\n    }\n}\n\n\n\n# 类型通配符\n\n类型通配符一般是使用 ? 代替具体的类型参数。例如 list<?> 在逻辑上是 list<string> ，list<integer> 等所有 list<具体类型实参> 的父类。\n\n\n# 上界通配符\n\n可以使用**上界通配符**来缩小类型参数的类型范围。\n\n它的语法形式为：<? extends number>\n\npublic class genericsupperboundedwildcarddemo {\n    public static double sumoflist(list<? extends number> list) {\n        double s = 0.0;\n        for (number n : list) {\n            s += n.doublevalue();\n        }\n        return s;\n    }\n\n    public static void main(string[] args) {\n        list<integer> li = arrays.aslist(1, 2, 3);\n        system.out.println("sum = " + sumoflist(li));\n    }\n}\n// output:\n// sum = 6.0\n\n\n\n# 下界通配符\n\n**下界通配符**将未知类型限制为该类型的特定类型或超类类型。\n\n> 🔔 注意：上界通配符和下界通配符不能同时使用。\n\n它的语法形式为：<? super number>\n\npublic class genericslowerboundedwildcarddemo {\n    public static void addnumbers(list<? super integer> list) {\n        for (int i = 1; i <= 5; i++) {\n            list.add(i);\n        }\n    }\n\n    public static void main(string[] args) {\n        list<integer> list = new arraylist<>();\n        addnumbers(list);\n        system.out.println(arrays.deeptostring(list.toarray()));\n    }\n}\n// output:\n// [1, 2, 3, 4, 5]\n\n\n\n# 无界通配符\n\n无界通配符有两种应用场景：\n\n * 可以使用 object 类中提供的功能来实现的方法。\n * 使用不依赖于类型参数的泛型类中的方法。\n\n语法形式：<?>\n\npublic class genericsunboundedwildcarddemo {\n    public static void printlist(list<?> list) {\n        for (object elem : list) {\n            system.out.print(elem + " ");\n        }\n        system.out.println();\n    }\n\n    public static void main(string[] args) {\n        list<integer> li = arrays.aslist(1, 2, 3);\n        list<string> ls = arrays.aslist("one", "two", "three");\n        printlist(li);\n        printlist(ls);\n    }\n}\n// output:\n// 1 2 3\n// one two three\n\n\n\n# 通配符和向上转型\n\n前面，我们提到：泛型不能向上转型。但是，我们可以通过使用通配符来向上转型。\n\npublic class genericswildcarddemo {\n    public static void main(string[] args) {\n        list<integer> intlist = new arraylist<>();\n        list<number> numlist = intlist;  // error\n\n        list<? extends integer> intlist2 = new arraylist<>();\n        list<? extends number> numlist2 = intlist2;  // ok\n    }\n}\n\n\n> 扩展阅读：oracle 泛型文档\n\n\n# 泛型的约束\n\n * 泛型类型的类型参数不能是值类型\n\npair<int, char> p = new pair<>(8, \'a\');  // 编译错误\n\n\n * 不能创建类型参数的实例\n\npublic static <e> void append(list<e> list) {\n    e elem = new e();  // 编译错误\n    list.add(elem);\n}\n\n\n * 不能声明类型为类型参数的静态成员\n\npublic class mobiledevice<t> {\n    private static t os; // error\n\n    // ...\n}\n\n\n * 类型参数不能使用类型转换或 instanceof\n\npublic static <e> void rtti(list<e> list) {\n    if (list instanceof arraylist<integer>) {  // 编译错误\n        // ...\n    }\n}\n\n\nlist<integer> li = new arraylist<>();\nlist<number>  ln = (list<number>) li;  // 编译错误\n\n\n * 不能创建类型参数的数组\n\nlist<integer>[] arrayoflists = new list<integer>[2];  // 编译错误\n\n\n * 不能创建、catch 或 throw 参数化类型对象\n\n// extends throwable indirectly\nclass mathexception<t> extends exception { /* ... */ }    // 编译错误\n\n// extends throwable directly\nclass queuefullexception<t> extends throwable { /* ... */ // 编译错误\n\n\npublic static <t extends exception, j> void execute(list<j> jobs) {\n    try {\n        for (j job : jobs)\n            // ...\n    } catch (t e) {   // compile-time error\n        // ...\n    }\n}\n\n\n * 仅仅是泛型类相同，而类型参数不同的方法不能重载\n\npublic class example {\n    public void print(set<string> strset) { }\n    public void print(set<integer> intset) { } // 编译错误\n}\n\n\n\n# 泛型最佳实践\n\n\n# 泛型命名\n\n泛型一些约定俗成的命名：\n\n * e - element\n * k - key\n * n - number\n * t - type\n * v - value\n * s,u,v etc. - 2nd, 3rd, 4th types\n\n\n# 使用泛型的建议\n\n * 消除类型检查告警\n * list 优先于数组\n * 优先考虑使用泛型来提高代码通用性\n * 优先考虑泛型方法来限定泛型的范围\n * 利用有限制通配符来提升 api 的灵活性\n * 优先考虑类型安全的异构容器\n\n\n# 小结\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * oracle 泛型文档\n * java 泛型详解',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 反射和动态代理",frontmatter:{title:"深入理解 Java 反射和动态代理",date:"2020-06-04T13:51:01.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","反射","动态代理"],permalink:"/pages/0d066a/",abbrlink:"38019de5"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.Java%E5%8F%8D%E5%B0%84.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/10.Java反射.md",key:"v-76e62b1a",path:"/pages/0d066a/",headers:[{level:2,title:"反射简介",slug:"反射简介",normalizedTitle:"反射简介",charIndex:24},{level:3,title:"什么是反射",slug:"什么是反射",normalizedTitle:"什么是反射",charIndex:35},{level:3,title:"反射的应用场景",slug:"反射的应用场景",normalizedTitle:"反射的应用场景",charIndex:157},{level:3,title:"反射的缺点",slug:"反射的缺点",normalizedTitle:"反射的缺点",charIndex:524},{level:2,title:"反射机制",slug:"反射机制",normalizedTitle:"反射机制",charIndex:118},{level:3,title:"类加载过程",slug:"类加载过程",normalizedTitle:"类加载过程",charIndex:800},{level:3,title:"Class 对象",slug:"class-对象",normalizedTitle:"class 对象",charIndex:1044},{level:3,title:"方法的反射调用",slug:"方法的反射调用",normalizedTitle:"方法的反射调用",charIndex:1555},{level:3,title:"反射调用的开销",slug:"反射调用的开销",normalizedTitle:"反射调用的开销",charIndex:6818},{level:2,title:"使用反射",slug:"使用反射",normalizedTitle:"使用反射",charIndex:1126},{level:3,title:"java.lang.reflect 包",slug:"java-lang-reflect-包",normalizedTitle:"java.lang.reflect 包",charIndex:7484},{level:3,title:"获取 Class 对象",slug:"获取-class-对象",normalizedTitle:"获取 class 对象",charIndex:7884},{level:3,title:"判断是否为某个类的实例",slug:"判断是否为某个类的实例",normalizedTitle:"判断是否为某个类的实例",charIndex:10050},{level:3,title:"创建实例",slug:"创建实例",normalizedTitle:"创建实例",charIndex:10556},{level:3,title:"创建数组实例",slug:"创建数组实例",normalizedTitle:"创建数组实例",charIndex:11340},{level:3,title:"Field",slug:"field",normalizedTitle:"field",charIndex:7654},{level:3,title:"Method",slug:"method",normalizedTitle:"method",charIndex:1576},{level:3,title:"Constructor",slug:"constructor",normalizedTitle:"constructor",charIndex:7723},{level:3,title:"绕开访问限制",slug:"绕开访问限制",normalizedTitle:"绕开访问限制",charIndex:15997},{level:2,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:15},{level:3,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:16299},{level:3,title:"JDK 动态代理",slug:"jdk-动态代理",normalizedTitle:"jdk 动态代理",charIndex:17108},{level:4,title:"InvocationHandler 接口",slug:"invocationhandler-接口",normalizedTitle:"invocationhandler 接口",charIndex:17796},{level:4,title:"Proxy 类",slug:"proxy-类",normalizedTitle:"proxy 类",charIndex:7851},{level:4,title:"JDK 动态代理实例",slug:"jdk-动态代理实例",normalizedTitle:"jdk 动态代理实例",charIndex:18952},{level:4,title:"JDK 动态代理小结",slug:"jdk-动态代理小结",normalizedTitle:"jdk 动态代理小结",charIndex:22967},{level:3,title:"CGLIB 动态代理",slug:"cglib-动态代理",normalizedTitle:"cglib 动态代理",charIndex:23156},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:23531}],headersStr:"反射简介 什么是反射 反射的应用场景 反射的缺点 反射机制 类加载过程 Class 对象 方法的反射调用 反射调用的开销 使用反射 java.lang.reflect 包 获取 Class 对象 判断是否为某个类的实例 创建实例 创建数组实例 Field Method Constructor 绕开访问限制 动态代理 静态代理 JDK 动态代理 InvocationHandler 接口 Proxy 类 JDK 动态代理实例 JDK 动态代理小结 CGLIB 动态代理 参考资料",content:'# 深入理解 Java 反射和动态代理\n\n\n# 反射简介\n\n\n\n\n# 什么是反射\n\n反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n通过反射机制，可以在运行时访问 Java 对象的属性，方法，构造方法等。\n\n\n# 反射的应用场景\n\n反射的主要应用场景有：\n\n * 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。\n * 动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。\n * 注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。\n * 可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。\n\n\n# 反射的缺点\n\n * 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。\n * 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n * 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。\n\n\n# 反射机制\n\n\n# 类加载过程\n\n\n\n类加载的完整过程如下：\n\n 1. 在编译时，Java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 JVM 能够识别的机器码。\n 2. JVM 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.Class 对象。\n 3. 加载结束后，JVM 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。\n\n\n# Class 对象\n\n要想使用反射，首先需要获得待操作的类所对应的 Class 对象。Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构。所以，java.lang.Class 可以视为所有反射 API 的入口点。\n\n反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象。\n\n举例来说，假如定义了以下代码：\n\nUser user = new User();\n\n\n步骤说明：\n\n 1. JVM 加载方法的时候，遇到 new User()，JVM 会根据 User 的全限定名去加载 User.class 。\n 2. JVM 会去本地磁盘查找 User.class 文件并加载 JVM 内存中。\n 3. JVM 通过调用类加载器自动创建这个类对应的 Class 对象，并且存储在 JVM 的方法区。注意：一个类有且只有一个 Class 对象。\n\n\n# 方法的反射调用\n\n方法的反射调用，也就是 Method.invoke 方法。\n\nMethod.invoke 方法源码：\n\npublic final class Method extends Executable {\n  ...\n  public Object invoke(Object obj, Object... args) throws ... {\n    ... // 权限检查\n    MethodAccessor ma = methodAccessor;\n    if (ma == null) {\n      ma = acquireMethodAccessor();\n    }\n    return ma.invoke(obj, args);\n  }\n}\n\n\nMethod.invoke 方法实际上委派给 MethodAccessor 接口来处理。它有两个已有的具体实现：\n\n * NativeMethodAccessorImpl：本地方法来实现反射调用\n * DelegatingMethodAccessorImpl：委派模式来实现反射调用\n\n每个 Method 实例的第一次反射调用都会生成一个委派实现（DelegatingMethodAccessorImpl），它所委派的具体实现便是一个本地实现（NativeMethodAccessorImpl）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 Method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。\n\n【示例】通过抛出异常方式 打印 Method.invoke 调用轨迹\n\npublic class MethodDemo01 {\n\n    public static void target(int i) {\n        new Exception("#" + i).printStackTrace();\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> clazz = Class.forName("io.github.dunwu.javacore.reflect.MethodDemo01");\n        Method method = clazz.getMethod("target", int.class);\n        method.invoke(null, 0);\n    }\n\n}\n// Output:\n// java.lang.Exception: #0\n//     at io.github.dunwu.javacore.reflect.MethodDemo01.target(MethodDemo01.java:12)\n//     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n//     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\n\n先调用 DelegatingMethodAccessorImpl；然后调用 NativeMethodAccessorImpl，最后调用实际方法。\n\n为什么反射调用DelegatingMethodAccessorImpl 作为中间层，而不是直接交给本地实现？\n\n其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。\n\n考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。\n\n【示例】执行 java -verbose:class MethodDemo02 启动\n\npublic class MethodDemo02 {\n\n    public static void target(int i) {\n        new Exception("#" + i).printStackTrace();\n    }\n\n    public static void main(String[] args) throws Exception {\n        Class<?> klass = Class.forName("io.github.dunwu.javacore.reflect.MethodDemo02");\n        Method method = klass.getMethod("target", int.class);\n        for (int i = 0; i < 20; i++) {\n            method.invoke(null, i);\n        }\n    }\n\n}\n\n\n输出内容：\n\n// ...省略\njava.lang.Exception: #14\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n[Loaded sun.reflect.ClassFileConstants from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.AccessorGenerator from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.MethodAccessorGenerator from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVectorFactory from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVector from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ByteVectorImpl from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassFileAssembler from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.UTF8 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.Label from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.Label$PatchInfo from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded java.util.ArrayList$Itr from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.MethodAccessorGenerator$1 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassDefiner from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.ClassDefiner$1 from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]\njava.lang.Exception: #15\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n[Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\\Tools\\Java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\njava.lang.Exception: #16\n        at io.github.dunwu.javacore.reflect.MethodDemo02.target(MethodDemo02.java:13)\n        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n        at java.lang.reflect.Method.invoke(Method.java:498)\n        at io.github.dunwu.javacore.reflect.MethodDemo02.main(MethodDemo02.java:20)\n// ...省略\n\n\n可以看到，从第 16 次开始后，都是使用 DelegatingMethodAccessorImpl ，不再使用本地实现 NativeMethodAccessorImpl。\n\n\n# 反射调用的开销\n\n方法的反射调用会带来不少性能开销，原因主要有三个：\n\n * 变长参数方法导致的 Object 数组\n * 基本类型的自动装箱、拆箱\n * 还有最重要的方法内联\n\nClass.forName 会调用本地方法，Class.getMethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。\n\n> 注意，以 getMethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 Method 数组的 getMethods 或者 getDeclaredMethods 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 Class.forName 和 Class.getMethod 的结果。\n\n下面只关注反射调用本身的性能开销。\n\n第一，由于 Method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 Object 数组（感兴趣的同学私下可以用 javap 查看）。Java 编译器会在方法调用处生成一个长度为传入参数数量的 Object 数组，并将传入参数一一存储进该数组中。\n\n第二，由于 Object 数组不能存储基本类型，Java 编译器会对传入的基本类型参数进行自动装箱。\n\n这两个操作除了带来性能开销外，还可能占用堆内存，使得 GC 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -XX:+PrintGC 试试。）那么，如何消除这部分开销呢？\n\n\n# 使用反射\n\n\n# java.lang.reflect 包\n\nJava 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。\n\njava.lang.reflect 包的核心接口和类如下：\n\n * Member 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。\n * Field 类：提供一个类的域的信息以及访问类的域的接口。\n * Method 类：提供一个类的方法的信息以及访问类的方法的接口。\n * Constructor 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。\n * Array 类：该类提供动态地生成和访问 JAVA 数组的方法。\n * Modifier 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。\n * Proxy 类：提供动态地生成代理类和类实例的静态方法。\n\n\n# 获取 Class 对象\n\n获取 Class 对象的三种方法：\n\n（1）Class.forName 静态方法\n\n【示例】使用 Class.forName 静态方法获取 Class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\npublic class ReflectClassDemo01 {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class c1 = Class.forName("io.github.dunwu.javacore.reflect.ReflectClassDemo01");\n        System.out.println(c1.getCanonicalName());\n\n        Class c2 = Class.forName("[D");\n        System.out.println(c2.getCanonicalName());\n\n        Class c3 = Class.forName("[[Ljava.lang.String;");\n        System.out.println(c3.getCanonicalName());\n    }\n}\n//Output:\n//io.github.dunwu.javacore.reflect.ReflectClassDemo01\n//double[]\n//java.lang.String[][]\n\n\n使用类的完全限定名来反射对象的类。常见的应用场景为：在 JDBC 开发中常用此方法加载数据库驱动。\n\n（2）类名 + .class\n\n【示例】直接用类名 + .class 获取 Class 对象\n\npublic class ReflectClassDemo02 {\n    public static void main(String[] args) {\n        boolean b;\n        // Class c = b.getClass(); // 编译错误\n        Class c1 = boolean.class;\n        System.out.println(c1.getCanonicalName());\n\n        Class c2 = java.io.PrintStream.class;\n        System.out.println(c2.getCanonicalName());\n\n        Class c3 = int[][][].class;\n        System.out.println(c3.getCanonicalName());\n    }\n}\n//Output:\n//boolean\n//java.io.PrintStream\n//int[][][]\n\n\n（3）Object 的 getClass 方法\n\nObject 类中有 getClass 方法，因为所有类都继承 Object 类。从而调用 Object 类来获取 Class 对象。\n\n【示例】Object 的 getClass 方法获取 Class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class ReflectClassDemo03 {\n    enum E {A, B}\n\n    public static void main(String[] args) {\n        Class c = "foo".getClass();\n        System.out.println(c.getCanonicalName());\n\n        Class c2 = ReflectClassDemo03.E.A.getClass();\n        System.out.println(c2.getCanonicalName());\n\n        byte[] bytes = new byte[1024];\n        Class c3 = bytes.getClass();\n        System.out.println(c3.getCanonicalName());\n\n        Set<String> set = new HashSet<>();\n        Class c4 = set.getClass();\n        System.out.println(c4.getCanonicalName());\n    }\n}\n//Output:\n//java.lang.String\n//io.github.dunwu.javacore.reflect.ReflectClassDemo.E\n//byte[]\n//java.util.HashSet\n\n\n\n# 判断是否为某个类的实例\n\n判断是否为某个类的实例有两种方式：\n\n 1. 用 instanceof 关键字\n 2. 用 Class 对象的 isInstance 方法（它是一个 Native 方法）\n\n【示例】\n\npublic class InstanceofDemo {\n    public static void main(String[] args) {\n        ArrayList arrayList = new ArrayList();\n        if (arrayList instanceof List) {\n            System.out.println("ArrayList is List");\n        }\n        if (List.class.isInstance(arrayList)) {\n            System.out.println("ArrayList is List");\n        }\n    }\n}\n//Output:\n//ArrayList is List\n//ArrayList is List\n\n\n\n# 创建实例\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 Class 对象的 newInstance 方法。\n * 用 Constructor 对象的 newInstance 方法。\n\n【示例】\n\npublic class NewInstanceDemo {\n    public static void main(String[] args)\n        throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {\n        Class<?> c1 = StringBuilder.class;\n        StringBuilder sb = (StringBuilder) c1.newInstance();\n        sb.append("aaa");\n        System.out.println(sb.toString());\n\n        //获取String所对应的Class对象\n        Class<?> c2 = String.class;\n        //获取String类带一个String参数的构造器\n        Constructor constructor = c2.getConstructor(String.class);\n        //根据构造器创建实例\n        String str2 = (String) constructor.newInstance("bbb");\n        System.out.println(str2);\n    }\n}\n//Output:\n//aaa\n//bbb\n\n\n\n# 创建数组实例\n\n数组在 Java 里是比较特殊的一种类型，它可以赋值给一个对象引用。Java 中，通过 Array.newInstance 创建数组的实例。\n\n【示例】利用反射创建数组\n\npublic class ReflectArrayDemo {\n    public static void main(String[] args) throws ClassNotFoundException {\n        Class<?> cls = Class.forName("java.lang.String");\n        Object array = Array.newInstance(cls, 25);\n        //往数组里添加内容\n        Array.set(array, 0, "Scala");\n        Array.set(array, 1, "Java");\n        Array.set(array, 2, "Groovy");\n        Array.set(array, 3, "Scala");\n        Array.set(array, 4, "Clojure");\n        //获取某一项的内容\n        System.out.println(Array.get(array, 3));\n    }\n}\n//Output:\n//Scala\n\n\n其中的 Array 类为 java.lang.reflect.Array 类。我们Array.newInstance 的原型是：\n\npublic static Object newInstance(Class<?> componentType, int length)\n    throws NegativeArraySizeException {\n    return newArray(componentType, length);\n}\n\n\n\n# Field\n\nClass 对象提供以下方法获取对象的成员（Field）：\n\n * getFiled - 根据名称获取公有的（public）类成员。\n * getDeclaredField - 根据名称获取已声明的类成员。但不能得到其父类的类成员。\n * getFields - 获取所有公有的（public）类成员。\n * getDeclaredFields - 获取所有已声明的类成员。\n\n示例如下：\n\npublic class ReflectFieldDemo {\n    class FieldSpy<T> {\n        public boolean[][] b = { {false, false}, {true, true} };\n        public String name = "Alice";\n        public List<Integer> list;\n        public T val;\n    }\n\n    public static void main(String[] args) throws NoSuchFieldException {\n        Field f1 = FieldSpy.class.getField("b");\n        System.out.format("Type: %s%n", f1.getType());\n\n        Field f2 = FieldSpy.class.getField("name");\n        System.out.format("Type: %s%n", f2.getType());\n\n        Field f3 = FieldSpy.class.getField("list");\n        System.out.format("Type: %s%n", f3.getType());\n\n        Field f4 = FieldSpy.class.getField("val");\n        System.out.format("Type: %s%n", f4.getType());\n    }\n}\n//Output:\n//Type: class [[Z\n//Type: class java.lang.String\n//Type: interface java.util.List\n//Type: class java.lang.Object\n\n\n\n# Method\n\nClass 对象提供以下方法获取对象的方法（Method）：\n\n * getMethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。\n * getDeclaredMethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 Class 的对象。\n * getMethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。\n * getDeclaredMethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。\n\n获取一个 Method 对象后，可以用 invoke 方法来调用这个方法。\n\ninvoke 方法的原型为:\n\npublic Object invoke(Object obj, Object... args)\n        throws IllegalAccessException, IllegalArgumentException,\n           InvocationTargetException\n\n\n【示例】\n\npublic class ReflectMethodDemo {\n    public static void main(String[] args)\n        throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n\n        // 返回所有方法\n        Method[] methods1 = System.class.getDeclaredMethods();\n        System.out.println("System getDeclaredMethods 清单（数量 = " + methods1.length + "）：");\n        for (Method m : methods1) {\n            System.out.println(m);\n        }\n\n        // 返回所有 public 方法\n        Method[] methods2 = System.class.getMethods();\n        System.out.println("System getMethods 清单（数量 = " + methods2.length + "）：");\n        for (Method m : methods2) {\n            System.out.println(m);\n        }\n\n        // 利用 Method 的 invoke 方法调用 System.currentTimeMillis()\n        Method method = System.class.getMethod("currentTimeMillis");\n        System.out.println(method);\n        System.out.println(method.invoke(null));\n    }\n}\n\n\n\n# Constructor\n\nClass 对象提供以下方法获取对象的构造方法（Constructor）：\n\n * getConstructor - 返回类的特定 public 构造方法。参数为方法参数对应 Class 的对象。\n * getDeclaredConstructor - 返回类的特定构造方法。参数为方法参数对应 Class 的对象。\n * getConstructors - 返回类的所有 public 构造方法。\n * getDeclaredConstructors - 返回类的所有构造方法。\n\n获取一个 Constructor 对象后，可以用 newInstance 方法来创建类实例。\n\n【示例】\n\npublic class ReflectMethodConstructorDemo {\n    public static void main(String[] args)\n        throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n        Constructor<?>[] constructors1 = String.class.getDeclaredConstructors();\n        System.out.println("String getDeclaredConstructors 清单（数量 = " + constructors1.length + "）：");\n        for (Constructor c : constructors1) {\n            System.out.println(c);\n        }\n\n        Constructor<?>[] constructors2 = String.class.getConstructors();\n        System.out.println("String getConstructors 清单（数量 = " + constructors2.length + "）：");\n        for (Constructor c : constructors2) {\n            System.out.println(c);\n        }\n\n        System.out.println("====================");\n        Constructor constructor = String.class.getConstructor(String.class);\n        System.out.println(constructor);\n        String str = (String) constructor.newInstance("bbb");\n        System.out.println(str);\n    }\n}\n\n\n\n# 绕开访问限制\n\n有时候，我们需要通过反射访问私有成员、方法。可以使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。\n\n\n# 动态代理\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。\n\n实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。\n\n\n\n\n# 静态代理\n\n> 静态代理其实就是指设计模式中的代理模式。\n> \n> 代理模式为其他对象提供一种代理以控制对这个对象的访问。\n\n\n\nSubject 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。\n\nabstract class Subject {\n    public abstract void Request();\n}\n\n\nRealSubject 定义 Proxy 所代表的真实实体。\n\nclass RealSubject extends Subject {\n    @Override\n    public void Request() {\n        System.out.println("真实的请求");\n    }\n}\n\n\nProxy 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass Proxy extends Subject {\n    private RealSubject real;\n\n    @Override\n    public void Request() {\n        if (null == real) {\n            real = new RealSubject();\n        }\n        real.Request();\n    }\n}\n\n\n> 说明：\n> \n> 静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。\n\n\n# JDK 动态代理\n\n为了解决静态代理的问题，就有了创建动态代理的想法：\n\n在运行状态中，需要代理的地方，根据 Subject 和 RealSubject，动态地创建一个 Proxy，用完之后，就会销毁，这样就可以避免了 Proxy 角色的 class 在系统中冗杂的问题了。\n\n\n\nJava 动态代理基于经典代理模式，引入了一个 InvocationHandler，InvocationHandler 负责统一管理所有的方法调用。\n\n动态代理步骤：\n\n 1. 获取 RealSubject 上的所有接口列表；\n 2. 确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；\n 3. 根据需要实现的接口信息，在代码中动态创建 该 Proxy 类的字节码；\n 4. 将对应的字节码转换为对应的 class 对象；\n 5. 创建 InvocationHandler 实例 handler，用来处理 Proxy 所有方法调用；\n 6. Proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。\n\n从上面可以看出，JDK 动态代理的实现是基于实现接口的方式，使得 Proxy 和 RealSubject 具有相同的功能。\n\n但其实还有一种思路：通过继承。即：让 Proxy 继承 RealSubject，这样二者同样具有相同的功能，Proxy 还可以通过重写 RealSubject 中的方法，来实现多态。CGLIB 就是基于这种思路设计的。\n\n在 Java 的动态代理机制中，有两个重要的类（接口），一个是 InvocationHandler 接口、另一个则是 Proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。\n\n# InvocationHandler 接口\n\nInvocationHandler 接口定义：\n\npublic interface InvocationHandler {\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n}\n\n\n每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个 Handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。\n\n我们来看看 InvocationHandler 这个接口的唯一一个方法 invoke 方法：\n\nObject invoke(Object proxy, Method method, Object[] args) throws Throwable\n\n\n参数说明：\n\n * proxy - 代理的真实对象。\n * method - 所要调用真实对象的某个方法的 Method 对象\n * args - 所要调用真实对象某个方法时接受的参数\n\n如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。\n\n# Proxy 类\n\nProxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：\n\npublic static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,  InvocationHandler h)  throws IllegalArgumentException\n\n\n这个方法的作用就是得到一个动态的代理对象。\n\n参数说明：\n\n * loader - 一个 ClassLoader 对象，定义了由哪个 ClassLoader 对象来对生成的代理对象进行加载。\n * interfaces - 一个 Class<?> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n * h - 一个 InvocationHandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 InvocationHandler 对象上\n\n# JDK 动态代理实例\n\n上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：\n\n首先我们定义了一个 Subject 类型的接口，为其声明了两个方法：\n\npublic interface Subject {\n\n    void hello(String str);\n\n    String bye();\n}\n\n\n接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject 类：\n\npublic class RealSubject implements Subject {\n\n    @Override\n    public void hello(String str) {\n        System.out.println("Hello  " + str);\n    }\n\n    @Override\n    public String bye() {\n        System.out.println("Goodbye");\n        return "Over";\n    }\n}\n\n\n下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外：\n\npublic class InvocationHandlerDemo implements InvocationHandler {\n    // 这个就是我们要代理的真实对象\n    private Object subject;\n\n    // 构造方法，给我们要代理的真实对象赋初值\n    public InvocationHandlerDemo(Object subject) {\n        this.subject = subject;\n    }\n\n    @Override\n    public Object invoke(Object object, Method method, Object[] args)\n        throws Throwable {\n        // 在代理真实对象前我们可以添加一些自己的操作\n        System.out.println("Before method");\n\n        System.out.println("Call Method: " + method);\n\n        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        Object obj = method.invoke(subject, args);\n\n        // 在代理真实对象后我们也可以添加一些自己的操作\n        System.out.println("After method");\n        System.out.println();\n\n        return obj;\n    }\n}\n\n\n最后，来看看我们的 Client 类：\n\npublic class Client {\n    public static void main(String[] args) {\n        // 我们要代理的真实对象\n        Subject realSubject = new RealSubject();\n\n        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        InvocationHandler handler = new InvocationHandlerDemo(realSubject);\n\n        /*\n         * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象\n         * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上\n         */\n        Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n\n        System.out.println(subject.getClass().getName());\n        subject.hello("World");\n        String result = subject.bye();\n        System.out.println("Result is: " + result);\n    }\n}\n\n\n我们先来看看控制台的输出：\n\ncom.sun.proxy.$Proxy0\nBefore method\nCall Method: public abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)\nHello  World\nAfter method\n\nBefore method\nCall Method: public abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()\nGoodbye\nAfter method\n\nResult is: Over\n\n\n我们首先来看看 com.sun.proxy.$Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？\n\nSubject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject\n                .getClass().getInterfaces(), handler);\n\n\n可能我以为返回的这个代理对象会是 Subject 类型的对象，或者是 InvocationHandler 的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为 Subject 类型的对象？\n\n原因就是：在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 Subject 类型，所以就可以将其转化为 Subject 类型了。\n\n同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。\n\n接着我们来看看这两句\n\nsubject.hello("World");\nString result = subject.bye();\n\n\n这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。\n\n我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：\n\npublic abstract void io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.hello(java.lang.String)\npublic abstract java.lang.String io.github.dunwu.javacore.reflect.InvocationHandlerDemo$Subject.bye()\n\n\n正好就是我们的 Subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。\n\n# JDK 动态代理小结\n\n代理类与委托类实现同一接口，主要是通过代理类实现 InvocationHandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\nJDK 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n\n * 缺点：强制要求代理类实现 InvocationHandler 接口。\n\n\n# CGLIB 动态代理\n\nCGLIB 提供了与 JDK 动态代理不同的方案。很多框架，例如 Spring AOP 中，就使用了 CGLIB 动态代理。\n\nCGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。\n\nCGLIB 动态代理的工作步骤：\n\n * 生成代理类的二进制字节码文件；\n * 加载二进制字节码，生成 Class 对象( 例如使用 Class.forName() 方法 )；\n * 通过反射机制获得实例构造，并创建代理类对象。\n\nCGLIB 动态代理特点：\n\n优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n> 参考：深入理解 CGLIB 动态代理机制\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * 深入拆解 Java 虚拟机\n * 深入解析 Java 反射（1） - 基础\n * Java 基础之—反射（非常重要）\n * 官方 Reflection API 文档\n * Java 的动态代理机制详解\n * Java 动态代理机制详解（JDK 和 CGLIB，Javassist，ASM）\n * 深入理解 JDK 动态代理机制\n * 深入理解 CGLIB 动态代理机制',normalizedContent:'# 深入理解 java 反射和动态代理\n\n\n# 反射简介\n\n\n\n\n# 什么是反射\n\n反射(reflection)是 java 程序开发语言的特征之一，它允许运行中的 java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n\n通过反射机制，可以在运行时访问 java 对象的属性，方法，构造方法等。\n\n\n# 反射的应用场景\n\n反射的主要应用场景有：\n\n * 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 spring）都是配置化的（比如通过 xml 文件配置 javabean、filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。\n * 动态代理 - 在切面编程（aop）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。\n * 注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。\n * 可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。\n\n\n# 反射的缺点\n\n * 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。\n * 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。\n * 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。\n\n\n# 反射机制\n\n\n# 类加载过程\n\n\n\n类加载的完整过程如下：\n\n 1. 在编译时，java 编译器编译好 .java 文件之后，在磁盘中产生 .class 文件。.class 文件是二进制文件，内容是只有 jvm 能够识别的机器码。\n 2. jvm 中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析.class 文件内的信息。类加载器会根据类的全限定名来获取此类的二进制字节流；然后，将字节流所代表的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的 java.lang.class 对象。\n 3. 加载结束后，jvm 开始进行连接阶段（包含验证、准备、初始化）。经过这一系列操作，类的变量会被初始化。\n\n\n# class 对象\n\n要想使用反射，首先需要获得待操作的类所对应的 class 对象。java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 class 对象。这个 class 对象是由 jvm 生成的，通过它能够获悉整个类的结构。所以，java.lang.class 可以视为所有反射 api 的入口点。\n\n反射的本质就是：在运行时，把 java 类中的各种成分映射成一个个的 java 对象。\n\n举例来说，假如定义了以下代码：\n\nuser user = new user();\n\n\n步骤说明：\n\n 1. jvm 加载方法的时候，遇到 new user()，jvm 会根据 user 的全限定名去加载 user.class 。\n 2. jvm 会去本地磁盘查找 user.class 文件并加载 jvm 内存中。\n 3. jvm 通过调用类加载器自动创建这个类对应的 class 对象，并且存储在 jvm 的方法区。注意：一个类有且只有一个 class 对象。\n\n\n# 方法的反射调用\n\n方法的反射调用，也就是 method.invoke 方法。\n\nmethod.invoke 方法源码：\n\npublic final class method extends executable {\n  ...\n  public object invoke(object obj, object... args) throws ... {\n    ... // 权限检查\n    methodaccessor ma = methodaccessor;\n    if (ma == null) {\n      ma = acquiremethodaccessor();\n    }\n    return ma.invoke(obj, args);\n  }\n}\n\n\nmethod.invoke 方法实际上委派给 methodaccessor 接口来处理。它有两个已有的具体实现：\n\n * nativemethodaccessorimpl：本地方法来实现反射调用\n * delegatingmethodaccessorimpl：委派模式来实现反射调用\n\n每个 method 实例的第一次反射调用都会生成一个委派实现（delegatingmethodaccessorimpl），它所委派的具体实现便是一个本地实现（nativemethodaccessorimpl）。本地实现非常容易理解。当进入了 java 虚拟机内部之后，我们便拥有了 method 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。\n\n【示例】通过抛出异常方式 打印 method.invoke 调用轨迹\n\npublic class methoddemo01 {\n\n    public static void target(int i) {\n        new exception("#" + i).printstacktrace();\n    }\n\n    public static void main(string[] args) throws exception {\n        class<?> clazz = class.forname("io.github.dunwu.javacore.reflect.methoddemo01");\n        method method = clazz.getmethod("target", int.class);\n        method.invoke(null, 0);\n    }\n\n}\n// output:\n// java.lang.exception: #0\n//     at io.github.dunwu.javacore.reflect.methoddemo01.target(methoddemo01.java:12)\n//     at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n//     at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n\n\n先调用 delegatingmethodaccessorimpl；然后调用 nativemethodaccessorimpl，最后调用实际方法。\n\n为什么反射调用delegatingmethodaccessorimpl 作为中间层，而不是直接交给本地实现？\n\n其实，java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 java 到 c++ 再到 java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。\n\n考虑到许多反射调用仅会执行一次，java 虚拟机设置了一个阈值 15（可以通过 -dsun.reflect.inflationthreshold 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 inflation。\n\n【示例】执行 java -verbose:class methoddemo02 启动\n\npublic class methoddemo02 {\n\n    public static void target(int i) {\n        new exception("#" + i).printstacktrace();\n    }\n\n    public static void main(string[] args) throws exception {\n        class<?> klass = class.forname("io.github.dunwu.javacore.reflect.methoddemo02");\n        method method = klass.getmethod("target", int.class);\n        for (int i = 0; i < 20; i++) {\n            method.invoke(null, i);\n        }\n    }\n\n}\n\n\n输出内容：\n\n// ...省略\njava.lang.exception: #14\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n[loaded sun.reflect.classfileconstants from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.accessorgenerator from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.methodaccessorgenerator from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevectorfactory from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevector from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.bytevectorimpl from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classfileassembler from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.utf8 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.label from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.label$patchinfo from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded java.util.arraylist$itr from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.methodaccessorgenerator$1 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classdefiner from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.classdefiner$1 from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\n[loaded sun.reflect.generatedmethodaccessor1 from __jvm_defineclass__]\njava.lang.exception: #15\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.nativemethodaccessorimpl.invoke0(native method)\n        at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:62)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n[loaded java.util.concurrent.concurrenthashmap$forwardingnode from d:\\tools\\java\\jdk1.8.0_192\\jre\\lib\\rt.jar]\njava.lang.exception: #16\n        at io.github.dunwu.javacore.reflect.methoddemo02.target(methoddemo02.java:13)\n        at sun.reflect.generatedmethodaccessor1.invoke(unknown source)\n        at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)\n        at java.lang.reflect.method.invoke(method.java:498)\n        at io.github.dunwu.javacore.reflect.methoddemo02.main(methoddemo02.java:20)\n// ...省略\n\n\n可以看到，从第 16 次开始后，都是使用 delegatingmethodaccessorimpl ，不再使用本地实现 nativemethodaccessorimpl。\n\n\n# 反射调用的开销\n\n方法的反射调用会带来不少性能开销，原因主要有三个：\n\n * 变长参数方法导致的 object 数组\n * 基本类型的自动装箱、拆箱\n * 还有最重要的方法内联\n\nclass.forname 会调用本地方法，class.getmethod 则会遍历该类的公有方法。如果没有匹配到，它还将遍历父类的公有方法。可想而知，这两个操作都非常费时。\n\n> 注意，以 getmethod 为代表的查找方法操作，会返回查找得到结果的一份拷贝。因此，我们应当避免在热点代码中使用返回 method 数组的 getmethods 或者 getdeclaredmethods 方法，以减少不必要的堆空间消耗。在实践中，我们往往会在应用程序中缓存 class.forname 和 class.getmethod 的结果。\n\n下面只关注反射调用本身的性能开销。\n\n第一，由于 method.invoke 是一个变长参数方法，在字节码层面它的最后一个参数会是 object 数组（感兴趣的同学私下可以用 javap 查看）。java 编译器会在方法调用处生成一个长度为传入参数数量的 object 数组，并将传入参数一一存储进该数组中。\n\n第二，由于 object 数组不能存储基本类型，java 编译器会对传入的基本类型参数进行自动装箱。\n\n这两个操作除了带来性能开销外，还可能占用堆内存，使得 gc 更加频繁。（如果你感兴趣的话，可以用虚拟机参数 -xx:+printgc 试试。）那么，如何消除这部分开销呢？\n\n\n# 使用反射\n\n\n# java.lang.reflect 包\n\njava 中的 java.lang.reflect 包提供了反射功能。java.lang.reflect 包中的类都没有 public 构造方法。\n\njava.lang.reflect 包的核心接口和类如下：\n\n * member 接口：反映关于单个成员(字段或方法)或构造函数的标识信息。\n * field 类：提供一个类的域的信息以及访问类的域的接口。\n * method 类：提供一个类的方法的信息以及访问类的方法的接口。\n * constructor 类：提供一个类的构造函数的信息以及访问类的构造函数的接口。\n * array 类：该类提供动态地生成和访问 java 数组的方法。\n * modifier 类：提供了 static 方法和常量，对类和成员访问修饰符进行解码。\n * proxy 类：提供动态地生成代理类和类实例的静态方法。\n\n\n# 获取 class 对象\n\n获取 class 对象的三种方法：\n\n（1）class.forname 静态方法\n\n【示例】使用 class.forname 静态方法获取 class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\npublic class reflectclassdemo01 {\n    public static void main(string[] args) throws classnotfoundexception {\n        class c1 = class.forname("io.github.dunwu.javacore.reflect.reflectclassdemo01");\n        system.out.println(c1.getcanonicalname());\n\n        class c2 = class.forname("[d");\n        system.out.println(c2.getcanonicalname());\n\n        class c3 = class.forname("[[ljava.lang.string;");\n        system.out.println(c3.getcanonicalname());\n    }\n}\n//output:\n//io.github.dunwu.javacore.reflect.reflectclassdemo01\n//double[]\n//java.lang.string[][]\n\n\n使用类的完全限定名来反射对象的类。常见的应用场景为：在 jdbc 开发中常用此方法加载数据库驱动。\n\n（2）类名 + .class\n\n【示例】直接用类名 + .class 获取 class 对象\n\npublic class reflectclassdemo02 {\n    public static void main(string[] args) {\n        boolean b;\n        // class c = b.getclass(); // 编译错误\n        class c1 = boolean.class;\n        system.out.println(c1.getcanonicalname());\n\n        class c2 = java.io.printstream.class;\n        system.out.println(c2.getcanonicalname());\n\n        class c3 = int[][][].class;\n        system.out.println(c3.getcanonicalname());\n    }\n}\n//output:\n//boolean\n//java.io.printstream\n//int[][][]\n\n\n（3）object 的 getclass 方法\n\nobject 类中有 getclass 方法，因为所有类都继承 object 类。从而调用 object 类来获取 class 对象。\n\n【示例】object 的 getclass 方法获取 class 对象\n\npackage io.github.dunwu.javacore.reflect;\n\nimport java.util.hashset;\nimport java.util.set;\n\npublic class reflectclassdemo03 {\n    enum e {a, b}\n\n    public static void main(string[] args) {\n        class c = "foo".getclass();\n        system.out.println(c.getcanonicalname());\n\n        class c2 = reflectclassdemo03.e.a.getclass();\n        system.out.println(c2.getcanonicalname());\n\n        byte[] bytes = new byte[1024];\n        class c3 = bytes.getclass();\n        system.out.println(c3.getcanonicalname());\n\n        set<string> set = new hashset<>();\n        class c4 = set.getclass();\n        system.out.println(c4.getcanonicalname());\n    }\n}\n//output:\n//java.lang.string\n//io.github.dunwu.javacore.reflect.reflectclassdemo.e\n//byte[]\n//java.util.hashset\n\n\n\n# 判断是否为某个类的实例\n\n判断是否为某个类的实例有两种方式：\n\n 1. 用 instanceof 关键字\n 2. 用 class 对象的 isinstance 方法（它是一个 native 方法）\n\n【示例】\n\npublic class instanceofdemo {\n    public static void main(string[] args) {\n        arraylist arraylist = new arraylist();\n        if (arraylist instanceof list) {\n            system.out.println("arraylist is list");\n        }\n        if (list.class.isinstance(arraylist)) {\n            system.out.println("arraylist is list");\n        }\n    }\n}\n//output:\n//arraylist is list\n//arraylist is list\n\n\n\n# 创建实例\n\n通过反射来创建实例对象主要有两种方式：\n\n * 用 class 对象的 newinstance 方法。\n * 用 constructor 对象的 newinstance 方法。\n\n【示例】\n\npublic class newinstancedemo {\n    public static void main(string[] args)\n        throws illegalaccessexception, instantiationexception, nosuchmethodexception, invocationtargetexception {\n        class<?> c1 = stringbuilder.class;\n        stringbuilder sb = (stringbuilder) c1.newinstance();\n        sb.append("aaa");\n        system.out.println(sb.tostring());\n\n        //获取string所对应的class对象\n        class<?> c2 = string.class;\n        //获取string类带一个string参数的构造器\n        constructor constructor = c2.getconstructor(string.class);\n        //根据构造器创建实例\n        string str2 = (string) constructor.newinstance("bbb");\n        system.out.println(str2);\n    }\n}\n//output:\n//aaa\n//bbb\n\n\n\n# 创建数组实例\n\n数组在 java 里是比较特殊的一种类型，它可以赋值给一个对象引用。java 中，通过 array.newinstance 创建数组的实例。\n\n【示例】利用反射创建数组\n\npublic class reflectarraydemo {\n    public static void main(string[] args) throws classnotfoundexception {\n        class<?> cls = class.forname("java.lang.string");\n        object array = array.newinstance(cls, 25);\n        //往数组里添加内容\n        array.set(array, 0, "scala");\n        array.set(array, 1, "java");\n        array.set(array, 2, "groovy");\n        array.set(array, 3, "scala");\n        array.set(array, 4, "clojure");\n        //获取某一项的内容\n        system.out.println(array.get(array, 3));\n    }\n}\n//output:\n//scala\n\n\n其中的 array 类为 java.lang.reflect.array 类。我们array.newinstance 的原型是：\n\npublic static object newinstance(class<?> componenttype, int length)\n    throws negativearraysizeexception {\n    return newarray(componenttype, length);\n}\n\n\n\n# field\n\nclass 对象提供以下方法获取对象的成员（field）：\n\n * getfiled - 根据名称获取公有的（public）类成员。\n * getdeclaredfield - 根据名称获取已声明的类成员。但不能得到其父类的类成员。\n * getfields - 获取所有公有的（public）类成员。\n * getdeclaredfields - 获取所有已声明的类成员。\n\n示例如下：\n\npublic class reflectfielddemo {\n    class fieldspy<t> {\n        public boolean[][] b = { {false, false}, {true, true} };\n        public string name = "alice";\n        public list<integer> list;\n        public t val;\n    }\n\n    public static void main(string[] args) throws nosuchfieldexception {\n        field f1 = fieldspy.class.getfield("b");\n        system.out.format("type: %s%n", f1.gettype());\n\n        field f2 = fieldspy.class.getfield("name");\n        system.out.format("type: %s%n", f2.gettype());\n\n        field f3 = fieldspy.class.getfield("list");\n        system.out.format("type: %s%n", f3.gettype());\n\n        field f4 = fieldspy.class.getfield("val");\n        system.out.format("type: %s%n", f4.gettype());\n    }\n}\n//output:\n//type: class [[z\n//type: class java.lang.string\n//type: interface java.util.list\n//type: class java.lang.object\n\n\n\n# method\n\nclass 对象提供以下方法获取对象的方法（method）：\n\n * getmethod - 返回类或接口的特定方法。其中第一个参数为方法名称，后面的参数为方法参数对应 class 的对象。\n * getdeclaredmethod - 返回类或接口的特定声明方法。其中第一个参数为方法名称，后面的参数为方法参数对应 class 的对象。\n * getmethods - 返回类或接口的所有 public 方法，包括其父类的 public 方法。\n * getdeclaredmethods - 返回类或接口声明的所有方法，包括 public、protected、默认（包）访问和 private 方法，但不包括继承的方法。\n\n获取一个 method 对象后，可以用 invoke 方法来调用这个方法。\n\ninvoke 方法的原型为:\n\npublic object invoke(object obj, object... args)\n        throws illegalaccessexception, illegalargumentexception,\n           invocationtargetexception\n\n\n【示例】\n\npublic class reflectmethoddemo {\n    public static void main(string[] args)\n        throws nosuchmethodexception, invocationtargetexception, illegalaccessexception {\n\n        // 返回所有方法\n        method[] methods1 = system.class.getdeclaredmethods();\n        system.out.println("system getdeclaredmethods 清单（数量 = " + methods1.length + "）：");\n        for (method m : methods1) {\n            system.out.println(m);\n        }\n\n        // 返回所有 public 方法\n        method[] methods2 = system.class.getmethods();\n        system.out.println("system getmethods 清单（数量 = " + methods2.length + "）：");\n        for (method m : methods2) {\n            system.out.println(m);\n        }\n\n        // 利用 method 的 invoke 方法调用 system.currenttimemillis()\n        method method = system.class.getmethod("currenttimemillis");\n        system.out.println(method);\n        system.out.println(method.invoke(null));\n    }\n}\n\n\n\n# constructor\n\nclass 对象提供以下方法获取对象的构造方法（constructor）：\n\n * getconstructor - 返回类的特定 public 构造方法。参数为方法参数对应 class 的对象。\n * getdeclaredconstructor - 返回类的特定构造方法。参数为方法参数对应 class 的对象。\n * getconstructors - 返回类的所有 public 构造方法。\n * getdeclaredconstructors - 返回类的所有构造方法。\n\n获取一个 constructor 对象后，可以用 newinstance 方法来创建类实例。\n\n【示例】\n\npublic class reflectmethodconstructordemo {\n    public static void main(string[] args)\n        throws nosuchmethodexception, illegalaccessexception, invocationtargetexception, instantiationexception {\n        constructor<?>[] constructors1 = string.class.getdeclaredconstructors();\n        system.out.println("string getdeclaredconstructors 清单（数量 = " + constructors1.length + "）：");\n        for (constructor c : constructors1) {\n            system.out.println(c);\n        }\n\n        constructor<?>[] constructors2 = string.class.getconstructors();\n        system.out.println("string getconstructors 清单（数量 = " + constructors2.length + "）：");\n        for (constructor c : constructors2) {\n            system.out.println(c);\n        }\n\n        system.out.println("====================");\n        constructor constructor = string.class.getconstructor(string.class);\n        system.out.println(constructor);\n        string str = (string) constructor.newinstance("bbb");\n        system.out.println(str);\n    }\n}\n\n\n\n# 绕开访问限制\n\n有时候，我们需要通过反射访问私有成员、方法。可以使用 constructor/field/method.setaccessible(true) 来绕开 java 语言的访问限制。\n\n\n# 动态代理\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 rpc 调用、面向切面的编程（aop）。\n\n实现动态代理的方式很多，比如 jdk 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 asm、cglib（基于 asm）、javassist 等。\n\n\n\n\n# 静态代理\n\n> 静态代理其实就是指设计模式中的代理模式。\n> \n> 代理模式为其他对象提供一种代理以控制对这个对象的访问。\n\n\n\nsubject 定义了 realsubject 和 proxy 的公共接口，这样就在任何使用 realsubject 的地方都可以使用 proxy 。\n\nabstract class subject {\n    public abstract void request();\n}\n\n\nrealsubject 定义 proxy 所代表的真实实体。\n\nclass realsubject extends subject {\n    @override\n    public void request() {\n        system.out.println("真实的请求");\n    }\n}\n\n\nproxy 保存一个引用使得代理可以访问实体，并提供一个与 subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass proxy extends subject {\n    private realsubject real;\n\n    @override\n    public void request() {\n        if (null == real) {\n            real = new realsubject();\n        }\n        real.request();\n    }\n}\n\n\n> 说明：\n> \n> 静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 proxy 和 realsubject 的功能本质上是相同的，proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。\n\n\n# jdk 动态代理\n\n为了解决静态代理的问题，就有了创建动态代理的想法：\n\n在运行状态中，需要代理的地方，根据 subject 和 realsubject，动态地创建一个 proxy，用完之后，就会销毁，这样就可以避免了 proxy 角色的 class 在系统中冗杂的问题了。\n\n\n\njava 动态代理基于经典代理模式，引入了一个 invocationhandler，invocationhandler 负责统一管理所有的方法调用。\n\n动态代理步骤：\n\n 1. 获取 realsubject 上的所有接口列表；\n 2. 确定要生成的代理类的类名，默认为：com.sun.proxy.$proxyxxxx；\n 3. 根据需要实现的接口信息，在代码中动态创建 该 proxy 类的字节码；\n 4. 将对应的字节码转换为对应的 class 对象；\n 5. 创建 invocationhandler 实例 handler，用来处理 proxy 所有方法调用；\n 6. proxy 的 class 对象 以创建的 handler 对象为参数，实例化一个 proxy 对象。\n\n从上面可以看出，jdk 动态代理的实现是基于实现接口的方式，使得 proxy 和 realsubject 具有相同的功能。\n\n但其实还有一种思路：通过继承。即：让 proxy 继承 realsubject，这样二者同样具有相同的功能，proxy 还可以通过重写 realsubject 中的方法，来实现多态。cglib 就是基于这种思路设计的。\n\n在 java 的动态代理机制中，有两个重要的类（接口），一个是 invocationhandler 接口、另一个则是 proxy 类，这一个类和一个接口是实现我们动态代理所必须用到的。\n\n# invocationhandler 接口\n\ninvocationhandler 接口定义：\n\npublic interface invocationhandler {\n    public object invoke(object proxy, method method, object[] args)\n        throws throwable;\n}\n\n\n每一个动态代理类都必须要实现 invocationhandler 这个接口，并且每个代理类的实例都关联到了一个 handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 invocationhandler 这个接口的 invoke 方法来进行调用。\n\n我们来看看 invocationhandler 这个接口的唯一一个方法 invoke 方法：\n\nobject invoke(object proxy, method method, object[] args) throws throwable\n\n\n参数说明：\n\n * proxy - 代理的真实对象。\n * method - 所要调用真实对象的某个方法的 method 对象\n * args - 所要调用真实对象某个方法时接受的参数\n\n如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。\n\n# proxy 类\n\nproxy 这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newproxyinstance 这个方法：\n\npublic static object newproxyinstance(classloader loader, class<?>[] interfaces,  invocationhandler h)  throws illegalargumentexception\n\n\n这个方法的作用就是得到一个动态的代理对象。\n\n参数说明：\n\n * loader - 一个 classloader 对象，定义了由哪个 classloader 对象来对生成的代理对象进行加载。\n * interfaces - 一个 class<?> 对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了\n * h - 一个 invocationhandler 对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个 invocationhandler 对象上\n\n# jdk 动态代理实例\n\n上面的内容介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的：\n\n首先我们定义了一个 subject 类型的接口，为其声明了两个方法：\n\npublic interface subject {\n\n    void hello(string str);\n\n    string bye();\n}\n\n\n接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，realsubject 类：\n\npublic class realsubject implements subject {\n\n    @override\n    public void hello(string str) {\n        system.out.println("hello  " + str);\n    }\n\n    @override\n    public string bye() {\n        system.out.println("goodbye");\n        return "over";\n    }\n}\n\n\n下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 invocationhandler 这个接口，因此我们这个动态代理类也不例外：\n\npublic class invocationhandlerdemo implements invocationhandler {\n    // 这个就是我们要代理的真实对象\n    private object subject;\n\n    // 构造方法，给我们要代理的真实对象赋初值\n    public invocationhandlerdemo(object subject) {\n        this.subject = subject;\n    }\n\n    @override\n    public object invoke(object object, method method, object[] args)\n        throws throwable {\n        // 在代理真实对象前我们可以添加一些自己的操作\n        system.out.println("before method");\n\n        system.out.println("call method: " + method);\n\n        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\n        object obj = method.invoke(subject, args);\n\n        // 在代理真实对象后我们也可以添加一些自己的操作\n        system.out.println("after method");\n        system.out.println();\n\n        return obj;\n    }\n}\n\n\n最后，来看看我们的 client 类：\n\npublic class client {\n    public static void main(string[] args) {\n        // 我们要代理的真实对象\n        subject realsubject = new realsubject();\n\n        // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的\n        invocationhandler handler = new invocationhandlerdemo(realsubject);\n\n        /*\n         * 通过proxy的newproxyinstance方法来创建我们的代理对象，我们来看看其三个参数\n         * 第一个参数 handler.getclass().getclassloader() ，我们这里使用handler这个类的classloader对象来加载我们的代理对象\n         * 第二个参数realsubject.getclass().getinterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了\n         * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 invocationhandler 这个对象上\n         */\n        subject subject = (subject)proxy.newproxyinstance(handler.getclass().getclassloader(), realsubject\n                .getclass().getinterfaces(), handler);\n\n        system.out.println(subject.getclass().getname());\n        subject.hello("world");\n        string result = subject.bye();\n        system.out.println("result is: " + result);\n    }\n}\n\n\n我们先来看看控制台的输出：\n\ncom.sun.proxy.$proxy0\nbefore method\ncall method: public abstract void io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.hello(java.lang.string)\nhello  world\nafter method\n\nbefore method\ncall method: public abstract java.lang.string io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.bye()\ngoodbye\nafter method\n\nresult is: over\n\n\n我们首先来看看 com.sun.proxy.$proxy0 这东西，我们看到，这个东西是由 system.out.println(subject.getclass().getname()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？\n\nsubject subject = (subject)proxy.newproxyinstance(handler.getclass().getclassloader(), realsubject\n                .getclass().getinterfaces(), handler);\n\n\n可能我以为返回的这个代理对象会是 subject 类型的对象，或者是 invocationhandler 的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为 subject 类型的对象？\n\n原因就是：在 newproxyinstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是 subject 类型，所以就可以将其转化为 subject 类型了。\n\n同时我们一定要记住，通过 proxy.newproxyinstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 invocationhandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy 为中，最后一个数字表示对象的标号。\n\n接着我们来看看这两句\n\nsubject.hello("world");\nstring result = subject.bye();\n\n\n这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的 invoke 方法去执行，而我们的这个 handler 对象又接受了一个 realsubject 类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的 invoke 方法去执行。\n\n我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：\n\npublic abstract void io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.hello(java.lang.string)\npublic abstract java.lang.string io.github.dunwu.javacore.reflect.invocationhandlerdemo$subject.bye()\n\n\n正好就是我们的 subject 接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的 invoke 方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。\n\n# jdk 动态代理小结\n\n代理类与委托类实现同一接口，主要是通过代理类实现 invocationhandler 并重写 invoke 方法来进行动态代理的，在 invoke 方法中将对方法进行处理。\n\njdk 动态代理特点：\n\n * 优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。\n\n * 缺点：强制要求代理类实现 invocationhandler 接口。\n\n\n# cglib 动态代理\n\ncglib 提供了与 jdk 动态代理不同的方案。很多框架，例如 spring aop 中，就使用了 cglib 动态代理。\n\ncglib 底层，其实是借助了 asm 这个强大的 java 字节码框架去进行字节码增强操作。\n\ncglib 动态代理的工作步骤：\n\n * 生成代理类的二进制字节码文件；\n * 加载二进制字节码，生成 class 对象( 例如使用 class.forname() 方法 )；\n * 通过反射机制获得实例构造，并创建代理类对象。\n\ncglib 动态代理特点：\n\n优点：使用字节码增强，比 jdk 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。\n\n缺点：不能对 final 类以及 final 方法进行代理。\n\n> 参考：深入理解 cglib 动态代理机制\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * 深入拆解 java 虚拟机\n * 深入解析 java 反射（1） - 基础\n * java 基础之—反射（非常重要）\n * 官方 reflection api 文档\n * java 的动态代理机制详解\n * java 动态代理机制详解（jdk 和 cglib，javassist，asm）\n * 深入理解 jdk 动态代理机制\n * 深入理解 cglib 动态代理机制',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"参考和来源",frontmatter:{title:"参考和来源",date:"2022-06-22T15:29:01.000Z",permalink:"/pages/47aa52/"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/99.%E5%8F%82%E8%80%83%E5%92%8C%E6%9D%A5%E6%BA%90.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/99.参考和来源.md",key:"v-5f2b8c5c",path:"/pages/47aa52/",headers:[{level:2,title:"参考和来源",slug:"参考和来源",normalizedTitle:"参考和来源",charIndex:2}],headersStr:"参考和来源",content:"# 参考和来源\n\n * JavaCore Java 基础部分来源于此，尚未更改，知识结构化搬运。",normalizedContent:"# 参考和来源\n\n * javacore java 基础部分来源于此，尚未更改，知识结构化搬运。",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java 注解",frontmatter:{title:"深入理解 Java 注解",date:"2019-05-06T15:02:02.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","注解"],permalink:"/pages/ecc011/",abbrlink:"87f5f5f7"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.Java%E6%B3%A8%E8%A7%A3.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/11.Java注解.md",key:"v-b0f13722",path:"/pages/ecc011/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:96},{level:3,title:"注解的形式",slug:"注解的形式",normalizedTitle:"注解的形式",charIndex:103},{level:3,title:"什么是注解",slug:"什么是注解",normalizedTitle:"什么是注解",charIndex:419},{level:3,title:"注解的作用",slug:"注解的作用",normalizedTitle:"注解的作用",charIndex:646},{level:3,title:"注解的代价",slug:"注解的代价",normalizedTitle:"注解的代价",charIndex:933},{level:3,title:"注解的应用范围",slug:"注解的应用范围",normalizedTitle:"注解的应用范围",charIndex:1166},{level:2,title:"内置注解",slug:"内置注解",normalizedTitle:"内置注解",charIndex:1487},{level:3,title:"@Override",slug:"override",normalizedTitle:"@override",charIndex:138},{level:3,title:"@Deprecated",slug:"deprecated",normalizedTitle:"@deprecated",charIndex:1524},{level:3,title:"@SuppressWarnnings",slug:"suppresswarnnings",normalizedTitle:"@suppresswarnnings",charIndex:1539},{level:3,title:"@SafeVarargs",slug:"safevarargs",normalizedTitle:"@safevarargs",charIndex:1561},{level:3,title:"@FunctionalInterface",slug:"functionalinterface",normalizedTitle:"@functionalinterface",charIndex:1586},{level:2,title:"元注解",slug:"元注解",normalizedTitle:"元注解",charIndex:7740},{level:3,title:"@Retention",slug:"retention",normalizedTitle:"@retention",charIndex:7851},{level:3,title:"@Documented",slug:"documented",normalizedTitle:"@documented",charIndex:7876},{level:3,title:"@Target",slug:"target",normalizedTitle:"@target",charIndex:7865},{level:3,title:"@Inherited",slug:"inherited",normalizedTitle:"@inherited",charIndex:7891},{level:3,title:"@Repeatable",slug:"repeatable",normalizedTitle:"@repeatable",charIndex:7914},{level:2,title:"自定义注解",slug:"自定义注解",normalizedTitle:"自定义注解",charIndex:614},{level:3,title:"注解的定义",slug:"注解的定义",normalizedTitle:"注解的定义",charIndex:11321},{level:3,title:"注解属性",slug:"注解属性",normalizedTitle:"注解属性",charIndex:11892},{level:3,title:"注解处理器",slug:"注解处理器",normalizedTitle:"注解处理器",charIndex:12408},{level:3,title:"使用注解",slug:"使用注解",normalizedTitle:"使用注解",charIndex:746},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:19110},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:19125}],headersStr:"简介 注解的形式 什么是注解 注解的作用 注解的代价 注解的应用范围 内置注解 @Override @Deprecated @SuppressWarnnings @SafeVarargs @FunctionalInterface 元注解 @Retention @Documented @Target @Inherited @Repeatable 自定义注解 注解的定义 注解属性 注解处理器 使用注解 小结 参考资料",content:'# 深入理解 Java 注解\n\n> 本文内容基于 JDK8。注解是 JDK5 引入的，后续 JDK 版本扩展了一些内容，本文中没有明确指明版本的注解都是 JDK5 就已经支持的注解。\n\n\n# 简介\n\n\n# 注解的形式\n\nJava 中，注解是以 @ 字符开始的修饰符。如下：\n\n@Override\nvoid mySuperMethod() { ... }\n\n\n注解可以包含命名或未命名的属性，并且这些属性有值。\n\n@Author(\n   name = "Benjamin Franklin",\n   date = "3/27/2003"\n)\nclass MyClass() { ... }\n\n\n如果只有一个名为 value 的属性，那么名称可以省略，如：\n\n@SuppressWarnings("unchecked")\nvoid myMethod() { ... }\n\n\n如果注解没有属性，则称为标记注解。如：@Override。\n\n\n# 什么是注解\n\n从本质上来说，注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。\n\n解析一个注解往往有两种形式：\n\n * 编译期直接的扫描 - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 JDK 内置的注解类。\n * 运行期的反射 - 如果要自定义注解，Java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。\n\n\n# 注解的作用\n\n注解有许多用途：\n\n * 编译器信息 - 编译器可以使用注解来检测错误或抑制警告。\n * 编译时和部署时的处理 - 程序可以处理注解信息以生成代码，XML 文件等。\n * 运行时处理 - 可以在运行时检查某些注解并处理。\n\n作为 Java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。\n\n\n# 注解的代价\n\n凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：\n\n * 显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。\n * 自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。\n * 注解所产生的问题，相对而言，更难以 debug 或定位。\n\n但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。\n\n\n# 注解的应用范围\n\n注解可以应用于类、字段、方法和其他程序元素的声明。\n\nJDK8 开始，注解的应用范围进一步扩大，以下是新的应用范围：\n\n类实例初始化表达式：\n\nnew @Interned MyObject();\n\n\n类型转换：\n\nmyString = (@NonNull String) str;\n\n\n实现接口的声明：\n\nclass UnmodifiableList<T> implements\n    @Readonly List<@Readonly T> {}\n\n\n抛出异常声明：\n\nvoid monitorTemperature()\n    throws @Critical TemperatureException {}\n\n\n\n# 内置注解\n\nJDK 中内置了以下注解：\n\n * @Override\n * @Deprecated\n * @SuppressWarnnings\n * @SafeVarargs（JDK7 引入）\n * @FunctionalInterface（JDK8 引入）\n\n\n# @Override\n\n@Override 用于表明被修饰方法覆写了父类的方法。\n\n如果试图使用 @Override 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。\n\n@Override 示例：\n\npublic class OverrideAnnotationDemo {\n\n    static class Person {\n        public String getName() {\n            return "getName";\n        }\n    }\n\n\n    static class Man extends Person {\n        @Override\n        public String getName() {\n            return "override getName";\n        }\n\n        /**\n         *  放开下面的注释，编译时会告警\n         */\n       /*\n        @Override\n        public String getName2() {\n            return "override getName2";\n        }\n        */\n    }\n\n    public static void main(String[] args) {\n        Person per = new Man();\n        System.out.println(per.getName());\n    }\n}\n\n\n\n# @Deprecated\n\n@Deprecated 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。\n\n@Deprecated 有一定的延续性：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 @Deprecated，但编译器仍然会告警。\n\n> 🔔 注意： @Deprecated 这个注解类型和 javadoc 中的 @deprecated 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。\n\n@Deprecated 示例：\n\npublic class DeprecatedAnnotationDemo {\n    static class DeprecatedField {\n        @Deprecated\n        public static final String DEPRECATED_FIELD = "DeprecatedField";\n    }\n\n\n    static class DeprecatedMethod {\n        @Deprecated\n        public String print() {\n            return "DeprecatedMethod";\n        }\n    }\n\n\n    @Deprecated\n    static class DeprecatedClass {\n        public String print() {\n            return "DeprecatedClass";\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(DeprecatedField.DEPRECATED_FIELD);\n\n        DeprecatedMethod dm = new DeprecatedMethod();\n        System.out.println(dm.print());\n\n\n        DeprecatedClass dc = new DeprecatedClass();\n        System.out.println(dc.print());\n    }\n}\n//Output:\n//DeprecatedField\n//DeprecatedMethod\n//DeprecatedClass\n\n\n\n# @SuppressWarnnings\n\n@SuppressWarnings 用于关闭对类、方法、成员编译时产生的特定警告。\n\n@SuppressWarning 不是一个标记注解。它有一个类型为 String[] 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 -Xlint 选项有效的警告名也同样对 @SuppressWarings 有效，同时编译器会忽略掉无法识别的警告名。\n\n@SuppressWarning 示例：\n\n@SuppressWarnings({"rawtypes", "unchecked"})\npublic class SuppressWarningsAnnotationDemo {\n    static class SuppressDemo<T> {\n        private T value;\n\n        public T getValue() {\n            return this.value;\n        }\n\n        public void setValue(T var) {\n            this.value = var;\n        }\n    }\n\n    @SuppressWarnings({"deprecation"})\n    public static void main(String[] args) {\n        SuppressDemo d = new SuppressDemo();\n        d.setValue("南京");\n        System.out.println("地名：" + d.getValue());\n    }\n}\n\n\n@SuppressWarnings 注解的常见参数值的简单说明：\n\n * deprecation - 使用了不赞成使用的类或方法时的警告；\n * unchecked - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型;\n * fallthrough - 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告;\n * path - 在类路径、源文件路径等中有不存在的路径时的警告;\n * serial - 当在可序列化的类上缺少 serialVersionUID 定义时的警告;\n * finally - 任何 finally 子句不能正常完成时的警告;\n * all - 所有的警告。\n\n@SuppressWarnings({"uncheck", "deprecation"})\npublic class InternalAnnotationDemo {\n\n    /**\n     * @SuppressWarnings 标记消除当前类的告警信息\n     */\n    @SuppressWarnings({"deprecation"})\n    static class A {\n        public void method1() {\n            System.out.println("call method1");\n        }\n\n        /**\n         * @Deprecated 标记当前方法为废弃方法，不建议使用\n         */\n        @Deprecated\n        public void method2() {\n            System.out.println("call method2");\n        }\n    }\n\n    /**\n     * @Deprecated 标记当前类为废弃类，不建议使用\n     */\n    @Deprecated\n    static class B extends A {\n        /**\n         * @Override 标记显示指明当前方法覆写了父类或接口的方法\n         */\n        @Override\n        public void method1() { }\n    }\n\n    public static void main(String[] args) {\n        A obj = new B();\n        obj.method1();\n        obj.method2();\n    }\n}\n\n\n\n# @SafeVarargs\n\n@SafeVarargs 在 JDK7 中引入。\n\n@SafeVarargs 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。\n\n简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 ClassCastException 异常。\n\n@SafeVarargs 注解使用范围：\n\n * @SafeVarargs 注解可以用于构造方法。\n * @SafeVarargs 注解可以用于 static 或 final 方法。\n\n@SafeVarargs 示例：\n\npublic class SafeVarargsAnnotationDemo {\n    /**\n     * 此方法实际上并不安全，不使用此注解，编译时会告警\n     */\n    @SafeVarargs\n    static void wrongMethod(List<String>... stringLists) {\n        Object[] array = stringLists;\n        List<Integer> tmpList = Arrays.asList(42);\n        array[0] = tmpList; // 语法错误，但是编译不告警\n        String s = stringLists[0].get(0); // 运行时报 ClassCastException\n    }\n\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add("A");\n        list.add("B");\n\n        List<String> list2 = new ArrayList<>();\n        list.add("1");\n        list.add("2");\n\n        wrongMethod(list, list2);\n    }\n}\n\n\n以上代码，如果不使用 @SafeVarargs ，编译时会告警\n\n[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 某些输入文件使用了未经检查或不安全的操作。\n[WARNING] /D:/Codes/ZP/Java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/SafeVarargsAnnotationDemo.java: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。\n\n\n\n# @FunctionalInterface\n\n@FunctionalInterface 在 JDK8 引入。\n\n@FunctionalInterface 用于指示被修饰的接口是函数式接口。\n\n需要注意的是，如果一个接口符合"函数式接口"定义，不加 @FunctionalInterface 也没关系；但如果编写的不是函数式接口，却使用 @FunctionInterface，那么编译器会报错。\n\n什么是函数式接口？\n\n函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。\n\n函数式接口的特点：\n\n * 接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。\n * 不能在接口中覆写 Object 类中的 public 方法（写了编译器也会报错）。\n * 允许有 default 实现方法。\n\n示例：\n\npublic class FunctionalInterfaceAnnotationDemo {\n\n    @FunctionalInterface\n    public interface Func1<T> {\n        void printMessage(T message);\n    }\n\n    /**\n     * @FunctionalInterface 修饰的接口中定义两个抽象方法，编译时会报错\n     * @param <T>\n     */\n    /*@FunctionalInterface\n    public interface Func2<T> {\n        void printMessage(T message);\n        void printMessage2(T message);\n    }*/\n\n    public static void main(String[] args) {\n        Func1 func1 = message -> System.out.println(message);\n        func1.printMessage("Hello");\n        func1.printMessage(100);\n    }\n}\n\n\n\n# 元注解\n\nJDK 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。\n\n元注解的作用就是用于定义其它的注解。\n\nJava 中提供了以下元注解类型：\n\n * @Retention\n * @Target\n * @Documented\n * @Inherited（JDK8 引入）\n * @Repeatable（JDK8 引入）\n\n这些类型和它们所支持的类在 java.lang.annotation 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。\n\n\n# @Retention\n\n@Retention 指明了注解的保留级别。\n\n@Retention 源码：\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Retention {\n    RetentionPolicy value();\n}\n\n\nRetentionPolicy 是一个枚举类型，它定义了被 @Retention 修饰的注解所支持的保留级别：\n\n * RetentionPolicy.SOURCE - 标记的注解仅在源文件中有效，编译器会忽略。\n * RetentionPolicy.CLASS - 标记的注解在 class 文件中有效，JVM 会忽略。\n * RetentionPolicy.RUNTIME - 标记的注解在运行时有效。\n\n@Retention 示例：\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Column {\n    public String name() default "fieldName";\n    public String setFuncName() default "setField";\n    public String getFuncName() default "getField";\n    public boolean defaultDBValue() default false;\n}\n\n\n\n# @Documented\n\n@Documented 表示无论何时使用指定的注解，都应使用 Javadoc（默认情况下，注释不包含在 Javadoc 中）。更多内容可以参考：Javadoc tools page。\n\n@Documented 示例：\n\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Column {\n    public String name() default "fieldName";\n    public String setFuncName() default "setField";\n    public String getFuncName() default "getField";\n    public boolean defaultDBValue() default false;\n}\n\n\n\n# @Target\n\n@Target 指定注解可以修饰的元素类型。\n\n@Target 源码：\n\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.ANNOTATION_TYPE)\npublic @interface Target {\n    ElementType[] value();\n}\n\n\nElementType 是一个枚举类型，它定义了被 @Target 修饰的注解可以应用的范围：\n\n * ElementType.ANNOTATION_TYPE - 标记的注解可以应用于注解类型。\n * ElementType.CONSTRUCTOR - 标记的注解可以应用于构造函数。\n * ElementType.FIELD - 标记的注解可以应用于字段或属性。\n * ElementType.LOCAL_VARIABLE - 标记的注解可以应用于局部变量。\n * ElementType.METHOD - 标记的注解可以应用于方法。\n * ElementType.PACKAGE - 标记的注解可以应用于包声明。\n * ElementType.PARAMETER - 标记的注解可以应用于方法的参数。\n * ElementType.TYPE - 标记的注解可以应用于类的任何元素。\n\n@Target 示例：\n\n@Target(ElementType.TYPE)\npublic @interface Table {\n    /**\n     * 数据表名称注解，默认值为类名称\n     * @return\n     */\n    public String tableName() default "className";\n}\n\n@Target(ElementType.FIELD)\npublic @interface NoDBColumn {}\n\n\n\n# @Inherited\n\n@Inherited 表示注解类型可以被继承（默认情况下不是这样）。\n\n表示自动继承注解类型。 如果注解类型声明中存在 @Inherited 元注解，则注解所修饰类的所有子类都将会继承此注解。\n\n> 🔔 注意：@Inherited 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。\n> \n> 此外，当 @Inherited 类型标注的注解的 @Retention 是 RetentionPolicy.RUNTIME，则反射 API 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @Inherited 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。\n\n@Inherited\npublic @interface Greeting {\n    public enum FontColor{ BULE,RED,GREEN};\n    String name();\n    FontColor fontColor() default FontColor.GREEN;\n}\n\n\n\n# @Repeatable\n\n@Repeatable 表示注解可以重复使用。\n\n以 Spring @Scheduled 为例：\n\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Schedules {\n\tScheduled[] value();\n}\n\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Repeatable(Schedules.class)\npublic @interface Scheduled {\n  // ...\n}\n\n\n应用示例：\n\npublic class TaskRunner {\n\n    @Scheduled("0 0/15 * * * ?")\n    @Scheduled("0 0 12 * ?")\n    public void task1() {}\n}\n\n\n\n# 自定义注解\n\n使用 @interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过 default 来声明参数的默认值。\n\n这里，我会通过实现一个名为 RegexValid 的正则校验注解工具来展示自定义注解的全步骤。\n\n\n# 注解的定义\n\n注解的语法格式如下：\n\npublic @interface 注解名 {定义体}\n\n\n我们来定义一个注解：\n\n@Documented\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RegexValid {}\n\n\n> 说明：\n> \n> 通过上一节对于元注解 @Target、@Retention、@Documented 的说明，这里就很容易理解了。\n> \n>  * 上面的代码中定义了一个名为 @RegexValid 的注解。\n>  * @Documented 表示 @RegexValid 应该使用 javadoc。\n>  * @Target({ElementType.FIELD, ElementType.PARAMETER}) 表示 @RegexValid 可以在类成员或方法参数上修饰。\n>  * @Retention(RetentionPolicy.RUNTIME) 表示 @RegexValid 在运行时有效。\n\n此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。\n\n\n# 注解属性\n\n注解属性的语法形式如下：\n\n[访问级别修饰符] [数据类型] 名称() default 默认值;\n\n\n例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：\n\nString value() default "";\n\n\n> 🔔 注意：在注解中，我们定义属性时，属性名后面需要加 ()。\n\n定义注解属性有以下要点：\n\n * 注解属性只能使用 public 或默认访问级别（即不指定访问级别修饰符）修饰。\n\n * 注解属性的数据类型有限制要求。支持的数据类型如下：\n   \n   * 所有基本数据类型（byte、char、short、int、long、float、double、boolean）\n   * String 类型\n   * Class 类\n   * enum 类型\n   * Annotation 类型\n   * 以上所有类型的数组\n\n * 注解属性必须有确定的值，建议指定默认值。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。\n\n * 如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。\n\n// 这两种方式效果相同\n@RegexValid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n@RegexValid(value = "^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n\n\n示例：\n\n了解了注解属性的定义要点，让我们来为 @RegexValid 注解定义几个属性。\n\n@Documented\n@Target({ElementType.FIELD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RegexValid {\n    enum Policy {\n        // @formatter:off\n        EMPTY(null),\n        DATE("^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\\\1"\n            + "(?:29|30)|(?:0?[13578]|1[02])\\\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|"\n            + "(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\\\2(?:29))$"),\n        MAIL("^[A-Za-z0-9](([_\\\\.\\\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\\\.\\\\-]?[a-zA-Z0-9]+)*)\\\\.([A-Za-z]{2,})$");\n        // @formatter:on\n\n        private String policy;\n\n        Policy(String policy) {\n            this.policy = policy;\n        }\n\n        public String getPolicy() {\n            return policy;\n        }\n    }\n\n    String value() default "";\n    Policy policy() default Policy.EMPTY;\n}\n\n\n> 说明：\n> \n> 在上面的示例代码中，我们定义了两个注解属性：String 类型的 value 属性和 Policy 枚举类型的 policy 属性。Policy 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。\n\n至此，@RegexValid 的声明已经结束。但是，程序仍不知道如何处理 @RegexValid 这个注解。我们还需要定义注解处理器。\n\n\n# 注解处理器\n\n如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。JDK5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。\n\njava.lang.annotation.Annotation 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据。\n\nAnnotation 接口源码如下：\n\npublic interface Annotation {\n    boolean equals(Object obj);\n\n    int hashCode();\n\n    String toString();\n\n    Class<? extends Annotation> annotationType();\n}\n\n\n除此之外，Java 中支持注解处理器接口 java.lang.reflect.AnnotatedElement ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：\n\n * Class - 类定义\n * Constructor - 构造器定义\n * Field - 累的成员变量定义\n * Method - 类的方法定义\n * Package - 类的包定义\n\njava.lang.reflect 包下主要包含一些实现反射功能的工具类。实际上，java.lang.reflect 包所有提供的反射 API 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method 和 Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：\n\n * getAnnotation - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。\n * getAnnotations - 返回该程序元素上存在的所有注解。\n * isAnnotationPresent - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。\n * getDeclaredAnnotations - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n了解了以上内容，让我们来实现 @RegexValid 的注解处理器：\n\nimport java.lang.reflect.Field;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegexValidUtil {\n    public static boolean check(Object obj) throws Exception {\n        boolean result = true;\n        StringBuilder sb = new StringBuilder();\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            // 判断成员是否被 @RegexValid 注解所修饰\n            if (field.isAnnotationPresent(RegexValid.class)) {\n                RegexValid valid = field.getAnnotation(RegexValid.class);\n\n                // 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性\n                String value = valid.value();\n                if ("".equals(value)) {\n                    RegexValid.Policy policy = valid.policy();\n                    value = policy.getPolicy();\n                }\n\n                // 通过设置 setAccessible(true) 来访问私有成员\n                field.setAccessible(true);\n                Object fieldObj = null;\n                try {\n                    fieldObj = field.get(obj);\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                if (fieldObj == null) {\n                    sb.append("\\n")\n                        .append(String.format("%s 类中的 %s 字段不能为空！", obj.getClass().getName(), field.getName()));\n                    result = false;\n                } else {\n                    if (fieldObj instanceof String) {\n                        String text = (String) fieldObj;\n                        Pattern p = Pattern.compile(value);\n                        Matcher m = p.matcher(text);\n                        result = m.matches();\n                        if (!result) {\n                            sb.append("\\n").append(String.format("%s 不是合法的 %s ！", text, field.getName()));\n                        }\n                    } else {\n                        sb.append("\\n").append(\n                            String.format("%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！", obj.getClass().getName(), field.getName()));\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        if (sb.length() > 0) {\n            throw new Exception(sb.toString());\n        }\n        return result;\n    }\n}\n\n\n> 说明：\n> \n> 以上示例中的注解处理器，执行步骤如下：\n> \n>  1. 通过 getDeclaredFields 反射方法获取传入对象的所有成员。\n>  2. 遍历成员，使用 isAnnotationPresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。\n>  3. 如果成员被注解所修饰，通过 RegexValid valid = field.getAnnotation(RegexValid.class); 这样的形式获取，注解实例化对象，然后，就可以使用 valid.value() 或 valid.policy() 这样的形式获取注解中设定的属性值。\n>  4. 根据属性值，进行逻辑处理。\n\n\n# 使用注解\n\n完成了以上工作，我们就可以使用自定义注解了，示例如下：\n\npublic class RegexValidDemo {\n    static class User {\n        private String name;\n        @RegexValid(policy = RegexValid.Policy.DATE)\n        private String date;\n        @RegexValid(policy = RegexValid.Policy.MAIL)\n        private String mail;\n        @RegexValid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n        private String phone;\n\n        public User(String name, String date, String mail, String phone) {\n            this.name = name;\n            this.date = date;\n            this.mail = mail;\n            this.phone = phone;\n        }\n\n        @Override\n        public String toString() {\n            return "User{" + "name=\'" + name + \'\\\'\' + ", date=\'" + date + \'\\\'\' + ", mail=\'" + mail + \'\\\'\' + ", phone=\'"\n                + phone + \'\\\'\' + \'}\';\n        }\n    }\n\n    static void printDate(@RegexValid(policy = RegexValid.Policy.DATE) String date){\n        System.out.println(date);\n    }\n\n    public static void main(String[] args) throws Exception {\n        User user = new User("Tom", "1990-01-31", "xxx@163.com", "18612341234");\n        User user2 = new User("Jack", "2019-02-29", "sadhgs", "183xxxxxxxx");\n        if (RegexValidUtil.check(user)) {\n            System.out.println(user + "正则校验通过");\n        }\n        if (RegexValidUtil.check(user2)) {\n            System.out.println(user2 + "正则校验通过");\n        }\n    }\n}\n\n\n\n# 小结\n\n\n\n\n\n\n\n\n\n\n# 参考资料\n\n * Java 编程思想\n * Java 核心技术（卷 1）\n * Effective java\n * Oracle 官方文档之注解篇\n * 深入理解 Java：注解（Annotation）自定义注解入门\n * https://blog.csdn.net/briblue/article/details/73824058',normalizedContent:'# 深入理解 java 注解\n\n> 本文内容基于 jdk8。注解是 jdk5 引入的，后续 jdk 版本扩展了一些内容，本文中没有明确指明版本的注解都是 jdk5 就已经支持的注解。\n\n\n# 简介\n\n\n# 注解的形式\n\njava 中，注解是以 @ 字符开始的修饰符。如下：\n\n@override\nvoid mysupermethod() { ... }\n\n\n注解可以包含命名或未命名的属性，并且这些属性有值。\n\n@author(\n   name = "benjamin franklin",\n   date = "3/27/2003"\n)\nclass myclass() { ... }\n\n\n如果只有一个名为 value 的属性，那么名称可以省略，如：\n\n@suppresswarnings("unchecked")\nvoid mymethod() { ... }\n\n\n如果注解没有属性，则称为标记注解。如：@override。\n\n\n# 什么是注解\n\n从本质上来说，注解是一种标签，其实质上可以视为一种特殊的注释，如果没有解析它的代码，它并不比普通注释强。\n\n解析一个注解往往有两种形式：\n\n * 编译期直接的扫描 - 编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。这种情况只适用于 jdk 内置的注解类。\n * 运行期的反射 - 如果要自定义注解，java 编译器无法识别并处理这个注解，它只能根据该注解的作用范围来选择是否编译进字节码文件。如果要处理注解，必须利用反射技术，识别该注解以及它所携带的信息，然后做相应的处理。\n\n\n# 注解的作用\n\n注解有许多用途：\n\n * 编译器信息 - 编译器可以使用注解来检测错误或抑制警告。\n * 编译时和部署时的处理 - 程序可以处理注解信息以生成代码，xml 文件等。\n * 运行时处理 - 可以在运行时检查某些注解并处理。\n\n作为 java 程序员，多多少少都曾经历过被各种配置文件（xml、properties）支配的恐惧。过多的配置文件会使得项目难以维护。个人认为，使用注解以减少配置文件或代码，是注解最大的用处。\n\n\n# 注解的代价\n\n凡事有得必有失，注解技术同样如此。使用注解也有一定的代价：\n\n * 显然，它是一种侵入式编程，那么，自然就存在着增加程序耦合度的问题。\n * 自定义注解的处理需要在运行时，通过反射技术来获取属性。如果注解所修饰的元素是类的非 public 成员，也可以通过反射获取。这就违背了面向对象的封装性。\n * 注解所产生的问题，相对而言，更难以 debug 或定位。\n\n但是，正所谓瑕不掩瑜，注解所付出的代价，相较于它提供的功能而言，还是可以接受的。\n\n\n# 注解的应用范围\n\n注解可以应用于类、字段、方法和其他程序元素的声明。\n\njdk8 开始，注解的应用范围进一步扩大，以下是新的应用范围：\n\n类实例初始化表达式：\n\nnew @interned myobject();\n\n\n类型转换：\n\nmystring = (@nonnull string) str;\n\n\n实现接口的声明：\n\nclass unmodifiablelist<t> implements\n    @readonly list<@readonly t> {}\n\n\n抛出异常声明：\n\nvoid monitortemperature()\n    throws @critical temperatureexception {}\n\n\n\n# 内置注解\n\njdk 中内置了以下注解：\n\n * @override\n * @deprecated\n * @suppresswarnnings\n * @safevarargs（jdk7 引入）\n * @functionalinterface（jdk8 引入）\n\n\n# @override\n\n@override 用于表明被修饰方法覆写了父类的方法。\n\n如果试图使用 @override 标记一个实际上并没有覆写父类的方法时，java 编译器会告警。\n\n@override 示例：\n\npublic class overrideannotationdemo {\n\n    static class person {\n        public string getname() {\n            return "getname";\n        }\n    }\n\n\n    static class man extends person {\n        @override\n        public string getname() {\n            return "override getname";\n        }\n\n        /**\n         *  放开下面的注释，编译时会告警\n         */\n       /*\n        @override\n        public string getname2() {\n            return "override getname2";\n        }\n        */\n    }\n\n    public static void main(string[] args) {\n        person per = new man();\n        system.out.println(per.getname());\n    }\n}\n\n\n\n# @deprecated\n\n@deprecated 用于标明被修饰的类或类成员、类方法已经废弃、过时，不建议使用。\n\n@deprecated 有一定的延续性：如果我们在代码中通过继承或者覆盖的方式使用了过时的类或类成员，即使子类或子方法没有标记为 @deprecated，但编译器仍然会告警。\n\n> 🔔 注意： @deprecated 这个注解类型和 javadoc 中的 @deprecated 这个 tag 是有区别的：前者是 java 编译器识别的；而后者是被 javadoc 工具所识别用来生成文档（包含程序成员为什么已经过时、它应当如何被禁止或者替代的描述）。\n\n@deprecated 示例：\n\npublic class deprecatedannotationdemo {\n    static class deprecatedfield {\n        @deprecated\n        public static final string deprecated_field = "deprecatedfield";\n    }\n\n\n    static class deprecatedmethod {\n        @deprecated\n        public string print() {\n            return "deprecatedmethod";\n        }\n    }\n\n\n    @deprecated\n    static class deprecatedclass {\n        public string print() {\n            return "deprecatedclass";\n        }\n    }\n\n    public static void main(string[] args) {\n        system.out.println(deprecatedfield.deprecated_field);\n\n        deprecatedmethod dm = new deprecatedmethod();\n        system.out.println(dm.print());\n\n\n        deprecatedclass dc = new deprecatedclass();\n        system.out.println(dc.print());\n    }\n}\n//output:\n//deprecatedfield\n//deprecatedmethod\n//deprecatedclass\n\n\n\n# @suppresswarnnings\n\n@suppresswarnings 用于关闭对类、方法、成员编译时产生的特定警告。\n\n@suppresswarning 不是一个标记注解。它有一个类型为 string[] 的数组成员，这个数组中存储的是要关闭的告警类型。对于 javac 编译器来讲，对 -xlint 选项有效的警告名也同样对 @suppresswarings 有效，同时编译器会忽略掉无法识别的警告名。\n\n@suppresswarning 示例：\n\n@suppresswarnings({"rawtypes", "unchecked"})\npublic class suppresswarningsannotationdemo {\n    static class suppressdemo<t> {\n        private t value;\n\n        public t getvalue() {\n            return this.value;\n        }\n\n        public void setvalue(t var) {\n            this.value = var;\n        }\n    }\n\n    @suppresswarnings({"deprecation"})\n    public static void main(string[] args) {\n        suppressdemo d = new suppressdemo();\n        d.setvalue("南京");\n        system.out.println("地名：" + d.getvalue());\n    }\n}\n\n\n@suppresswarnings 注解的常见参数值的简单说明：\n\n * deprecation - 使用了不赞成使用的类或方法时的警告；\n * unchecked - 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (generics) 来指定集合保存的类型;\n * fallthrough - 当 switch 程序块直接通往下一种情况而没有 break 时的警告;\n * path - 在类路径、源文件路径等中有不存在的路径时的警告;\n * serial - 当在可序列化的类上缺少 serialversionuid 定义时的警告;\n * finally - 任何 finally 子句不能正常完成时的警告;\n * all - 所有的警告。\n\n@suppresswarnings({"uncheck", "deprecation"})\npublic class internalannotationdemo {\n\n    /**\n     * @suppresswarnings 标记消除当前类的告警信息\n     */\n    @suppresswarnings({"deprecation"})\n    static class a {\n        public void method1() {\n            system.out.println("call method1");\n        }\n\n        /**\n         * @deprecated 标记当前方法为废弃方法，不建议使用\n         */\n        @deprecated\n        public void method2() {\n            system.out.println("call method2");\n        }\n    }\n\n    /**\n     * @deprecated 标记当前类为废弃类，不建议使用\n     */\n    @deprecated\n    static class b extends a {\n        /**\n         * @override 标记显示指明当前方法覆写了父类或接口的方法\n         */\n        @override\n        public void method1() { }\n    }\n\n    public static void main(string[] args) {\n        a obj = new b();\n        obj.method1();\n        obj.method2();\n    }\n}\n\n\n\n# @safevarargs\n\n@safevarargs 在 jdk7 中引入。\n\n@safevarargs 的作用是：告诉编译器，在可变长参数中的泛型是类型安全的。可变长参数是使用数组存储的，而数组和泛型不能很好的混合使用。\n\n简单的说，数组元素的数据类型在编译和运行时都是确定的，而泛型的数据类型只有在运行时才能确定下来。因此，当把一个泛型存储到数组中时，编译器在编译阶段无法确认数据类型是否匹配，因此会给出警告信息；即如果泛型的真实数据类型无法和参数数组的类型匹配，会导致 classcastexception 异常。\n\n@safevarargs 注解使用范围：\n\n * @safevarargs 注解可以用于构造方法。\n * @safevarargs 注解可以用于 static 或 final 方法。\n\n@safevarargs 示例：\n\npublic class safevarargsannotationdemo {\n    /**\n     * 此方法实际上并不安全，不使用此注解，编译时会告警\n     */\n    @safevarargs\n    static void wrongmethod(list<string>... stringlists) {\n        object[] array = stringlists;\n        list<integer> tmplist = arrays.aslist(42);\n        array[0] = tmplist; // 语法错误，但是编译不告警\n        string s = stringlists[0].get(0); // 运行时报 classcastexception\n    }\n\n    public static void main(string[] args) {\n        list<string> list = new arraylist<>();\n        list.add("a");\n        list.add("b");\n\n        list<string> list2 = new arraylist<>();\n        list.add("1");\n        list.add("2");\n\n        wrongmethod(list, list2);\n    }\n}\n\n\n以上代码，如果不使用 @safevarargs ，编译时会告警\n\n[warning] /d:/codes/zp/java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/safevarargsannotationdemo.java: 某些输入文件使用了未经检查或不安全的操作。\n[warning] /d:/codes/zp/java/javacore/codes/basics/src/main/java/io/github/dunwu/javacore/annotation/safevarargsannotationdemo.java: 有关详细信息, 请使用 -xlint:unchecked 重新编译。\n\n\n\n# @functionalinterface\n\n@functionalinterface 在 jdk8 引入。\n\n@functionalinterface 用于指示被修饰的接口是函数式接口。\n\n需要注意的是，如果一个接口符合"函数式接口"定义，不加 @functionalinterface 也没关系；但如果编写的不是函数式接口，却使用 @functioninterface，那么编译器会报错。\n\n什么是函数式接口？\n\n函数式接口(functional interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。\n\n函数式接口的特点：\n\n * 接口有且只能有个一个抽象方法（抽象方法只有方法定义，没有方法体）。\n * 不能在接口中覆写 object 类中的 public 方法（写了编译器也会报错）。\n * 允许有 default 实现方法。\n\n示例：\n\npublic class functionalinterfaceannotationdemo {\n\n    @functionalinterface\n    public interface func1<t> {\n        void printmessage(t message);\n    }\n\n    /**\n     * @functionalinterface 修饰的接口中定义两个抽象方法，编译时会报错\n     * @param <t>\n     */\n    /*@functionalinterface\n    public interface func2<t> {\n        void printmessage(t message);\n        void printmessage2(t message);\n    }*/\n\n    public static void main(string[] args) {\n        func1 func1 = message -> system.out.println(message);\n        func1.printmessage("hello");\n        func1.printmessage(100);\n    }\n}\n\n\n\n# 元注解\n\njdk 中虽然内置了几个注解，但这远远不能满足开发过程中遇到的千变万化的需求。所以我们需要自定义注解，而这就需要用到元注解。\n\n元注解的作用就是用于定义其它的注解。\n\njava 中提供了以下元注解类型：\n\n * @retention\n * @target\n * @documented\n * @inherited（jdk8 引入）\n * @repeatable（jdk8 引入）\n\n这些类型和它们所支持的类在 java.lang.annotation 包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。\n\n\n# @retention\n\n@retention 指明了注解的保留级别。\n\n@retention 源码：\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.annotation_type)\npublic @interface retention {\n    retentionpolicy value();\n}\n\n\nretentionpolicy 是一个枚举类型，它定义了被 @retention 修饰的注解所支持的保留级别：\n\n * retentionpolicy.source - 标记的注解仅在源文件中有效，编译器会忽略。\n * retentionpolicy.class - 标记的注解在 class 文件中有效，jvm 会忽略。\n * retentionpolicy.runtime - 标记的注解在运行时有效。\n\n@retention 示例：\n\n@target(elementtype.field)\n@retention(retentionpolicy.runtime)\npublic @interface column {\n    public string name() default "fieldname";\n    public string setfuncname() default "setfield";\n    public string getfuncname() default "getfield";\n    public boolean defaultdbvalue() default false;\n}\n\n\n\n# @documented\n\n@documented 表示无论何时使用指定的注解，都应使用 javadoc（默认情况下，注释不包含在 javadoc 中）。更多内容可以参考：javadoc tools page。\n\n@documented 示例：\n\n@target(elementtype.field)\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface column {\n    public string name() default "fieldname";\n    public string setfuncname() default "setfield";\n    public string getfuncname() default "getfield";\n    public boolean defaultdbvalue() default false;\n}\n\n\n\n# @target\n\n@target 指定注解可以修饰的元素类型。\n\n@target 源码：\n\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.annotation_type)\npublic @interface target {\n    elementtype[] value();\n}\n\n\nelementtype 是一个枚举类型，它定义了被 @target 修饰的注解可以应用的范围：\n\n * elementtype.annotation_type - 标记的注解可以应用于注解类型。\n * elementtype.constructor - 标记的注解可以应用于构造函数。\n * elementtype.field - 标记的注解可以应用于字段或属性。\n * elementtype.local_variable - 标记的注解可以应用于局部变量。\n * elementtype.method - 标记的注解可以应用于方法。\n * elementtype.package - 标记的注解可以应用于包声明。\n * elementtype.parameter - 标记的注解可以应用于方法的参数。\n * elementtype.type - 标记的注解可以应用于类的任何元素。\n\n@target 示例：\n\n@target(elementtype.type)\npublic @interface table {\n    /**\n     * 数据表名称注解，默认值为类名称\n     * @return\n     */\n    public string tablename() default "classname";\n}\n\n@target(elementtype.field)\npublic @interface nodbcolumn {}\n\n\n\n# @inherited\n\n@inherited 表示注解类型可以被继承（默认情况下不是这样）。\n\n表示自动继承注解类型。 如果注解类型声明中存在 @inherited 元注解，则注解所修饰类的所有子类都将会继承此注解。\n\n> 🔔 注意：@inherited 注解类型是被标注过的类的子类所继承。类并不从它所实现的接口继承注解，方法并不从它所覆写的方法继承注解。\n> \n> 此外，当 @inherited 类型标注的注解的 @retention 是 retentionpolicy.runtime，则反射 api 增强了这种继承性。如果我们使用 java.lang.reflect 去查询一个 @inherited 类型的注解时，反射代码检查将展开工作：检查类和其父类，直到发现指定的注解类型被发现，或者到达类继承结构的顶层。\n\n@inherited\npublic @interface greeting {\n    public enum fontcolor{ bule,red,green};\n    string name();\n    fontcolor fontcolor() default fontcolor.green;\n}\n\n\n\n# @repeatable\n\n@repeatable 表示注解可以重复使用。\n\n以 spring @scheduled 为例：\n\n@target({elementtype.method, elementtype.annotation_type})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface schedules {\n\tscheduled[] value();\n}\n\n@target({elementtype.method, elementtype.annotation_type})\n@retention(retentionpolicy.runtime)\n@documented\n@repeatable(schedules.class)\npublic @interface scheduled {\n  // ...\n}\n\n\n应用示例：\n\npublic class taskrunner {\n\n    @scheduled("0 0/15 * * * ?")\n    @scheduled("0 0 12 * ?")\n    public void task1() {}\n}\n\n\n\n# 自定义注解\n\n使用 @interface 自定义注解时，自动继承了 java.lang.annotation.annotation 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、class、string、enum）。可以通过 default 来声明参数的默认值。\n\n这里，我会通过实现一个名为 regexvalid 的正则校验注解工具来展示自定义注解的全步骤。\n\n\n# 注解的定义\n\n注解的语法格式如下：\n\npublic @interface 注解名 {定义体}\n\n\n我们来定义一个注解：\n\n@documented\n@target({elementtype.field, elementtype.parameter})\n@retention(retentionpolicy.runtime)\npublic @interface regexvalid {}\n\n\n> 说明：\n> \n> 通过上一节对于元注解 @target、@retention、@documented 的说明，这里就很容易理解了。\n> \n>  * 上面的代码中定义了一个名为 @regexvalid 的注解。\n>  * @documented 表示 @regexvalid 应该使用 javadoc。\n>  * @target({elementtype.field, elementtype.parameter}) 表示 @regexvalid 可以在类成员或方法参数上修饰。\n>  * @retention(retentionpolicy.runtime) 表示 @regexvalid 在运行时有效。\n\n此时，我们已经定义了一个没有任何属性的注解，如果到此为止，它仅仅是一个标记注解。作为正则工具，没有属性可什么也做不了。接下来，我们将为它添加注解属性。\n\n\n# 注解属性\n\n注解属性的语法形式如下：\n\n[访问级别修饰符] [数据类型] 名称() default 默认值;\n\n\n例如，我们要定义在注解中定义一个名为 value 的字符串属性，其默认值为空字符串，访问级别为默认级别，那么应该定义如下：\n\nstring value() default "";\n\n\n> 🔔 注意：在注解中，我们定义属性时，属性名后面需要加 ()。\n\n定义注解属性有以下要点：\n\n * 注解属性只能使用 public 或默认访问级别（即不指定访问级别修饰符）修饰。\n\n * 注解属性的数据类型有限制要求。支持的数据类型如下：\n   \n   * 所有基本数据类型（byte、char、short、int、long、float、double、boolean）\n   * string 类型\n   * class 类\n   * enum 类型\n   * annotation 类型\n   * 以上所有类型的数组\n\n * 注解属性必须有确定的值，建议指定默认值。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。\n\n * 如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。\n\n// 这两种方式效果相同\n@regexvalid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n@regexvalid(value = "^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n\n\n示例：\n\n了解了注解属性的定义要点，让我们来为 @regexvalid 注解定义几个属性。\n\n@documented\n@target({elementtype.field, elementtype.parameter})\n@retention(retentionpolicy.runtime)\npublic @interface regexvalid {\n    enum policy {\n        // @formatter:off\n        empty(null),\n        date("^(?:(?!0000)[0-9]{4}([-/.]?)(?:(?:0?[1-9]|1[0-2])\\\\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\\\\1"\n            + "(?:29|30)|(?:0?[13578]|1[02])\\\\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|"\n            + "(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\\\\2(?:29))$"),\n        mail("^[a-za-z0-9](([_\\\\.\\\\-]?[a-za-z0-9]+)*)@([a-za-z0-9]+)(([\\\\.\\\\-]?[a-za-z0-9]+)*)\\\\.([a-za-z]{2,})$");\n        // @formatter:on\n\n        private string policy;\n\n        policy(string policy) {\n            this.policy = policy;\n        }\n\n        public string getpolicy() {\n            return policy;\n        }\n    }\n\n    string value() default "";\n    policy policy() default policy.empty;\n}\n\n\n> 说明：\n> \n> 在上面的示例代码中，我们定义了两个注解属性：string 类型的 value 属性和 policy 枚举类型的 policy 属性。policy 枚举中定义了几个默认的正则表达式，这是为了直接使用这几个常用表达式去正则校验。考虑到，我们可能需要自己传入一些自定义正则表达式去校验其他场景，所以定义了 value 属性，允许使用者传入正则表达式。\n\n至此，@regexvalid 的声明已经结束。但是，程序仍不知道如何处理 @regexvalid 这个注解。我们还需要定义注解处理器。\n\n\n# 注解处理器\n\n如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。jdk5 扩展了反射机制的 api，以帮助程序员快速的构造自定义注解处理器。\n\njava.lang.annotation.annotation 是一个接口，程序可以通过反射来获取指定程序元素的注解对象，然后通过注解对象来获取注解里面的元数据。\n\nannotation 接口源码如下：\n\npublic interface annotation {\n    boolean equals(object obj);\n\n    int hashcode();\n\n    string tostring();\n\n    class<? extends annotation> annotationtype();\n}\n\n\n除此之外，java 中支持注解处理器接口 java.lang.reflect.annotatedelement ，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：\n\n * class - 类定义\n * constructor - 构造器定义\n * field - 累的成员变量定义\n * method - 类的方法定义\n * package - 类的包定义\n\njava.lang.reflect 包下主要包含一些实现反射功能的工具类。实际上，java.lang.reflect 包所有提供的反射 api 扩充了读取运行时注解信息的能力。当一个注解类型被定义为运行时的注解后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的注解才会被虚拟机读取。 annotatedelement 接口是所有程序元素（class、method 和 constructor）的父接口，所以程序通过反射获取了某个类的annotatedelement 对象之后，程序就可以调用该对象的如下四个个方法来访问注解信息：\n\n * getannotation - 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回 null。\n * getannotations - 返回该程序元素上存在的所有注解。\n * isannotationpresent - 判断该程序元素上是否包含指定类型的注解，存在则返回 true，否则返回 false。\n * getdeclaredannotations - 返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。\n\n了解了以上内容，让我们来实现 @regexvalid 的注解处理器：\n\nimport java.lang.reflect.field;\nimport java.util.regex.matcher;\nimport java.util.regex.pattern;\n\npublic class regexvalidutil {\n    public static boolean check(object obj) throws exception {\n        boolean result = true;\n        stringbuilder sb = new stringbuilder();\n        field[] fields = obj.getclass().getdeclaredfields();\n        for (field field : fields) {\n            // 判断成员是否被 @regexvalid 注解所修饰\n            if (field.isannotationpresent(regexvalid.class)) {\n                regexvalid valid = field.getannotation(regexvalid.class);\n\n                // 如果 value 为空字符串，说明没有注入自定义正则表达式，改用 policy 属性\n                string value = valid.value();\n                if ("".equals(value)) {\n                    regexvalid.policy policy = valid.policy();\n                    value = policy.getpolicy();\n                }\n\n                // 通过设置 setaccessible(true) 来访问私有成员\n                field.setaccessible(true);\n                object fieldobj = null;\n                try {\n                    fieldobj = field.get(obj);\n                } catch (illegalaccessexception e) {\n                    e.printstacktrace();\n                }\n                if (fieldobj == null) {\n                    sb.append("\\n")\n                        .append(string.format("%s 类中的 %s 字段不能为空！", obj.getclass().getname(), field.getname()));\n                    result = false;\n                } else {\n                    if (fieldobj instanceof string) {\n                        string text = (string) fieldobj;\n                        pattern p = pattern.compile(value);\n                        matcher m = p.matcher(text);\n                        result = m.matches();\n                        if (!result) {\n                            sb.append("\\n").append(string.format("%s 不是合法的 %s ！", text, field.getname()));\n                        }\n                    } else {\n                        sb.append("\\n").append(\n                            string.format("%s 类中的 %s 字段不是字符串类型，不能使用此注解校验！", obj.getclass().getname(), field.getname()));\n                        result = false;\n                    }\n                }\n            }\n        }\n\n        if (sb.length() > 0) {\n            throw new exception(sb.tostring());\n        }\n        return result;\n    }\n}\n\n\n> 说明：\n> \n> 以上示例中的注解处理器，执行步骤如下：\n> \n>  1. 通过 getdeclaredfields 反射方法获取传入对象的所有成员。\n>  2. 遍历成员，使用 isannotationpresent 判断成员是否被指定注解所修饰，如果不是，直接跳过。\n>  3. 如果成员被注解所修饰，通过 regexvalid valid = field.getannotation(regexvalid.class); 这样的形式获取，注解实例化对象，然后，就可以使用 valid.value() 或 valid.policy() 这样的形式获取注解中设定的属性值。\n>  4. 根据属性值，进行逻辑处理。\n\n\n# 使用注解\n\n完成了以上工作，我们就可以使用自定义注解了，示例如下：\n\npublic class regexvaliddemo {\n    static class user {\n        private string name;\n        @regexvalid(policy = regexvalid.policy.date)\n        private string date;\n        @regexvalid(policy = regexvalid.policy.mail)\n        private string mail;\n        @regexvalid("^((\\\\+)?86\\\\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\\\\d{8}$")\n        private string phone;\n\n        public user(string name, string date, string mail, string phone) {\n            this.name = name;\n            this.date = date;\n            this.mail = mail;\n            this.phone = phone;\n        }\n\n        @override\n        public string tostring() {\n            return "user{" + "name=\'" + name + \'\\\'\' + ", date=\'" + date + \'\\\'\' + ", mail=\'" + mail + \'\\\'\' + ", phone=\'"\n                + phone + \'\\\'\' + \'}\';\n        }\n    }\n\n    static void printdate(@regexvalid(policy = regexvalid.policy.date) string date){\n        system.out.println(date);\n    }\n\n    public static void main(string[] args) throws exception {\n        user user = new user("tom", "1990-01-31", "xxx@163.com", "18612341234");\n        user user2 = new user("jack", "2019-02-29", "sadhgs", "183xxxxxxxx");\n        if (regexvalidutil.check(user)) {\n            system.out.println(user + "正则校验通过");\n        }\n        if (regexvalidutil.check(user2)) {\n            system.out.println(user2 + "正则校验通过");\n        }\n    }\n}\n\n\n\n# 小结\n\n\n\n\n\n\n\n\n\n\n# 参考资料\n\n * java 编程思想\n * java 核心技术（卷 1）\n * effective java\n * oracle 官方文档之注解篇\n * 深入理解 java：注解（annotation）自定义注解入门\n * https://blog.csdn.net/briblue/article/details/73824058',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Overview",frontmatter:{title:"Overview",date:"2022-06-22T14:58:53.000Z",permalink:"/pages/7ea877/"},regularPath:"/0102.Java%20%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/01.Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/01.Overview.html",relativePath:"0102.Java 版本特性/01.Java 8 新特性/01.Overview.md",key:"v-6ed74962",path:"/pages/7ea877/",headers:[{level:3,title:"特性列表",slug:"特性列表",normalizedTitle:"特性列表",charIndex:2}],headersStr:"特性列表",content:"# 特性列表\n\n * Lambda 表达式\n * Optional",normalizedContent:"# 特性列表\n\n * lambda 表达式\n * optional",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"深入理解 Java String 类型",frontmatter:{title:"深入理解 Java String 类型",date:"2020-12-25T18:43:11.000Z",categories:["Java","JavaSE","基础特性"],tags:["Java","JavaSE","工具类","字符串"],permalink:"/pages/bc583c/",abbrlink:"a673a8"},regularPath:"/0101.Java%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/01.Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/42.JavaString%E7%B1%BB%E5%9E%8B.html",relativePath:"0101.Java 核心知识/01.Java 基础知识/42.JavaString类型.md",key:"v-8a5f2b9e",path:"/pages/bc583c/",headers:[{level:2,title:"String 的不可变性",slug:"string-的不可变性",normalizedTitle:"string 的不可变性",charIndex:119},{level:2,title:"String 的性能考量",slug:"string-的性能考量",normalizedTitle:"string 的性能考量",charIndex:929},{level:3,title:"字符串拼接",slug:"字符串拼接",normalizedTitle:"字符串拼接",charIndex:946},{level:3,title:"字符串分割",slug:"字符串分割",normalizedTitle:"字符串分割",charIndex:1696},{level:3,title:"String.intern",slug:"string-intern",normalizedTitle:"string.intern",charIndex:1903},{level:2,title:"String、StringBuffer、StringBuilder 有什么区别",slug:"string、stringbuffer、stringbuilder-有什么区别",normalizedTitle:"string、stringbuffer、stringbuilder 有什么区别",charIndex:2668},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3478}],headersStr:"String 的不可变性 String 的性能考量 字符串拼接 字符串分割 String.intern String、StringBuffer、StringBuilder 有什么区别 参考资料",content:'# 深入理解 Java String 类型\n\n> String 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。\n\n\n# String 的不可变性\n\n我们先来看下 String 的定义：\n\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n\nString 类被 final 关键字修饰，表示不可继承 String 类。\n\nString 类的数据存储于 char[] 数组，这个数组被 final 关键字修饰，表示 String 对象不可被更改。\n\n为什么 Java 要这样设计？\n\n（1）保证 String 对象安全性。避免 String 被篡改。\n\n（2）保证 hash 值不会频繁变更。\n\n（3）可以实现字符串常量池。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str="abc"; 另一种是字符串变量通过 new 形式的创建，如 String str = new String("abc")。\n\n使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。\n\nString str = new String("abc") 这种方式，首先在编译类文件时，"abc" 常量字符串将会放入到常量结构中，在类加载时，"abc" 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的 "abc" 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。\n\n\n# String 的性能考量\n\n\n# 字符串拼接\n\n字符串常量的拼接，编译器会将其优化为一个常量字符串。\n\n【示例】字符串常量拼接\n\npublic static void main(String[] args) {\n    // 本行代码在 class 文件中，会被编译器直接优化为：\n    // String str = "abc";\n    String str = "a" + "b" + "c";\n    System.out.println("str = " + str);\n}\n\n\n字符串变量的拼接，编译器会优化成 StringBuilder 的方式。\n\n【示例】字符串变量的拼接\n\npublic static void main(String[] args) {\n    String str = "";\n    for(int i=0; i<1000; i++) {\n        // 本行代码会被编译器优化为：\n        // str = (new StringBuilder(String.valueOf(str))).append(i).toString();\n        str = str + i;\n    }\n}\n\n\n但是，每次循环都会生成一个新的 StringBuilder 实例，同样也会降低系统的性能。\n\n字符串拼接的正确方案：\n\n * 如果需要使用字符串拼接，应该优先考虑 StringBuilder 的 append 方法替代使用 + 号。\n * 如果在并发编程中，String 对象的拼接涉及到线程安全，可以使用 StringBuffer。但是要注意，由于 StringBuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 StringBuilder 差一些。\n\n\n# 字符串分割\n\nString 的 split() 方法使用正则表达式实现其强大的分割功能。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。\n\n所以，应该慎重使用 split() 方法，可以考虑用 String.indexOf() 方法代替 split() 方法完成字符串的分割。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。\n\n\n# String.intern\n\n在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。\n\n在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。\n\n如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。\n\n【示例】\n\npublic class SharedLocation {\n\n\tprivate String city;\n\tprivate String region;\n\tprivate String countryCode;\n}\n\nSharedLocation sharedLocation = new SharedLocation();\nsharedLocation.setCity(messageInfo.getCity().intern());\t\tsharedLocation.setCountryCode(messageInfo.getRegion().intern());\nsharedLocation.setRegion(messageInfo.getCountryCode().intern());\n\n\n> 使用 intern 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。\n\n\n# String、StringBuffer、StringBuilder 有什么区别\n\nString 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。\n\nStringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 是一个线程安全的可修改字符序列。StringBuffer 的线程安全是通过在各种修改数据的方法上用 synchronized 关键字修饰实现的。\n\nStringBuilder 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。\n\nStringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。\n\n除非有线程安全的需要，不然一般都使用 StringBuilder。\n\n\n# 参考资料\n\n * 《Java 编程思想（Thinking in java）》\n * 《Java 核心技术 卷 I 基础知识》\n * 《Java 性能调优实战》\n * 《Java 核心技术面试精讲》\n * Java 基本数据类型和引用类型\n * 深入剖析 Java 中的装箱和拆箱',normalizedContent:'# 深入理解 java string 类型\n\n> string 类型可能是 java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。\n\n\n# string 的不可变性\n\n我们先来看下 string 的定义：\n\npublic final class string\n    implements java.io.serializable, comparable<string>, charsequence {\n    /** the value is used for character storage. */\n    private final char value[];\n\n\nstring 类被 final 关键字修饰，表示不可继承 string 类。\n\nstring 类的数据存储于 char[] 数组，这个数组被 final 关键字修饰，表示 string 对象不可被更改。\n\n为什么 java 要这样设计？\n\n（1）保证 string 对象安全性。避免 string 被篡改。\n\n（2）保证 hash 值不会频繁变更。\n\n（3）可以实现字符串常量池。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 string str="abc"; 另一种是字符串变量通过 new 形式的创建，如 string str = new string("abc")。\n\n使用第一种方式创建字符串对象时，jvm 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。\n\nstring str = new string("abc") 这种方式，首先在编译类文件时，"abc" 常量字符串将会放入到常量结构中，在类加载时，"abc" 将会在常量池中创建；其次，在调用 new 时，jvm 命令将会调用 string 的构造函数，同时引用常量池中的 "abc" 字符串，在堆内存中创建一个 string 对象；最后，str 将引用 string 对象。\n\n\n# string 的性能考量\n\n\n# 字符串拼接\n\n字符串常量的拼接，编译器会将其优化为一个常量字符串。\n\n【示例】字符串常量拼接\n\npublic static void main(string[] args) {\n    // 本行代码在 class 文件中，会被编译器直接优化为：\n    // string str = "abc";\n    string str = "a" + "b" + "c";\n    system.out.println("str = " + str);\n}\n\n\n字符串变量的拼接，编译器会优化成 stringbuilder 的方式。\n\n【示例】字符串变量的拼接\n\npublic static void main(string[] args) {\n    string str = "";\n    for(int i=0; i<1000; i++) {\n        // 本行代码会被编译器优化为：\n        // str = (new stringbuilder(string.valueof(str))).append(i).tostring();\n        str = str + i;\n    }\n}\n\n\n但是，每次循环都会生成一个新的 stringbuilder 实例，同样也会降低系统的性能。\n\n字符串拼接的正确方案：\n\n * 如果需要使用字符串拼接，应该优先考虑 stringbuilder 的 append 方法替代使用 + 号。\n * 如果在并发编程中，string 对象的拼接涉及到线程安全，可以使用 stringbuffer。但是要注意，由于 stringbuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 stringbuilder 差一些。\n\n\n# 字符串分割\n\nstring 的 split() 方法使用正则表达式实现其强大的分割功能。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 cpu 居高不下。\n\n所以，应该慎重使用 split() 方法，可以考虑用 string.indexof() 方法代替 split() 方法完成字符串的分割。如果实在无法满足需求，你就在使用 split() 方法时，对回溯问题加以重视就可以了。\n\n\n# string.intern\n\n在每次赋值的时候使用 string 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。\n\n在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。\n\n如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。\n\n【示例】\n\npublic class sharedlocation {\n\n\tprivate string city;\n\tprivate string region;\n\tprivate string countrycode;\n}\n\nsharedlocation sharedlocation = new sharedlocation();\nsharedlocation.setcity(messageinfo.getcity().intern());\t\tsharedlocation.setcountrycode(messageinfo.getregion().intern());\nsharedlocation.setregion(messageinfo.getcountrycode().intern());\n\n\n> 使用 intern 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 hashtable 的实现方式，hashtable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。\n\n\n# string、stringbuffer、stringbuilder 有什么区别\n\nstring 是 java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 string 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。\n\nstringbuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。stringbuffer 是一个线程安全的可修改字符序列。stringbuffer 的线程安全是通过在各种修改数据的方法上用 synchronized 关键字修饰实现的。\n\nstringbuilder 是 java 1.5 中新增的，在能力上和 stringbuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。\n\nstringbuffer 和 stringbuilder 底层都是利用可修改的（char，jdk 9 以后是 byte）数组，二者都继承了 abstractstringbuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。\n\n除非有线程安全的需要，不然一般都使用 stringbuilder。\n\n\n# 参考资料\n\n * 《java 编程思想（thinking in java）》\n * 《java 核心技术 卷 i 基础知识》\n * 《java 性能调优实战》\n * 《java 核心技术面试精讲》\n * java 基本数据类型和引用类型\n * 深入剖析 java 中的装箱和拆箱',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Lambda 表达式",frontmatter:{title:"Lambda 表达式",date:"2022-06-22T14:59:16.000Z",permalink:"/pages/81ea3b/"},regularPath:"/0102.Java%20%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/01.Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/02.Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"0102.Java 版本特性/01.Java 8 新特性/02.Lambda 表达式.md",key:"v-153cf32e",path:"/pages/81ea3b/",headers:[{level:2,title:"源码解读",slug:"源码解读",normalizedTitle:"源码解读",charIndex:220},{level:2,title:"JDK 定义的常用函数式接口",slug:"jdk-定义的常用函数式接口",normalizedTitle:"jdk 定义的常用函数式接口",charIndex:4008},{level:2,title:"使用场景示例",slug:"使用场景示例",normalizedTitle:"使用场景示例",charIndex:4828},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:8888}],headersStr:"源码解读 JDK 定义的常用函数式接口 使用场景示例 总结",content:'# 函数式编程（Lambda表达式）\n\n提示\n\nLambda 表达式作为 Java 8 的一部分被引入 Java 语言。术语lambda 表达式来自lambda 演算，指的是您创建并作为参数传递给另一个方法的匿名方法（函数式编程中使用的一种流行技术）。一旦您理解了语法，您将看到 Java lambda 表达式如何让您在不牺牲可读性的情况下编写更紧凑的 Java 代码（一些人认为，lambda 表达式的简单性使代码更具可读性）。\n\n\n# 源码解读\n\n我们一步步来理解Lambda，我们先上先上Java 8的函数式接口的注解的源码\n\n/**\n * An informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the Java Language Specification.\n *\n * Conceptually, a functional interface has exactly one abstract\n * method.  Since {@linkplain java.lang.reflect.Method#isDefault()\n * default methods} have an implementation, they are not abstract.  If\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.Object}, that also does\n * <em>not</em> count toward the interface\'s abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.Object} or elsewhere.\n *\n * <p>Note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>If a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> The type is an interface type and not an annotation type, enum, or class.\n * <li> The annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>However, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code FunctionalInterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. The Class Object\n * @jls 9.8 Functional Interfaces\n * @jls 9.4.3 Interface Method Body\n * @since 1.8\n */\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface FunctionalInterface {}\n\n\n我们主要从注释的内容解析，注释中对函数式接口定义是，该注解作用于接口，且该接口有且只能有一个抽象方法，可以有多个默认方法，例如JDK 1.8中自带的Consumer接口定义如下：\n\n/**\n * Represents an operation that accepts a single input argument and returns no\n * result. Unlike most other functional interfaces, {@code Consumer} is expected\n * to operate via side-effects.\n *\n * <p>This is a <a href="package-summary.html">functional interface</a>\n * whose functional method is {@link #accept(Object)}.\n *\n * @param <T> the type of the input to the operation\n *\n * @since 1.8\n */\n@FunctionalInterface\npublic interface Consumer<T> {\n\n    /**\n     * Performs this operation on the given argument.\n     *\n     * @param t the input argument\n     */\n    void accept(T t);\n\n    /**\n     * Returns a composed {@code Consumer} that performs, in sequence, this\n     * operation followed by the {@code after} operation. If performing either\n     * operation throws an exception, it is relayed to the caller of the\n     * composed operation.  If performing this operation throws an exception,\n     * the {@code after} operation will not be performed.\n     *\n     * @param after the operation to perform after this operation\n     * @return a composed {@code Consumer} that performs in sequence this\n     * operation followed by the {@code after} operation\n     * @throws NullPointerException if {@code after} is null\n     */\n    default Consumer<T> andThen(Consumer<? super T> after) {\n        Objects.requireNonNull(after);\n        return (T t) -> { accept(t); after.accept(t); };\n    }\n}\n\n\n函数式接口定义并非一定要用注解@FunctionalInterface，只要符合函数式接口定义即可，但是实际场景中@FunctionalInterface还是要加上，提示团队中的开发小伙伴，避免小伙伴们误拓展了接口，导致函数接口失效。\n\n同时函数式接口不仅仅可用于lambda表达式，还可以用于方法引用或函数构造引用，下面使用常用的集合来体验一下：\n\n// forEach内就是一个lambda表达式\nList<String> list = new ArrayList<>();\nlist.forEach(e -> {\n    // TODO 业务操作...\n    System.out.println(e);\n});\n// 如果是简单的表达式，可以缩写如下\nList<String> list = new ArrayList<>();\nlist.forEach(e -> System.out.println(e));\n// 方法引用写法如下\nList<String> list = new ArrayList<>();\nlist.forEach(System.out::println);\n// 构造器引用（Supplier下面会有说明）\nSupplier<String> supplier = String::new;\nString s = supplier.get();\n\n\n\n# JDK 定义的常用函数式接口\n\nJDK 1.8 有提供了一部分函数式接口定义，下面列举常用的几个接口如下（java.util.function 包下是Java8预定义的一些函数接口，当然不止这些，还有其他接口也有使用，例如Runnable就是很好的例子）：\n\n接口名                 参数类型   返回类型      抽象方法名    描述               其他方法\nConsumer<T>         T      void      accept   处理一个T类型的值        andThen\nFunction<T,R>       T      R         apply    有一个T类型参数的函数      compose,andThen,identity\nSupplier<T>         无      T         get      提供一个T类型的值        无\nPredicate<T>        T      boolean   test     返回布尔值的函数         and,or,negate,isEqual\nBiConsumer<T,U>     T,U    void      accept   处理T和U类型的值        andThen\nBiFunction<T,U,R>   T,U    R         apply    有T和U类型参数的函数      compose,andThen,identity\nBiPredicate<T,U>    T,U    boolean   test     返回布尔值的函数         and,or,negate,isEqual\nRunnable            无      void      run      作为无参数或返回值的动作运行   无\n\n\n# 使用场景示例\n\n我们来个使用场景来上手一下（这里使用Consumer）：场景定义->定义一个手机工具类，传入区号（+86）和手机号（15300000000），拨打电话前执行一些业务逻辑，然后拨打电话，代码如下：\n\n/**\n * 首先定义一个电话工具类\n * \n * @author ZhcChen\n * @since 2022-04-14 14:11:10\n */\n@Data\npublic class PhoneUtil {\n    private String code;\n    private String phoneNumber;\n\n    private PhoneUtil(String code, String phoneNumber) {\n        this.code = code;\n        this.phoneNumber = phoneNumber;\n    }\n\n    public static PhoneUtil of(String code, String phoneNumber) {\n        return new PhoneUtil(code, phoneNumber);\n    }\n\n    public void call(Consumer<PhoneUtil> consumer) {\n        consumer.accept(this);\n        // TODO 这里省略工具内部的检查号码逻辑\n        // ...\n        // TODO 这里省略调用打电话逻辑...\n        // ...\n    }\n}\n\n\n// 拨打电话\nPhoneUtil.of("+86", "15300000000")\n        .call(phone -> {\n            // TODO 可能根据业务需要，比如一些黑名单用户无法拨打，这里省略判断黑名单用户逻辑\n            // ...\n            // TODO 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等，这里省略发送推荐广告短信等操作\n            // ...\n        });\n\n\n然后，其实这个场景是通过抛出业务异常来中断，实际中，可能我要求不抛出异常，只是没有达到业务条件下仅仅不拨打电话，那消费型的Consumer就不符合我们的需要了，我们根据上面的这个表格看，Predicate有返回标识能满足我们的需求，调整代码如下：\n\n@Data\npublic class PhoneUtil {\n    private String code;\n    private String phoneNumber;\n\n    private PhoneUtil(String code, String phoneNumber) {\n        this.code = code;\n        this.phoneNumber = phoneNumber;\n    }\n\n    public static PhoneUtil of(String code, String phoneNumber) {\n        return new PhoneUtil(code, phoneNumber);\n    }\n\n    public void call(Predicate<PhoneUtil> predicate) {\n        if (predicate.test(this)) {\n            // TODO 这里省略工具内部的检查号码逻辑\n            // ...\n            // TODO 这里省略调用打电话逻辑...\n            // ...\n        }\n    }\n}\n\n\nPhoneUtil.of("+86", "15300000000")\n        .call(phone -> {\n            boolean flag = false;\n            // TODO 可能根据业务需要，比如一些黑名单用户无法拨打\n            // 这里省略判断黑名单用户...，通过操作flag标记\n            // TODO 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等\n            // 这里省略发送推荐广告短信等操作...\n            return flag;\n        });\n\n\n函数式编程（Lambda）简单理解就是，通过定义函数接口，使用时实现函数接口定义的具体逻辑，以Consumer来说，其实就是简单的接收phone参数，然后自定义业务（当然也可以什么都不做），对于有返回值类型的Predicate，相比于Consumer来说就是多了返回参数boolean。\n\n上面我们都是用预定义的函数接口，那我们再来拓展一下上面的场景：原先操作的只有PhoneUtil，我们对工具内做个拓展，根据手机号，对应查询到用户信息和对这个用户已拨打的记录。代码如下：\n\n/**\n * 用户信息类\n * \n * @author ZhcChen\n * @since 2022-04-15 11:00:02\n */\n@Data\npublic class UserInfo {\n\n    private String userName;\n    private Integer age;\n    // ...等等其他字段省略\n\n}\n\n\n/**\n * 拨打记录\n * \n * @author ZhcChen\n * @since 2022-04-15 11:01:29\n */\n@Data\npublic class CallRecord {\n\n    private Date callDateTime;\n    private Long callDuration;\n    // ...等等其他拨打的记录信息省略\n\n}\n\n\n/**\n * 自定义多参数函数接口\n *\n * @author ZhcChen\n * @since 2022-04-15 10:57:29\n */\n@FunctionalInterface\npublic interface CustomPredicate<A, B, C> {\n\n    boolean test(A a, B b, C c);\n\n}\n\n\n/**\n * 首先定义一个电话工具类\n *\n * @author ZhcChen\n * @since 2022-04-14 14:11:10\n */\n@Data\npublic class PhoneUtil {\n    private String code;\n    private String phoneNumber;\n\n    private PhoneUtil(String code, String phoneNumber) {\n        this.code = code;\n        this.phoneNumber = phoneNumber;\n    }\n\n    public static PhoneUtil of(String code, String phoneNumber) {\n        return new PhoneUtil(code, phoneNumber);\n    }\n\n    public void call(CustomPredicate<PhoneUtil, UserInfo, List<CallRecord>> predicate) {\n        // 这里实际根据手机号从数据库中查询出来的数据，省略对应步骤\n        UserInfo userInfo = new UserInfo();\n        List<CallRecord> callRecordList = new ArrayList<>();\n        // 执行原型逻辑\n        if (predicate.test(this, userInfo, callRecordList)) {\n            // TODO 这里省略工具内部的检查号码逻辑\n            // ...\n            // TODO 这里省略调用打电话逻辑...\n            // ...\n        }\n    }\n}\n\n\n// 参数列表里面就多了我们需要的拓展信息对象userInfo和callRecordList\nPhoneUtil.of("+86", "15300000000")\n        .call((phone, userInfo, callRecordList) -> {\n            boolean flag = false;\n            // TODO 可能根据业务需要，比如一些黑名单用户无法拨打\n            // 这里省略判断黑名单用户...，通过操作flag标记\n            // TODO 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等\n            // 这里省略发送推荐广告短信等操作...\n            // TODO 这里根据用户信息userInfo和拨打记录callRecordList拓展业务\n            // 这里省略拓展业务逻辑...\n            return flag;\n        });\n\n\n\n# 总结\n\n上面的场景仅仅是对Lambda简单使用的例子，如果做不到理解的同学可以对前后的流程重新过一遍，明确函数接口的前后提供了什么，对比以前传统有什么区别，每个的理解点不同。同时我也推荐可以结合下章节的Optional类来理解学习，Optional也使用了函数式编程的思想。',normalizedContent:'# 函数式编程（lambda表达式）\n\n提示\n\nlambda 表达式作为 java 8 的一部分被引入 java 语言。术语lambda 表达式来自lambda 演算，指的是您创建并作为参数传递给另一个方法的匿名方法（函数式编程中使用的一种流行技术）。一旦您理解了语法，您将看到 java lambda 表达式如何让您在不牺牲可读性的情况下编写更紧凑的 java 代码（一些人认为，lambda 表达式的简单性使代码更具可读性）。\n\n\n# 源码解读\n\n我们一步步来理解lambda，我们先上先上java 8的函数式接口的注解的源码\n\n/**\n * an informative annotation type used to indicate that an interface\n * type declaration is intended to be a <i>functional interface</i> as\n * defined by the java language specification.\n *\n * conceptually, a functional interface has exactly one abstract\n * method.  since {@linkplain java.lang.reflect.method#isdefault()\n * default methods} have an implementation, they are not abstract.  if\n * an interface declares an abstract method overriding one of the\n * public methods of {@code java.lang.object}, that also does\n * <em>not</em> count toward the interface\'s abstract method count\n * since any implementation of the interface will have an\n * implementation from {@code java.lang.object} or elsewhere.\n *\n * <p>note that instances of functional interfaces can be created with\n * lambda expressions, method references, or constructor references.\n *\n * <p>if a type is annotated with this annotation type, compilers are\n * required to generate an error message unless:\n *\n * <ul>\n * <li> the type is an interface type and not an annotation type, enum, or class.\n * <li> the annotated type satisfies the requirements of a functional interface.\n * </ul>\n *\n * <p>however, the compiler will treat any interface meeting the\n * definition of a functional interface as a functional interface\n * regardless of whether or not a {@code functionalinterface}\n * annotation is present on the interface declaration.\n *\n * @jls 4.3.2. the class object\n * @jls 9.8 functional interfaces\n * @jls 9.4.3 interface method body\n * @since 1.8\n */\n@documented\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\npublic @interface functionalinterface {}\n\n\n我们主要从注释的内容解析，注释中对函数式接口定义是，该注解作用于接口，且该接口有且只能有一个抽象方法，可以有多个默认方法，例如jdk 1.8中自带的consumer接口定义如下：\n\n/**\n * represents an operation that accepts a single input argument and returns no\n * result. unlike most other functional interfaces, {@code consumer} is expected\n * to operate via side-effects.\n *\n * <p>this is a <a href="package-summary.html">functional interface</a>\n * whose functional method is {@link #accept(object)}.\n *\n * @param <t> the type of the input to the operation\n *\n * @since 1.8\n */\n@functionalinterface\npublic interface consumer<t> {\n\n    /**\n     * performs this operation on the given argument.\n     *\n     * @param t the input argument\n     */\n    void accept(t t);\n\n    /**\n     * returns a composed {@code consumer} that performs, in sequence, this\n     * operation followed by the {@code after} operation. if performing either\n     * operation throws an exception, it is relayed to the caller of the\n     * composed operation.  if performing this operation throws an exception,\n     * the {@code after} operation will not be performed.\n     *\n     * @param after the operation to perform after this operation\n     * @return a composed {@code consumer} that performs in sequence this\n     * operation followed by the {@code after} operation\n     * @throws nullpointerexception if {@code after} is null\n     */\n    default consumer<t> andthen(consumer<? super t> after) {\n        objects.requirenonnull(after);\n        return (t t) -> { accept(t); after.accept(t); };\n    }\n}\n\n\n函数式接口定义并非一定要用注解@functionalinterface，只要符合函数式接口定义即可，但是实际场景中@functionalinterface还是要加上，提示团队中的开发小伙伴，避免小伙伴们误拓展了接口，导致函数接口失效。\n\n同时函数式接口不仅仅可用于lambda表达式，还可以用于方法引用或函数构造引用，下面使用常用的集合来体验一下：\n\n// foreach内就是一个lambda表达式\nlist<string> list = new arraylist<>();\nlist.foreach(e -> {\n    // todo 业务操作...\n    system.out.println(e);\n});\n// 如果是简单的表达式，可以缩写如下\nlist<string> list = new arraylist<>();\nlist.foreach(e -> system.out.println(e));\n// 方法引用写法如下\nlist<string> list = new arraylist<>();\nlist.foreach(system.out::println);\n// 构造器引用（supplier下面会有说明）\nsupplier<string> supplier = string::new;\nstring s = supplier.get();\n\n\n\n# jdk 定义的常用函数式接口\n\njdk 1.8 有提供了一部分函数式接口定义，下面列举常用的几个接口如下（java.util.function 包下是java8预定义的一些函数接口，当然不止这些，还有其他接口也有使用，例如runnable就是很好的例子）：\n\n接口名                 参数类型   返回类型      抽象方法名    描述               其他方法\nconsumer<t>         t      void      accept   处理一个t类型的值        andthen\nfunction<t,r>       t      r         apply    有一个t类型参数的函数      compose,andthen,identity\nsupplier<t>         无      t         get      提供一个t类型的值        无\npredicate<t>        t      boolean   test     返回布尔值的函数         and,or,negate,isequal\nbiconsumer<t,u>     t,u    void      accept   处理t和u类型的值        andthen\nbifunction<t,u,r>   t,u    r         apply    有t和u类型参数的函数      compose,andthen,identity\nbipredicate<t,u>    t,u    boolean   test     返回布尔值的函数         and,or,negate,isequal\nrunnable            无      void      run      作为无参数或返回值的动作运行   无\n\n\n# 使用场景示例\n\n我们来个使用场景来上手一下（这里使用consumer）：场景定义->定义一个手机工具类，传入区号（+86）和手机号（15300000000），拨打电话前执行一些业务逻辑，然后拨打电话，代码如下：\n\n/**\n * 首先定义一个电话工具类\n * \n * @author zhcchen\n * @since 2022-04-14 14:11:10\n */\n@data\npublic class phoneutil {\n    private string code;\n    private string phonenumber;\n\n    private phoneutil(string code, string phonenumber) {\n        this.code = code;\n        this.phonenumber = phonenumber;\n    }\n\n    public static phoneutil of(string code, string phonenumber) {\n        return new phoneutil(code, phonenumber);\n    }\n\n    public void call(consumer<phoneutil> consumer) {\n        consumer.accept(this);\n        // todo 这里省略工具内部的检查号码逻辑\n        // ...\n        // todo 这里省略调用打电话逻辑...\n        // ...\n    }\n}\n\n\n// 拨打电话\nphoneutil.of("+86", "15300000000")\n        .call(phone -> {\n            // todo 可能根据业务需要，比如一些黑名单用户无法拨打，这里省略判断黑名单用户逻辑\n            // ...\n            // todo 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等，这里省略发送推荐广告短信等操作\n            // ...\n        });\n\n\n然后，其实这个场景是通过抛出业务异常来中断，实际中，可能我要求不抛出异常，只是没有达到业务条件下仅仅不拨打电话，那消费型的consumer就不符合我们的需要了，我们根据上面的这个表格看，predicate有返回标识能满足我们的需求，调整代码如下：\n\n@data\npublic class phoneutil {\n    private string code;\n    private string phonenumber;\n\n    private phoneutil(string code, string phonenumber) {\n        this.code = code;\n        this.phonenumber = phonenumber;\n    }\n\n    public static phoneutil of(string code, string phonenumber) {\n        return new phoneutil(code, phonenumber);\n    }\n\n    public void call(predicate<phoneutil> predicate) {\n        if (predicate.test(this)) {\n            // todo 这里省略工具内部的检查号码逻辑\n            // ...\n            // todo 这里省略调用打电话逻辑...\n            // ...\n        }\n    }\n}\n\n\nphoneutil.of("+86", "15300000000")\n        .call(phone -> {\n            boolean flag = false;\n            // todo 可能根据业务需要，比如一些黑名单用户无法拨打\n            // 这里省略判断黑名单用户...，通过操作flag标记\n            // todo 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等\n            // 这里省略发送推荐广告短信等操作...\n            return flag;\n        });\n\n\n函数式编程（lambda）简单理解就是，通过定义函数接口，使用时实现函数接口定义的具体逻辑，以consumer来说，其实就是简单的接收phone参数，然后自定义业务（当然也可以什么都不做），对于有返回值类型的predicate，相比于consumer来说就是多了返回参数boolean。\n\n上面我们都是用预定义的函数接口，那我们再来拓展一下上面的场景：原先操作的只有phoneutil，我们对工具内做个拓展，根据手机号，对应查询到用户信息和对这个用户已拨打的记录。代码如下：\n\n/**\n * 用户信息类\n * \n * @author zhcchen\n * @since 2022-04-15 11:00:02\n */\n@data\npublic class userinfo {\n\n    private string username;\n    private integer age;\n    // ...等等其他字段省略\n\n}\n\n\n/**\n * 拨打记录\n * \n * @author zhcchen\n * @since 2022-04-15 11:01:29\n */\n@data\npublic class callrecord {\n\n    private date calldatetime;\n    private long callduration;\n    // ...等等其他拨打的记录信息省略\n\n}\n\n\n/**\n * 自定义多参数函数接口\n *\n * @author zhcchen\n * @since 2022-04-15 10:57:29\n */\n@functionalinterface\npublic interface custompredicate<a, b, c> {\n\n    boolean test(a a, b b, c c);\n\n}\n\n\n/**\n * 首先定义一个电话工具类\n *\n * @author zhcchen\n * @since 2022-04-14 14:11:10\n */\n@data\npublic class phoneutil {\n    private string code;\n    private string phonenumber;\n\n    private phoneutil(string code, string phonenumber) {\n        this.code = code;\n        this.phonenumber = phonenumber;\n    }\n\n    public static phoneutil of(string code, string phonenumber) {\n        return new phoneutil(code, phonenumber);\n    }\n\n    public void call(custompredicate<phoneutil, userinfo, list<callrecord>> predicate) {\n        // 这里实际根据手机号从数据库中查询出来的数据，省略对应步骤\n        userinfo userinfo = new userinfo();\n        list<callrecord> callrecordlist = new arraylist<>();\n        // 执行原型逻辑\n        if (predicate.test(this, userinfo, callrecordlist)) {\n            // todo 这里省略工具内部的检查号码逻辑\n            // ...\n            // todo 这里省略调用打电话逻辑...\n            // ...\n        }\n    }\n}\n\n\n// 参数列表里面就多了我们需要的拓展信息对象userinfo和callrecordlist\nphoneutil.of("+86", "15300000000")\n        .call((phone, userinfo, callrecordlist) -> {\n            boolean flag = false;\n            // todo 可能根据业务需要，比如一些黑名单用户无法拨打\n            // 这里省略判断黑名单用户...，通过操作flag标记\n            // todo 可能还有其他业务，比如拨打电话前的会给用户发送推荐广告短信等\n            // 这里省略发送推荐广告短信等操作...\n            // todo 这里根据用户信息userinfo和拨打记录callrecordlist拓展业务\n            // 这里省略拓展业务逻辑...\n            return flag;\n        });\n\n\n\n# 总结\n\n上面的场景仅仅是对lambda简单使用的例子，如果做不到理解的同学可以对前后的流程重新过一遍，明确函数接口的前后提供了什么，对比以前传统有什么区别，每个的理解点不同。同时我也推荐可以结合下章节的optional类来理解学习，optional也使用了函数式编程的思想。',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Overview",frontmatter:{title:"Overview",date:"2022-06-22T15:31:15.000Z",permalink:"/pages/bece42/"},regularPath:"/0103.JVM%20%E7%9B%B8%E5%85%B3/01.Java%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/01.Overview.html",relativePath:"0103.JVM 相关/01.Java 类加载机制/01.Overview.md",key:"v-677586e7",path:"/pages/bece42/",headers:[{level:2,title:"Overview",slug:"overview",normalizedTitle:"overview",charIndex:2}],headersStr:"Overview",content:"# Overview\n\n更新中...",normalizedContent:"# overview\n\n更新中...",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Optional",frontmatter:{title:"Optional",date:"2022-06-22T15:13:16.000Z",permalink:"/pages/ce7867/"},regularPath:"/0102.Java%20%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/01.Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/03.Optional.html",relativePath:"0102.Java 版本特性/01.Java 8 新特性/03.Optional.md",key:"v-17d42598",path:"/pages/ce7867/",headers:[{level:2,title:"Optional 详解",slug:"optional-详解",normalizedTitle:"optional 详解",charIndex:2},{level:2,title:"主要方法解析",slug:"主要方法解析",normalizedTitle:"主要方法解析",charIndex:258},{level:3,title:"empty",slug:"empty",normalizedTitle:"empty",charIndex:269},{level:3,title:"of",slug:"of",normalizedTitle:"of",charIndex:278},{level:3,title:"ofNullable",slug:"ofnullable",normalizedTitle:"ofnullable",charIndex:284},{level:3,title:"get",slug:"get",normalizedTitle:"get",charIndex:329},{level:3,title:"filter",slug:"filter",normalizedTitle:"filter",charIndex:336},{level:3,title:"flatMap",slug:"flatmap",normalizedTitle:"flatmap",charIndex:346},{level:3,title:"ifPresent",slug:"ifpresent",normalizedTitle:"ifpresent",charIndex:357},{level:3,title:"isPresent",slug:"ispresent",normalizedTitle:"ispresent",charIndex:370},{level:3,title:"map",slug:"map",normalizedTitle:"map",charIndex:383},{level:3,title:"orElse",slug:"orelse",normalizedTitle:"orelse",charIndex:390},{level:3,title:"orElseGet",slug:"orelseget",normalizedTitle:"orelseget",charIndex:400},{level:3,title:"orElseThrow",slug:"orelsethrow",normalizedTitle:"orelsethrow",charIndex:413},{level:2,title:"使用场景解析",slug:"使用场景解析",normalizedTitle:"使用场景解析",charIndex:4924},{level:3,title:"场景1：判定字符串是否包含abc字串",slug:"场景1-判定字符串是否包含abc字串",normalizedTitle:"场景1：判定字符串是否包含abc字串",charIndex:4935},{level:3,title:"场景2：有一栋楼，楼内有多间房间（有对应房间号），房间内有多台设备。根据对应房间号和设备id获取对应设备名称，不存在的返回设备不存在的值串。",slug:"场景2-有一栋楼-楼内有多间房间-有对应房间号-房间内有多台设备。根据对应房间号和设备id获取对应设备名称-不存在的返回设备不存在的值串。",normalizedTitle:"场景2：有一栋楼，楼内有多间房间（有对应房间号），房间内有多台设备。根据对应房间号和设备id获取对应设备名称，不存在的返回设备不存在的值串。",charIndex:5241},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6350}],headersStr:"Optional 详解 主要方法解析 empty of ofNullable get filter flatMap ifPresent isPresent map orElse orElseGet orElseThrow 使用场景解析 场景1：判定字符串是否包含abc字串 场景2：有一栋楼，楼内有多间房间（有对应房间号），房间内有多台设备。根据对应房间号和设备id获取对应设备名称，不存在的返回设备不存在的值串。 总结",content:'# Optional 详解\n\n提示\n\n粗心的使用null会导致各种各样的错误。通过研究 Google 代码库，我们发现 95% 的集合不应该包含任何 null 值，让它们快速失败而不是默默接受null对开发人员很有帮助。这句话是引用Google的Guava工具包对Optional的使用场景描述，是的没错，其他三方工具包已有对应实现，只是在Java 8上直接内置了对应类似实现——Optional。说白了Optional就是类似一个对象容器类，需要操作被托管对象时经过操作该容器，可以避免空指针的出现场景。\n\n\n# 主要方法解析\n\n * empty\n * of\n * ofNullable 【常用该静态方法创建Optional实例，进而使用以下方法】\n * get\n * filter\n * flatMap\n * ifPresent\n * isPresent\n * map\n * orElse\n * orElseGet\n * orElseThrow\n\n\n# empty\n\n提示\n\n返回一个空的 Optional实例。\n\n// 调用静态方法实例化\nOptional optional = Optional.empty();\n\n\n\n# of\n\n提示\n\n返回具有Optional的当前非空值的Optional实例，如果目前参数为null时抛出NullPointerException异常。\n\n// 调用静态方法实例化\nOptional optional = Optional.of("value");\n\n\n\n# ofNullable\n\n提示\n\n返回一个Optional指定值的Optional，如果非空（也就是允许空值传入），则返回一个空的Optional（其实就是重新调用了empty）。\n\n// 调用静态方法实例化\nOptional optional = Optional.ofNullable("value");\n// 调用静态方法实例化，null情况下实际内部重新调用了empty静态方法实例化\nOptional nullOptional = Optional.ofNullable(null);\n\n\n\n# get\n\n提示\n\n如果 Optional中有一个值，返回值，否则抛出 NoSuchElementException 。\n\n// 结果正常\nOptional<String> optional = Optional.ofNullable("value");\nString value = optional.get();\n// 运行时异常，抛出NoSuchElementException异常\nOptional<String> optional = Optional.ofNullable(null);\nString value = optional.get();\n\n\n\n# filter\n\n提示\n\n如果一个值存在，并且该值给定的值相匹配时，返回一个 Optional描述的值，否则返回一个空的 Optional 。\n\n// 输出 value\nOptional<String> optional = Optional.ofNullable("value");\nSystem.out.println(optional.filter(s -> s.equals("value")).get());\n// 运行时异常，抛出NoSuchElementException异常\nOptional<String> optional = Optional.ofNullable("value");\nSystem.out.println(optional.filter(s -> s.equals("default")).get());\n\n\n\n# flatMap\n\n提示\n\n如果一个值存在，应用提供的 Optional映射函数给它，返回该结果，否则返回一个空的 Optional 。\n\n// 输出 VALUE\nOptional<String> optional = Optional.ofNullable("value");\nSystem.out.println(optional.flatMap(s -> Optional.ofNullable(s.toUpperCase())).get());\n// 运行时异常，抛出NoSuchElementException异常\nOptional<String> optional = Optional.ofNullable(null);\nSystem.out.println(optional.flatMap(s -> Optional.ofNullable(s.toUpperCase())).get());\n\n\n\n# ifPresent\n\n提示\n\n如果存在值，则使用该值调用指定的消费者，否则不执行任何操作，该方法接收Consumer参数，以函数式形式编程。\n\n// 输出结果为value\nOptional<String> optional = Optional.ofNullable("value");\noptional.ifPresent(s -> System.out.println(s));\n// 没有输出结果，因为操作值为null，所以并不执行输出的代码段\nOptional<String> optional = Optional.ofNullable(null);\noptional.ifPresent(s -> System.out.println(s));\n\n\n\n# isPresent\n\n提示\n\n如果存在值返回 true，否则为 false 。\n\n// 结果为true\nOptional<String> optional = Optional.ofNullable("value");\nSystem.out.println(optional.isPresent());\n// 结果为false\nOptional<String> optional = Optional.ofNullable(null);\nSystem.out.println(optional.isPresent());\n\n\n\n# map\n\n提示\n\n如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 Optional结果的 Optional 。\n\n/**\n * 定义一个设备类\n * \n * @author ZhcChen\n * @since 2022-04-13 09:57:52\n */\n@Data\npublic class Device {\n    private Long deviceId;\n    private String deviceName;\n    private Integer deviceType;\n}\n\n\n// map其实就是通过一个lambda操作返回一个结果，放入一个新的Optional容器里面\nDevice device = new Device();\nOptional<Device> deviceOptional = Optional.ofNullable(device);\nOptional<String> deviceNameOptional = deviceOptional.map(d -> d.getDeviceName());\n\n\n// 实际我们就不需要一个新的容器，直接在返回的Optional直接操作就行了\nDevice device = new Device();\nOptional<Device> deviceOptional = Optional.ofNullable(device);\nString deviceName = deviceOptional.map(d -> {\n    if (d.getDeviceId() == null) {\n        return "暂无设备名称";\n    }\n    return d.getDeviceName();\n}).get();\n// 这里输出的是 暂无设备名称\nSystem.out.println(deviceName);\n\n\n\n# orElse\n\n提示\n\n返回值如果存在返回对应值，否则返回传入的参数值。\n\n// 输出结果为value\nOptional<String> optional = Optional.ofNullable("value");\nSystem.out.println(optional.orElse("default"));\n// 输出结果为default,因为Optional的值为null，相比于get，get是直接粗暴的抛出异常，当然也要根据业务场景选择合适方法\nOptional<String> optional = Optional.ofNullable(null);\nSystem.out.println(optional.orElse("default"));\n\n\n\n# orElseGet\n\n提示\n\n返回值如果存在返回对应值，否则调用对应方法（函数式接口参数）返回值。该方法类似于orElse，只不过orElseGet可以在lambda里面进行业务操作，然后返回值\n\n// 输出的结果为default，TODO的地方可以根据具体业务操作flag的状态\nOptional<String> optional = Optional.ofNullable(null);\nSystem.out.println(optional.orElseGet(() -> {\n    boolean flag = false;\n    // TODO 这里可以对flag一些业务操作\n    return flag ? "value" : "default";\n}));\n\n\n\n# orElseThrow\n\n提示\n\n返回值如果存在返回对应值，否则调用对应方法（函数式接口参数）抛出异常。该方法类似于orElseGet，只不过orElseThrow是值不存在时抛出异常（用户自己根据业务操作抛出对应异常）\n\n// 输出结果为 value,写了一大段，但是只要值不为null，则正常返回\nOptional<String> optional = Optional.ofNullable("value");\ntry {\n    System.out.println(optional.orElseThrow(() -> {\n        boolean flag = false;\n        // TODO 这里可以对flag一些业务操作\n        return flag ? new Exception("default") : null;\n    }));\n} catch (Exception e) {\n    System.out.println("e: " + e.getMessage());\n}\n\n\n// 输出结果为e: 异常B, 操作值为null，所有执行自定义返回的异常，并被try...catch捕获\nOptional<String> optional = Optional.ofNullable(null);\ntry {\n    System.out.println(optional.orElseThrow(() -> {\n        boolean flag = false;\n        // TODO 这里可以对flag一些业务操作\n        return flag ? new Exception("default") : null;\n    }));\n} catch (Exception e) {\n    System.out.println("e: " + e.getMessage());\n}\n\n\n\n# 使用场景解析\n\n\n# 场景1：判定字符串是否包含abc字串\n\n// 不使用Optional的写法如下\nString str = null;\nSystem.out.println(str == null ? false : str.indexOf("abc") != -1);\n// 使用Optional的写法如下\nString str = null;\nSystem.out.println(Optional.ofNullable(str).orElse("").indexOf("abc") != -1);\n\n\n这样看好像Optional的写法好像更长一些，一些简单的场景并不会提现Optional的优势，再往下看下一个场景\n\n\n# 场景2：有一栋楼，楼内有多间房间（有对应房间号），房间内有多台设备。根据对应房间号和设备id获取对应设备名称，不存在的返回设备不存在的值串。\n\n/**\n * 定义一个设备类\n *\n * @author ZhcChen\n * @since 2022-04-13 09:57:52\n */\n@Data\npublic class Device {\n    private Long deviceId;\n    private String deviceName;\n    private Integer deviceType;\n}\n\n\n// 假定上述描述的对应结构如下\nMap<String, Map<Long, Device>> roomMap = new HashMap<>(10);\n// 房间号\nString roomNo = "335";\n// 设备ID\nLong deviceId = 1L;\n// 不使用Optional的写法如下\nString result = "设备不存在";\nif (roomMap != null) {\n    Map<Long, Device> deviceMap = roomMap.get(roomNo);\n    if (deviceMap != null) {\n        Device device = deviceMap.get(deviceId);\n        if (device != null) {\n            String name = device.getDeviceName();\n            if (name != null) {\n                result = name;\n            }\n        }\n    }\n}\nSystem.out.println(result);\n// 使用Optional的写法如下\nSystem.out.println(\n        Optional.ofNullable(roomMap)\n                .map(rMap -> rMap.get(roomNo))\n                .map(dMap -> dMap.get(deviceId))\n                .map(Device::getDeviceName)\n                .orElse("设备不存在")\n);\n\n\n这样看下来就明显一点了，同时使用Optional的代码结构上少了一堆判断，看起来更加直观一些\n\n\n# 总结\n\nOptional适合的场景是从一些复杂的结构中获取自己想要的数据，可以省去众多if语句，让代码的可读性更高（前提是熟悉链式和函数式编程和稍微看下Optional常用的几个方法源码）',normalizedContent:'# optional 详解\n\n提示\n\n粗心的使用null会导致各种各样的错误。通过研究 google 代码库，我们发现 95% 的集合不应该包含任何 null 值，让它们快速失败而不是默默接受null对开发人员很有帮助。这句话是引用google的guava工具包对optional的使用场景描述，是的没错，其他三方工具包已有对应实现，只是在java 8上直接内置了对应类似实现——optional。说白了optional就是类似一个对象容器类，需要操作被托管对象时经过操作该容器，可以避免空指针的出现场景。\n\n\n# 主要方法解析\n\n * empty\n * of\n * ofnullable 【常用该静态方法创建optional实例，进而使用以下方法】\n * get\n * filter\n * flatmap\n * ifpresent\n * ispresent\n * map\n * orelse\n * orelseget\n * orelsethrow\n\n\n# empty\n\n提示\n\n返回一个空的 optional实例。\n\n// 调用静态方法实例化\noptional optional = optional.empty();\n\n\n\n# of\n\n提示\n\n返回具有optional的当前非空值的optional实例，如果目前参数为null时抛出nullpointerexception异常。\n\n// 调用静态方法实例化\noptional optional = optional.of("value");\n\n\n\n# ofnullable\n\n提示\n\n返回一个optional指定值的optional，如果非空（也就是允许空值传入），则返回一个空的optional（其实就是重新调用了empty）。\n\n// 调用静态方法实例化\noptional optional = optional.ofnullable("value");\n// 调用静态方法实例化，null情况下实际内部重新调用了empty静态方法实例化\noptional nulloptional = optional.ofnullable(null);\n\n\n\n# get\n\n提示\n\n如果 optional中有一个值，返回值，否则抛出 nosuchelementexception 。\n\n// 结果正常\noptional<string> optional = optional.ofnullable("value");\nstring value = optional.get();\n// 运行时异常，抛出nosuchelementexception异常\noptional<string> optional = optional.ofnullable(null);\nstring value = optional.get();\n\n\n\n# filter\n\n提示\n\n如果一个值存在，并且该值给定的值相匹配时，返回一个 optional描述的值，否则返回一个空的 optional 。\n\n// 输出 value\noptional<string> optional = optional.ofnullable("value");\nsystem.out.println(optional.filter(s -> s.equals("value")).get());\n// 运行时异常，抛出nosuchelementexception异常\noptional<string> optional = optional.ofnullable("value");\nsystem.out.println(optional.filter(s -> s.equals("default")).get());\n\n\n\n# flatmap\n\n提示\n\n如果一个值存在，应用提供的 optional映射函数给它，返回该结果，否则返回一个空的 optional 。\n\n// 输出 value\noptional<string> optional = optional.ofnullable("value");\nsystem.out.println(optional.flatmap(s -> optional.ofnullable(s.touppercase())).get());\n// 运行时异常，抛出nosuchelementexception异常\noptional<string> optional = optional.ofnullable(null);\nsystem.out.println(optional.flatmap(s -> optional.ofnullable(s.touppercase())).get());\n\n\n\n# ifpresent\n\n提示\n\n如果存在值，则使用该值调用指定的消费者，否则不执行任何操作，该方法接收consumer参数，以函数式形式编程。\n\n// 输出结果为value\noptional<string> optional = optional.ofnullable("value");\noptional.ifpresent(s -> system.out.println(s));\n// 没有输出结果，因为操作值为null，所以并不执行输出的代码段\noptional<string> optional = optional.ofnullable(null);\noptional.ifpresent(s -> system.out.println(s));\n\n\n\n# ispresent\n\n提示\n\n如果存在值返回 true，否则为 false 。\n\n// 结果为true\noptional<string> optional = optional.ofnullable("value");\nsystem.out.println(optional.ispresent());\n// 结果为false\noptional<string> optional = optional.ofnullable(null);\nsystem.out.println(optional.ispresent());\n\n\n\n# map\n\n提示\n\n如果存在一个值，则应用提供的映射函数，如果结果不为空，则返回一个 optional结果的 optional 。\n\n/**\n * 定义一个设备类\n * \n * @author zhcchen\n * @since 2022-04-13 09:57:52\n */\n@data\npublic class device {\n    private long deviceid;\n    private string devicename;\n    private integer devicetype;\n}\n\n\n// map其实就是通过一个lambda操作返回一个结果，放入一个新的optional容器里面\ndevice device = new device();\noptional<device> deviceoptional = optional.ofnullable(device);\noptional<string> devicenameoptional = deviceoptional.map(d -> d.getdevicename());\n\n\n// 实际我们就不需要一个新的容器，直接在返回的optional直接操作就行了\ndevice device = new device();\noptional<device> deviceoptional = optional.ofnullable(device);\nstring devicename = deviceoptional.map(d -> {\n    if (d.getdeviceid() == null) {\n        return "暂无设备名称";\n    }\n    return d.getdevicename();\n}).get();\n// 这里输出的是 暂无设备名称\nsystem.out.println(devicename);\n\n\n\n# orelse\n\n提示\n\n返回值如果存在返回对应值，否则返回传入的参数值。\n\n// 输出结果为value\noptional<string> optional = optional.ofnullable("value");\nsystem.out.println(optional.orelse("default"));\n// 输出结果为default,因为optional的值为null，相比于get，get是直接粗暴的抛出异常，当然也要根据业务场景选择合适方法\noptional<string> optional = optional.ofnullable(null);\nsystem.out.println(optional.orelse("default"));\n\n\n\n# orelseget\n\n提示\n\n返回值如果存在返回对应值，否则调用对应方法（函数式接口参数）返回值。该方法类似于orelse，只不过orelseget可以在lambda里面进行业务操作，然后返回值\n\n// 输出的结果为default，todo的地方可以根据具体业务操作flag的状态\noptional<string> optional = optional.ofnullable(null);\nsystem.out.println(optional.orelseget(() -> {\n    boolean flag = false;\n    // todo 这里可以对flag一些业务操作\n    return flag ? "value" : "default";\n}));\n\n\n\n# orelsethrow\n\n提示\n\n返回值如果存在返回对应值，否则调用对应方法（函数式接口参数）抛出异常。该方法类似于orelseget，只不过orelsethrow是值不存在时抛出异常（用户自己根据业务操作抛出对应异常）\n\n// 输出结果为 value,写了一大段，但是只要值不为null，则正常返回\noptional<string> optional = optional.ofnullable("value");\ntry {\n    system.out.println(optional.orelsethrow(() -> {\n        boolean flag = false;\n        // todo 这里可以对flag一些业务操作\n        return flag ? new exception("default") : null;\n    }));\n} catch (exception e) {\n    system.out.println("e: " + e.getmessage());\n}\n\n\n// 输出结果为e: 异常b, 操作值为null，所有执行自定义返回的异常，并被try...catch捕获\noptional<string> optional = optional.ofnullable(null);\ntry {\n    system.out.println(optional.orelsethrow(() -> {\n        boolean flag = false;\n        // todo 这里可以对flag一些业务操作\n        return flag ? new exception("default") : null;\n    }));\n} catch (exception e) {\n    system.out.println("e: " + e.getmessage());\n}\n\n\n\n# 使用场景解析\n\n\n# 场景1：判定字符串是否包含abc字串\n\n// 不使用optional的写法如下\nstring str = null;\nsystem.out.println(str == null ? false : str.indexof("abc") != -1);\n// 使用optional的写法如下\nstring str = null;\nsystem.out.println(optional.ofnullable(str).orelse("").indexof("abc") != -1);\n\n\n这样看好像optional的写法好像更长一些，一些简单的场景并不会提现optional的优势，再往下看下一个场景\n\n\n# 场景2：有一栋楼，楼内有多间房间（有对应房间号），房间内有多台设备。根据对应房间号和设备id获取对应设备名称，不存在的返回设备不存在的值串。\n\n/**\n * 定义一个设备类\n *\n * @author zhcchen\n * @since 2022-04-13 09:57:52\n */\n@data\npublic class device {\n    private long deviceid;\n    private string devicename;\n    private integer devicetype;\n}\n\n\n// 假定上述描述的对应结构如下\nmap<string, map<long, device>> roommap = new hashmap<>(10);\n// 房间号\nstring roomno = "335";\n// 设备id\nlong deviceid = 1l;\n// 不使用optional的写法如下\nstring result = "设备不存在";\nif (roommap != null) {\n    map<long, device> devicemap = roommap.get(roomno);\n    if (devicemap != null) {\n        device device = devicemap.get(deviceid);\n        if (device != null) {\n            string name = device.getdevicename();\n            if (name != null) {\n                result = name;\n            }\n        }\n    }\n}\nsystem.out.println(result);\n// 使用optional的写法如下\nsystem.out.println(\n        optional.ofnullable(roommap)\n                .map(rmap -> rmap.get(roomno))\n                .map(dmap -> dmap.get(deviceid))\n                .map(device::getdevicename)\n                .orelse("设备不存在")\n);\n\n\n这样看下来就明显一点了，同时使用optional的代码结构上少了一堆判断，看起来更加直观一些\n\n\n# 总结\n\noptional适合的场景是从一些复杂的结构中获取自己想要的数据，可以省去众多if语句，让代码的可读性更高（前提是熟悉链式和函数式编程和稍微看下optional常用的几个方法源码）',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"数据结构",frontmatter:{title:"数据结构",date:"2022-06-22T15:45:58.000Z",permalink:"/pages/cef328/"},regularPath:"/02.%E7%AE%97%E6%B3%95/01.%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"02.算法/01.算法基础/01.数据结构.md",key:"v-6e542804",path:"/pages/cef328/",headers:[{level:2,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:2}],headersStr:"数据结构",content:"# 数据结构\n\n更新中...",normalizedContent:"# 数据结构\n\n更新中...",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"速查表",frontmatter:{title:"速查表",date:"2022-10-26T16:32:43.000Z",permalink:"/pages/1b68b5/"},regularPath:"/0201.%E9%80%9F%E6%9F%A5%E8%A1%A8/01.%E9%80%9F%E6%9F%A5%E8%A1%A8.html",relativePath:"0201.速查表/01.速查表.md",key:"v-309b2a07",path:"/pages/1b68b5/",headers:[{level:2,title:"编程语言",slug:"编程语言",normalizedTitle:"编程语言",charIndex:2},{level:2,title:"系统",slug:"系统",normalizedTitle:"系统",charIndex:49},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:66}],headersStr:"编程语言 系统 工具",content:"# 编程语言\n\n * Shell\n * Java\n * Go\n * JavaScript\n\n\n# 系统\n\n * Linux\n\n\n# 工具\n\n * Git\n * Vim",normalizedContent:"# 编程语言\n\n * shell\n * java\n * go\n * javascript\n\n\n# 系统\n\n * linux\n\n\n# 工具\n\n * git\n * vim",charsets:{cjk:!0},lastUpdated:"2022/10/30, 11:17:19",lastUpdatedTimestamp:1667099839e3},{title:"Shell",frontmatter:{title:"Shell",date:"2022-10-30T11:08:50.000Z",permalink:"/pages/5bc7d8/"},regularPath:"/0201.%E9%80%9F%E6%9F%A5%E8%A1%A8/0200001.Shell.html",relativePath:"0201.速查表/0200001.Shell.md",key:"v-007fa29a",path:"/pages/5bc7d8/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/10/30, 11:17:19",lastUpdatedTimestamp:1667099839e3},{title:"Go",frontmatter:{title:"Go",date:"2022-10-30T11:10:17.000Z",permalink:"/pages/918089/"},regularPath:"/0201.%E9%80%9F%E6%9F%A5%E8%A1%A8/0200003.Go.html",relativePath:"0201.速查表/0200003.Go.md",key:"v-31b974f5",path:"/pages/918089/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/10/30, 11:17:19",lastUpdatedTimestamp:1667099839e3},{title:"介绍",frontmatter:{title:"介绍",date:"2022-06-27T10:15:50.000Z",permalink:"/pages/17da4a/"},regularPath:"/0303.%E5%BC%80%E5%8F%91%20-%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.%E4%BB%8B%E7%BB%8D.html",relativePath:"0303.开发 - 代码设计/01.设计模式/00.介绍.md",key:"v-94d17ce6",path:"/pages/17da4a/",headersStr:null,content:"设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\n设计模式分为三种类型，共23种：\n\n * 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。\n * 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n * 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。",normalizedContent:"设计模式（design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。\n\n设计模式分为三种类型，共23种：\n\n * 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。\n * 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。\n * 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"单例模式",frontmatter:{title:"单例模式",date:"2022-06-27T10:24:39.000Z",permalink:"/pages/6278f7/"},regularPath:"/0303.%E5%BC%80%E5%8F%91%20-%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"0303.开发 - 代码设计/01.设计模式/01.单例模式.md",key:"v-0609ad2e",path:"/pages/6278f7/",headers:[{level:2,title:"饿汉式",slug:"饿汉式",normalizedTitle:"饿汉式",charIndex:82},{level:2,title:"懒汉式",slug:"懒汉式",normalizedTitle:"懒汉式",charIndex:151},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:204}],headersStr:"饿汉式 懒汉式 总结",content:'> 单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。\n\n\n# 饿汉式\n\n> 在类被加载时实例化对象，优点：线程安全，使用对象时没有首次实例化耗时，缺点：丢失了延迟实例化带来的节约资源的好处。\n\n\n# 懒汉式\n\n> 在需要使用到对象时才实例化对象，优点：延迟实例化可以节约资源，缺点：有首次加载耗时\n\n\n# 总结\n\npublic class Demo {\n    public static void main(String[] args) {\n        System.out.println("hello world!");\n    }\n}\n',normalizedContent:'> 单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。\n\n\n# 饿汉式\n\n> 在类被加载时实例化对象，优点：线程安全，使用对象时没有首次实例化耗时，缺点：丢失了延迟实例化带来的节约资源的好处。\n\n\n# 懒汉式\n\n> 在需要使用到对象时才实例化对象，优点：延迟实例化可以节约资源，缺点：有首次加载耗时\n\n\n# 总结\n\npublic class demo {\n    public static void main(string[] args) {\n        system.out.println("hello world!");\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"工厂模式",frontmatter:{title:"工厂模式",date:"2022-06-27T10:32:53.000Z",permalink:"/pages/48ae87/"},regularPath:"/0303.%E5%BC%80%E5%8F%91%20-%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"0303.开发 - 代码设计/01.设计模式/02.工厂模式.md",key:"v-484b5d68",path:"/pages/48ae87/",headersStr:null,content:'简单列一下这个模式的家族：\n\n * 1、静态工厂模式\n   \n   * 这个最常见了，项目中的辅助类，TextUtil.isEmpty等，类+静态方法。\n\n * 2、简单工厂模式（店里买肉夹馍）\n   \n   * 定义：通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n   * 根据类型直接创建肉夹馍：SimpleRoujiaMoFactory.java\n   \n    public RoujiaMo creatRoujiaMo(String type) {\n        RoujiaMo roujiaMo = null;\n        switch (type) {\n            case "Suan":\n                roujiaMo = new ZSuanRoujiaMo();\n                break;\n            case "La":\n                roujiaMo = new ZLaRoujiaMo();\n                break;\n            case "Tian":\n                roujiaMo = new ZTianRoujiaMo();\n                break;\n            default:// 默认为酸肉夹馍\n                roujiaMo = new ZSuanRoujiaMo();\n                break;\n        }\n        return roujiaMo;\n    }\n   ',normalizedContent:'简单列一下这个模式的家族：\n\n * 1、静态工厂模式\n   \n   * 这个最常见了，项目中的辅助类，textutil.isempty等，类+静态方法。\n\n * 2、简单工厂模式（店里买肉夹馍）\n   \n   * 定义：通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。\n   * 根据类型直接创建肉夹馍：simpleroujiamofactory.java\n   \n    public roujiamo creatroujiamo(string type) {\n        roujiamo roujiamo = null;\n        switch (type) {\n            case "suan":\n                roujiamo = new zsuanroujiamo();\n                break;\n            case "la":\n                roujiamo = new zlaroujiamo();\n                break;\n            case "tian":\n                roujiamo = new ztianroujiamo();\n                break;\n            default:// 默认为酸肉夹馍\n                roujiamo = new zsuanroujiamo();\n                break;\n        }\n        return roujiamo;\n    }\n   ',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"建造者模式",frontmatter:{title:"建造者模式",date:"2022-06-27T10:34:12.000Z",permalink:"/pages/ea53e7/"},regularPath:"/0303.%E5%BC%80%E5%8F%91%20-%20%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"0303.开发 - 代码设计/01.设计模式/03.建造者模式.md",key:"v-44272527",path:"/pages/ea53e7/",headersStr:null,content:"> 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。\n\n * 需求：用户去汽车店购买汽车。\n\n * 分析：汽车店根据每个用户的需求提取对应汽车\n\n * 建造者超类：Builder\n   \n   public abstract class Builder {\n   \n       public abstract void setPart(String name, String type);\n   \n       public abstract Product getProduct();\n   }\n   \n\n * 建造者对应实现类：ConcreteBuilder\n   \n    public class ConcreteBuilder extends Builder {\n   \n        private Product product = new Product();\n    \n        @Override\n        public void setPart(String name, String type) {\n            product.setName(name);\n            product.setType(type);\n        }\n    \n        @Override\n        public Product getProduct() {\n            return product;\n        }\n    }\n   \n\n * 店长Director取汽车：\n   \n    // 店长\n    Director director = new Director();\n    // 得到宝马汽车，内部实现提取宝马汽车的详情操作\n    Product product = director.getBProduct();\n    // 展示汽车信息\n    product.showProduct();\n   ",normalizedContent:"> 建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。\n\n * 需求：用户去汽车店购买汽车。\n\n * 分析：汽车店根据每个用户的需求提取对应汽车\n\n * 建造者超类：builder\n   \n   public abstract class builder {\n   \n       public abstract void setpart(string name, string type);\n   \n       public abstract product getproduct();\n   }\n   \n\n * 建造者对应实现类：concretebuilder\n   \n    public class concretebuilder extends builder {\n   \n        private product product = new product();\n    \n        @override\n        public void setpart(string name, string type) {\n            product.setname(name);\n            product.settype(type);\n        }\n    \n        @override\n        public product getproduct() {\n            return product;\n        }\n    }\n   \n\n * 店长director取汽车：\n   \n    // 店长\n    director director = new director();\n    // 得到宝马汽车，内部实现提取宝马汽车的详情操作\n    product product = director.getbproduct();\n    // 展示汽车信息\n    product.showproduct();\n   ",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Overview",frontmatter:{title:"Overview",date:"2022-06-22T18:21:22.000Z",permalink:"/pages/422210/"},regularPath:"/0501.%E5%B7%A5%E5%85%B7-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.Overview.html",relativePath:"0501.工具-开发工具/01.开发工具/01.Overview.md",key:"v-742f5d39",path:"/pages/422210/",headersStr:null,content:"更新中...",normalizedContent:"更新中...",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Overview",frontmatter:{title:"Overview",date:"2022-06-22T18:22:04.000Z",permalink:"/pages/30becd/"},regularPath:"/0502.%E5%B7%A5%E5%85%B7-Git/01.Git/01.Overview.html",relativePath:"0502.工具-Git/01.Git/01.Overview.md",key:"v-7f1fe1d3",path:"/pages/30becd/",headersStr:null,content:"更新中...",normalizedContent:"更新中...",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"环境搭建",frontmatter:{title:"环境搭建",date:"2022-07-06T17:47:32.000Z",permalink:"/pages/e71389/"},regularPath:"/0601.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%20-%20Dart/01.Dart/01.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"0601.编程语言 - Dart/01.Dart/01.环境搭建.md",key:"v-3745d52d",path:"/pages/e71389/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"变量",frontmatter:{title:"变量",date:"2022-07-06T17:51:58.000Z",permalink:"/pages/b214ca/"},regularPath:"/0601.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%20-%20Dart/01.Dart/02.%E5%8F%98%E9%87%8F.html",relativePath:"0601.编程语言 - Dart/01.Dart/02.变量.md",key:"v-56a5be0e",path:"/pages/b214ca/",headers:[{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:2},{level:3,title:"变量初始化",slug:"变量初始化",normalizedTitle:"变量初始化",charIndex:9},{level:3,title:"变量默认值",slug:"变量默认值",normalizedTitle:"变量默认值",charIndex:235},{level:3,title:"Late 修饰符",slug:"late-修饰符",normalizedTitle:"late 修饰符",charIndex:573},{level:3,title:"final 和 const",slug:"final-和-const",normalizedTitle:"final 和 const",charIndex:1467}],headersStr:"变量 变量初始化 变量默认值 Late 修饰符 final 和 const",content:'# 变量\n\n\n# 变量初始化\n\n变量初始化示例（运行时进行类型推断）\n\nvar str = "hello world!";\n\n\n显示声明变量类型（确定变量类型）\n\nString str = "hello world!";\n\n\n如果变量类型非单一的情况，使用Object类型\n\nObject str = "hello world!";\n// 其他情况改变其他类型\nstr = 100;\n\n\n> 根据Dart官方的样式指南，对局部变量 使用var，而不是类型注释。\n\n\n# 变量默认值\n\n只声明未赋值的变量的默认值都为null\n\nvar value;\n// 输出结果为 null\nprint(value);\n\n\n显示声明变量的情况下，如果没有赋值，有使用到变量时则报错，无法运行\n\n// 声明但未赋值\nString stringValue;\nprint(stringValue); // 运行时错误\n\n// 无需声明时就赋值\nString stringValue;\nstringValue = "hello";\n// 输出结果为 hello\nprint(stringValue);\n\n\n显示声明情况下，允许变量为空，则采用 ?\n\nString? stringValue;\n// 输出结果为 null\nprint(stringValue);\n\n\n\n# Late 修饰符\n\nDart 2.12 添加了late修饰符，它有两个作用：\n\n 1. 声明一个在声明后初始化的不可为空的变量（全局变量）。\n 2. 懒惰地初始化一个变量。\n\n第一点的功能跟?功能类似，但是又有点不同，对于全局变量才有使用意义，局部变量声明时未立刻初始化，运行并不会报错，示例代码如下：\n\n// 以下程序运行正常\nlate String global; // 全局变量如果声明时未初始化需要 late 或者 ? 声明，等价于 String? global\n\nvoid main() {\n  global = \'这是一个全局变量\';\n  String local; // 局部变量则无需声明时立刻初始化\n  local = "这是一个局部变量";\n  print(local);\n  print(global);\n}\n\n\n第二点的功能则是懒加载的一个功能，即当late声明的变量在使用时才会加载对应的赋值或赋值方法，示例代码如下：\n\n/// 该段程序输出结果为：\n/// hello\nlate String global = initVar();\n\nvoid main() {\n  late String local = initVar();\n  print("hello");\n}\n\nString initVar() {\n  print("开始初始化变量");\n  return "我是一个默认变量值";\n}\n\n\n/// 该段程序输出结果为：\n/// hello\n/// 开始初始化变量\n/// 我是一个默认变量值\n/// 开始初始化变量\n/// 我是一个默认变量值\nlate String global = initVar();\n\nvoid main() {\n  late String local = initVar();\n  print("hello");\n  print(global);\n  print(local);\n}\n\nString initVar() {\n  print("开始初始化变量");\n  return "我是一个默认变量值";\n}\n\n\n\n# final 和 const\n\nfinal变量只能赋值一次，之后无法修改，示例如下：\n\nfinal str = "hello";\n// 等价于\nfinal String str = "hello";\n\n\n以下为错误示例：\n\nfinal str = "hello";\nstr = "hello world"; // 运行错误，不可再次赋值\n\n\nfinal 也支持延迟初始化\n\nfinal str;\nstr = "hello";\n\n\n> final使用late修饰符，分别作用于全局变量和局部变量，会是什么效果呢，感兴趣的同学可以自己动手验证一下。\n\n> 对于不可变，且声明时已初始化，即为常量，通常使用const，且const对热加载友好\n\nconst是编译时常量，如果const在类级别，则需使用static const来声明\n\nconst str = "hello";\n// 等价于\nconst String str = "hello";\n\n\nconst B = 1024;\nconst KB = B * 1024;\nconst MB = KB * 1024;\nconst GB = MB * 1024;\n\n\nconst在列表数据上允许延迟初始化\n\nvar str = const [];\nstr = [1, 2];\n',normalizedContent:'# 变量\n\n\n# 变量初始化\n\n变量初始化示例（运行时进行类型推断）\n\nvar str = "hello world!";\n\n\n显示声明变量类型（确定变量类型）\n\nstring str = "hello world!";\n\n\n如果变量类型非单一的情况，使用object类型\n\nobject str = "hello world!";\n// 其他情况改变其他类型\nstr = 100;\n\n\n> 根据dart官方的样式指南，对局部变量 使用var，而不是类型注释。\n\n\n# 变量默认值\n\n只声明未赋值的变量的默认值都为null\n\nvar value;\n// 输出结果为 null\nprint(value);\n\n\n显示声明变量的情况下，如果没有赋值，有使用到变量时则报错，无法运行\n\n// 声明但未赋值\nstring stringvalue;\nprint(stringvalue); // 运行时错误\n\n// 无需声明时就赋值\nstring stringvalue;\nstringvalue = "hello";\n// 输出结果为 hello\nprint(stringvalue);\n\n\n显示声明情况下，允许变量为空，则采用 ?\n\nstring? stringvalue;\n// 输出结果为 null\nprint(stringvalue);\n\n\n\n# late 修饰符\n\ndart 2.12 添加了late修饰符，它有两个作用：\n\n 1. 声明一个在声明后初始化的不可为空的变量（全局变量）。\n 2. 懒惰地初始化一个变量。\n\n第一点的功能跟?功能类似，但是又有点不同，对于全局变量才有使用意义，局部变量声明时未立刻初始化，运行并不会报错，示例代码如下：\n\n// 以下程序运行正常\nlate string global; // 全局变量如果声明时未初始化需要 late 或者 ? 声明，等价于 string? global\n\nvoid main() {\n  global = \'这是一个全局变量\';\n  string local; // 局部变量则无需声明时立刻初始化\n  local = "这是一个局部变量";\n  print(local);\n  print(global);\n}\n\n\n第二点的功能则是懒加载的一个功能，即当late声明的变量在使用时才会加载对应的赋值或赋值方法，示例代码如下：\n\n/// 该段程序输出结果为：\n/// hello\nlate string global = initvar();\n\nvoid main() {\n  late string local = initvar();\n  print("hello");\n}\n\nstring initvar() {\n  print("开始初始化变量");\n  return "我是一个默认变量值";\n}\n\n\n/// 该段程序输出结果为：\n/// hello\n/// 开始初始化变量\n/// 我是一个默认变量值\n/// 开始初始化变量\n/// 我是一个默认变量值\nlate string global = initvar();\n\nvoid main() {\n  late string local = initvar();\n  print("hello");\n  print(global);\n  print(local);\n}\n\nstring initvar() {\n  print("开始初始化变量");\n  return "我是一个默认变量值";\n}\n\n\n\n# final 和 const\n\nfinal变量只能赋值一次，之后无法修改，示例如下：\n\nfinal str = "hello";\n// 等价于\nfinal string str = "hello";\n\n\n以下为错误示例：\n\nfinal str = "hello";\nstr = "hello world"; // 运行错误，不可再次赋值\n\n\nfinal 也支持延迟初始化\n\nfinal str;\nstr = "hello";\n\n\n> final使用late修饰符，分别作用于全局变量和局部变量，会是什么效果呢，感兴趣的同学可以自己动手验证一下。\n\n> 对于不可变，且声明时已初始化，即为常量，通常使用const，且const对热加载友好\n\nconst是编译时常量，如果const在类级别，则需使用static const来声明\n\nconst str = "hello";\n// 等价于\nconst string str = "hello";\n\n\nconst b = 1024;\nconst kb = b * 1024;\nconst mb = kb * 1024;\nconst gb = mb * 1024;\n\n\nconst在列表数据上允许延迟初始化\n\nvar str = const [];\nstr = [1, 2];\n',charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"类型",frontmatter:{title:"类型",date:"2022-07-07T11:03:12.000Z",permalink:"/pages/e07dc6/"},regularPath:"/0601.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%20-%20Dart/01.Dart/03.%E7%B1%BB%E5%9E%8B.html",relativePath:"0601.编程语言 - Dart/01.Dart/03.类型.md",key:"v-5dfccfb9",path:"/pages/e07dc6/",headers:[{level:2,title:"内置类型",slug:"内置类型",normalizedTitle:"内置类型",charIndex:2},{level:2,title:"数值",slug:"数值",normalizedTitle:"数值",charIndex:25},{level:2,title:"字符串",slug:"字符串",normalizedTitle:"字符串",charIndex:44},{level:2,title:"布尔值",slug:"布尔值",normalizedTitle:"布尔值",charIndex:59},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:72},{level:2,title:"Set集合",slug:"set集合",normalizedTitle:"set集合",charIndex:84},{level:2,title:"Map集合",slug:"map集合",normalizedTitle:"map集合",charIndex:98},{level:2,title:"Runes",slug:"runes",normalizedTitle:"runes",charIndex:112},{level:2,title:"Symbols",slug:"symbols",normalizedTitle:"symbols",charIndex:128}],headersStr:"内置类型 数值 字符串 布尔值 数组 Set集合 Map集合 Runes Symbols",content:"# 内置类型\n\nDart 内置以下类型：\n\n * 数值（int, double）\n * 字符串（String）\n * 布尔值（bool）\n * 数组（List）\n * Set集合（Set）\n * Map集合（Map）\n * Runes（Runes）\n * Symbols\n * 空值null（Null）\n\n\n# 数值\n\nint 不大于64位的整数值，具体取决于平台。\n\nvar x = 1;\nvar hex = 0xDEADBEEF;\n\n\ndouble64 位（双精度）浮点数，由 IEEE 754 标准指定。\n\nvar y = 1.1;\nvar exponents = 1.42e5;\n\ndouble x = 1;\n// 等价于\ndouble x = 1.0;\n\n\n由于int和double都属于num的子类，所以可以直接使用num声明，且具有两种类型特性\n\nnum x = 1; // x 可以是int和double\nx += 2.5;\n\n\n\n# 字符串\n\n字符串的定义，允许使用单引号和双引号\n\nvar s = \"hello\";\nvar s1 = 'hello';\n\n\n字符串定义时，允许多行，且可省略+符号\n\nvar a = 'hello '\n      'world '\n      \"!\";\n\n\n模板变量（使代码更加易读）\n\nvar name = \"Chen\";\nvar age = 18;\n\nvar info = '我是$name,我今年$age岁了';\n// 等价于（不过使用$var更加简洁）\nvar info = '我是${name},我今年${age}岁了';\n\n\n\n# 布尔值\n\n为了表示布尔值，Dart 有一个名为 的类型bool。布尔字面量是true和false，它们都是编译时常量。\n\nbool b = true;\nbool b1 = false;\nvar b2 = true;\n\n\n\n# 数组\n\n在 Dart 中，数组是 List对象，所以大多数人只称它们为列表。\n\nList list = [1, 2, 3];\n// 等价于\nvar list = [1, 2, 3];\n\n// 新增\nlist.add(7);\n// 移除\nlist.remove(7);\n\n\nDart 2.3 引入了扩展运算符( ...) 和可 识别空值的扩展运算符( ...?)，它们提供了一种将多个值插入集合的简洁方法。\n\n例如，您可以使用扩展运算符 ( ...) 将列表的所有值插入到另一个列表中：\n\nvar list = [1, 2, 3];\nvar list1 = null;\n// ...? 表示list1可能为空\nvar list2 = [...list, 4, 5, 6, ...?list1];\n// 输出结果为[1, 2, 3, 4, 5, 6]\nprint(list2);\n\n\nDart 还提供了collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。\n\nvar add = true;\nvar list = [1, 2, 3, if (add) 4];\n// 输出结果为[1, 2, 3, 4]\nprint(list);\n\n\nvar listOfIns = [4, 5, 6];\nvar list = [1, 2, 3, for (var i in listOfIns) i];\n// 输出结果为[1, 2, 3, 4]\nprint(list);\n\n\n\n# Set集合\n\nDart 提供了Set类型集合，Set其特点是元素唯一，并且无序\n\nvar set = {1, 2, 3, 4, 5, 6};\n// 等价于\nSet<int> set = {1, 2, 3, 4, 5, 6};\n\n// 新增\nset.add(7);\n// 移除\nset.remove(7);\n\n\nDart 同样对Set集合提供了collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。用法可参考数组。\n\n\n# Map集合\n\n通常，映射是关联键和值的对象。键和值都可以是任何类型的对象。每个键只出现一次，但您可以多次使用相同的*值。*Dart 对Map集合的支持由Map`类型提供。\n\nvar map = {'name': 'Chen', 'age': 18};\n// 等价于\nMap<String, Object> map = {'name': 'Chen', 'age': 18};\n\n// 新增\nmap['height'] = '100kg';\n// 移除\nmap.remove('height');\n\n\nMap集合同样支持collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。用法可参考数组。\n\n\n# Runes\n\n在 Dart 中，Runes暴露了字符串的 Unicode 代码点。您可以使用字符包 来查看或操作用户感知的字符，也称为 Unicode（扩展）字素簇。\n\nUnicode 为世界上所有书写系统中使用的每个字母、数字和符号定义了一个唯一的数值。因为 Dart 字符串是 UTF-16 代码单元的序列，所以在字符串中表达 Unicode 代码点需要特殊的语法。表示 Unicode 代码点的常用方法是 \\uXXXX，其中 XXXX 是 4 位十六进制值。例如，心形字符 (♥) 是\\u2665。要指定多于或少于 4 个十六进制数字，请将值放在大括号中。例如，笑的表情符号 (😆) 是\\u{1f606}.\n\n// 输出两个😆\nvar a = '\\u{1f606}';\nprint(a);\nvar r = Runes('\\u{1f606}');\nprint(r.string);\n\n\n\n# Symbols\n\nSymbol对象表示在 Dart 程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的 API 非常宝贵，因为缩小会更改标识符名称，但不会更改标识符符号。\n\n要获取标识符的符号，请使用符号文字，#其后跟标识符：\n\n> 符号文字是编译时常量。",normalizedContent:"# 内置类型\n\ndart 内置以下类型：\n\n * 数值（int, double）\n * 字符串（string）\n * 布尔值（bool）\n * 数组（list）\n * set集合（set）\n * map集合（map）\n * runes（runes）\n * symbols\n * 空值null（null）\n\n\n# 数值\n\nint 不大于64位的整数值，具体取决于平台。\n\nvar x = 1;\nvar hex = 0xdeadbeef;\n\n\ndouble64 位（双精度）浮点数，由 ieee 754 标准指定。\n\nvar y = 1.1;\nvar exponents = 1.42e5;\n\ndouble x = 1;\n// 等价于\ndouble x = 1.0;\n\n\n由于int和double都属于num的子类，所以可以直接使用num声明，且具有两种类型特性\n\nnum x = 1; // x 可以是int和double\nx += 2.5;\n\n\n\n# 字符串\n\n字符串的定义，允许使用单引号和双引号\n\nvar s = \"hello\";\nvar s1 = 'hello';\n\n\n字符串定义时，允许多行，且可省略+符号\n\nvar a = 'hello '\n      'world '\n      \"!\";\n\n\n模板变量（使代码更加易读）\n\nvar name = \"chen\";\nvar age = 18;\n\nvar info = '我是$name,我今年$age岁了';\n// 等价于（不过使用$var更加简洁）\nvar info = '我是${name},我今年${age}岁了';\n\n\n\n# 布尔值\n\n为了表示布尔值，dart 有一个名为 的类型bool。布尔字面量是true和false，它们都是编译时常量。\n\nbool b = true;\nbool b1 = false;\nvar b2 = true;\n\n\n\n# 数组\n\n在 dart 中，数组是 list对象，所以大多数人只称它们为列表。\n\nlist list = [1, 2, 3];\n// 等价于\nvar list = [1, 2, 3];\n\n// 新增\nlist.add(7);\n// 移除\nlist.remove(7);\n\n\ndart 2.3 引入了扩展运算符( ...) 和可 识别空值的扩展运算符( ...?)，它们提供了一种将多个值插入集合的简洁方法。\n\n例如，您可以使用扩展运算符 ( ...) 将列表的所有值插入到另一个列表中：\n\nvar list = [1, 2, 3];\nvar list1 = null;\n// ...? 表示list1可能为空\nvar list2 = [...list, 4, 5, 6, ...?list1];\n// 输出结果为[1, 2, 3, 4, 5, 6]\nprint(list2);\n\n\ndart 还提供了collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。\n\nvar add = true;\nvar list = [1, 2, 3, if (add) 4];\n// 输出结果为[1, 2, 3, 4]\nprint(list);\n\n\nvar listofins = [4, 5, 6];\nvar list = [1, 2, 3, for (var i in listofins) i];\n// 输出结果为[1, 2, 3, 4]\nprint(list);\n\n\n\n# set集合\n\ndart 提供了set类型集合，set其特点是元素唯一，并且无序\n\nvar set = {1, 2, 3, 4, 5, 6};\n// 等价于\nset<int> set = {1, 2, 3, 4, 5, 6};\n\n// 新增\nset.add(7);\n// 移除\nset.remove(7);\n\n\ndart 同样对set集合提供了collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。用法可参考数组。\n\n\n# map集合\n\n通常，映射是关联键和值的对象。键和值都可以是任何类型的对象。每个键只出现一次，但您可以多次使用相同的*值。*dart 对map集合的支持由map`类型提供。\n\nvar map = {'name': 'chen', 'age': 18};\n// 等价于\nmap<string, object> map = {'name': 'chen', 'age': 18};\n\n// 新增\nmap['height'] = '100kg';\n// 移除\nmap.remove('height');\n\n\nmap集合同样支持collection if和collection for，您可以使用它们来使用条件 ( if) 和重复 ( for) 构建集合。用法可参考数组。\n\n\n# runes\n\n在 dart 中，runes暴露了字符串的 unicode 代码点。您可以使用字符包 来查看或操作用户感知的字符，也称为 unicode（扩展）字素簇。\n\nunicode 为世界上所有书写系统中使用的每个字母、数字和符号定义了一个唯一的数值。因为 dart 字符串是 utf-16 代码单元的序列，所以在字符串中表达 unicode 代码点需要特殊的语法。表示 unicode 代码点的常用方法是 \\uxxxx，其中 xxxx 是 4 位十六进制值。例如，心形字符 (♥) 是\\u2665。要指定多于或少于 4 个十六进制数字，请将值放在大括号中。例如，笑的表情符号 (😆) 是\\u{1f606}.\n\n// 输出两个😆\nvar a = '\\u{1f606}';\nprint(a);\nvar r = runes('\\u{1f606}');\nprint(r.string);\n\n\n\n# symbols\n\nsymbol对象表示在 dart 程序中声明的运算符或标识符。您可能永远不需要使用符号，但它们对于按名称引用标识符的 api 非常宝贵，因为缩小会更改标识符名称，但不会更改标识符符号。\n\n要获取标识符的符号，请使用符号文字，#其后跟标识符：\n\n> 符号文字是编译时常量。",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"介绍",frontmatter:{title:"介绍",date:"2022-06-22T14:39:37.000Z",permalink:"/pages/f2e32e/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/01.%E4%BB%8B%E7%BB%8D.html",relativePath:"96.工具/01.Docker/01.介绍.md",key:"v-6e7f3c94",path:"/pages/f2e32e/",headers:[{level:2,title:"Docker 平台",slug:"docker-平台",normalizedTitle:"docker 平台",charIndex:154},{level:2,title:"我可以使用 Docker 做什么？",slug:"我可以使用-docker-做什么",normalizedTitle:"我可以使用 docker 做什么？",charIndex:454},{level:2,title:"Docker 架构",slug:"docker-架构",normalizedTitle:"docker 架构",charIndex:1026},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1275}],headersStr:"Docker 平台 我可以使用 Docker 做什么？ Docker 架构 参考",content:"Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分离，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础设施。通过利用 Docker 快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产环境中运行之间的延迟。\n\n\n# Docker 平台\n\nDocker 提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的一切，因此您无需依赖主机上当前安装的内容。您可以在工作时轻松共享容器，并确保与您共享的每个人都获得以相同方式工作的同一个容器。\n\nDocker 提供工具和平台来管理容器的生命周期：\n\n * 使用容器开发您的应用程序及其支持组件。\n * 容器成为分发和测试应用程序的单元。\n * 准备就绪后，将应用程序部署到生产环境中，作为容器或编排的服务。无论您的生产环境是本地数据中心、云提供商还是两者的混合，这都是一样的。\n\n\n# 我可以使用 Docker 做什么？\n\n快速、一致地交付您的应用程序\n\nDocker 通过允许开发人员使用提供应用程序和服务的本地容器在标准化环境中工作来简化开发生命周期。容器非常适合持续集成和持续交付 (CI/CD) 工作流程。\n\n考虑以下示例场景：\n\n * 您的开发人员在本地编写代码并使用 Docker 容器与同事分享他们的工作。\n * 他们使用 Docker 将他们的应用程序推送到测试环境中并执行自动化和手动测试。\n * 当开发者发现bug时，可以在开发环境中修复，重新部署到测试环境中进行测试和验证。\n * 测试完成后，将修复程序提供给客户就像将更新的映像推送到生产环境一样简单。\n\n响应式部署和扩展\n\nDocker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑、数据中心的物理或虚拟机、云提供商或混合环境中运行。\n\nDocker 的可移植性和轻量级特性还使得动态管理工作负载、根据业务需求近乎实时地扩展或拆除应用程序和服务变得容易。\n\n在相同硬件上运行更多工作负载\n\nDocker 是轻量级和快速的。它为基于管理程序的虚拟机提供了一种可行且经济高效的替代方案，因此您可以使用更多计算容量来实现业务目标。Docker 非常适合高密度环境以及需要用更少资源完成更多工作的中小型部署。\n\n\n# Docker 架构\n\nDocker 使用客户端-服务器架构。Docker客户端与 Docker**守护进程对话，后者负责构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以 在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序使用 REST API，通过 UNIX 套接字或网络接口进行通信。另一个 Docker 客户端是 Docker Compose，它允许您使用由一组容器组成的应用程序。\n\n\n# 参考\n\n * https://docs.docker.com/get-started/",normalizedContent:"docker 是一个用于开发、发布和运行应用程序的开放平台。docker 使您能够将应用程序与基础架构分离，以便您可以快速交付软件。使用 docker，您可以像管理应用程序一样管理基础设施。通过利用 docker 快速交付、测试和部署代码的方法，您可以显着减少编写代码和在生产环境中运行之间的延迟。\n\n\n# docker 平台\n\ndocker 提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的一切，因此您无需依赖主机上当前安装的内容。您可以在工作时轻松共享容器，并确保与您共享的每个人都获得以相同方式工作的同一个容器。\n\ndocker 提供工具和平台来管理容器的生命周期：\n\n * 使用容器开发您的应用程序及其支持组件。\n * 容器成为分发和测试应用程序的单元。\n * 准备就绪后，将应用程序部署到生产环境中，作为容器或编排的服务。无论您的生产环境是本地数据中心、云提供商还是两者的混合，这都是一样的。\n\n\n# 我可以使用 docker 做什么？\n\n快速、一致地交付您的应用程序\n\ndocker 通过允许开发人员使用提供应用程序和服务的本地容器在标准化环境中工作来简化开发生命周期。容器非常适合持续集成和持续交付 (ci/cd) 工作流程。\n\n考虑以下示例场景：\n\n * 您的开发人员在本地编写代码并使用 docker 容器与同事分享他们的工作。\n * 他们使用 docker 将他们的应用程序推送到测试环境中并执行自动化和手动测试。\n * 当开发者发现bug时，可以在开发环境中修复，重新部署到测试环境中进行测试和验证。\n * 测试完成后，将修复程序提供给客户就像将更新的映像推送到生产环境一样简单。\n\n响应式部署和扩展\n\ndocker 基于容器的平台允许高度可移植的工作负载。docker 容器可以在开发人员的本地笔记本电脑、数据中心的物理或虚拟机、云提供商或混合环境中运行。\n\ndocker 的可移植性和轻量级特性还使得动态管理工作负载、根据业务需求近乎实时地扩展或拆除应用程序和服务变得容易。\n\n在相同硬件上运行更多工作负载\n\ndocker 是轻量级和快速的。它为基于管理程序的虚拟机提供了一种可行且经济高效的替代方案，因此您可以使用更多计算容量来实现业务目标。docker 非常适合高密度环境以及需要用更少资源完成更多工作的中小型部署。\n\n\n# docker 架构\n\ndocker 使用客户端-服务器架构。docker客户端与 docker**守护进程对话，后者负责构建、运行和分发 docker 容器的繁重工作。docker 客户端和守护程序可以 在同一系统上运行，或者您可以将 docker 客户端连接到远程 docker 守护程序。docker 客户端和守护程序使用 rest api，通过 unix 套接字或网络接口进行通信。另一个 docker 客户端是 docker compose，它允许您使用由一组容器组成的应用程序。\n\n\n# 参考\n\n * https://docs.docker.com/get-started/",charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:15:39",lastUpdatedTimestamp:1671434139e3},{title:"快速上手",frontmatter:{title:"快速上手",date:"2022-06-22T14:39:51.000Z",permalink:"/pages/abbe88/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/02.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html",relativePath:"96.工具/01.Docker/02.快速上手.md",key:"v-1a749d5a",path:"/pages/abbe88/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:2},{level:3,title:"方式一：使用Docker Desktop 安装",slug:"方式一-使用docker-desktop-安装",normalizedTitle:"方式一：使用docker desktop 安装",charIndex:51},{level:3,title:"方式二：使用脚本安装",slug:"方式二-使用脚本安装",normalizedTitle:"方式二：使用脚本安装",charIndex:190},{level:2,title:"镜像加速",slug:"镜像加速",normalizedTitle:"镜像加速",charIndex:826}],headersStr:"安装 方式一：使用Docker Desktop 安装 方式二：使用脚本安装 镜像加速",content:"# 安装\n\n提示\n\n如果是个人的开发环境下，推荐使用Docker Desktop，方便又快捷\n\n\n# 方式一：使用Docker Desktop 安装\n\nDocker 官网提供桌面安装程序 Docker Desktop，可以根据自己的操作系统选择，Docker Desktop 包含了Docker所有相关组件，方便快捷，但是要注意的是Docker Desktop 的条款。\n\n\n# 方式二：使用脚本安装\n\n如果是Linux Server的这类纯命令行系统，Docker 也针对此做了便携式的安装脚本，脚本如下（注意，有些操作系统如果不被支持，可前往官网查看相关文档）：\n\ncurl -fsSL https://get.docker.com -o get-docker.sh && sudo sh get-docker.sh && systemctl start docker\n\n\n上面脚本安装了基本的docker基本组件，如果有docker-compose使用需求的人，按照以下脚本执行即可，下的脚本是基于docker-compose 2.14.0 版本，如果需要特定版本可前往Github下载：https://github.com/docker/compose/releases，然后自行拆分脚本运行\n\nwget https://github.com/docker/compose/releases/download/v2.14.1/docker-compose-linux-x86_64 -O /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose && sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose && docker-compose --version\n\n\n\n# 镜像加速\n\n如果遇到由于拉取镜像的时间异常的长的话，可以配置镜像加速，可以参考和使用阿里云提供的镜像加速服务。",normalizedContent:"# 安装\n\n提示\n\n如果是个人的开发环境下，推荐使用docker desktop，方便又快捷\n\n\n# 方式一：使用docker desktop 安装\n\ndocker 官网提供桌面安装程序 docker desktop，可以根据自己的操作系统选择，docker desktop 包含了docker所有相关组件，方便快捷，但是要注意的是docker desktop 的条款。\n\n\n# 方式二：使用脚本安装\n\n如果是linux server的这类纯命令行系统，docker 也针对此做了便携式的安装脚本，脚本如下（注意，有些操作系统如果不被支持，可前往官网查看相关文档）：\n\ncurl -fssl https://get.docker.com -o get-docker.sh && sudo sh get-docker.sh && systemctl start docker\n\n\n上面脚本安装了基本的docker基本组件，如果有docker-compose使用需求的人，按照以下脚本执行即可，下的脚本是基于docker-compose 2.14.0 版本，如果需要特定版本可前往github下载：https://github.com/docker/compose/releases，然后自行拆分脚本运行\n\nwget https://github.com/docker/compose/releases/download/v2.14.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose && sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose && docker-compose --version\n\n\n\n# 镜像加速\n\n如果遇到由于拉取镜像的时间异常的长的话，可以配置镜像加速，可以参考和使用阿里云提供的镜像加速服务。",charsets:{cjk:!0},lastUpdated:"2022/12/21, 12:02:23",lastUpdatedTimestamp:1671595343e3},{title:"Docker 镜像",frontmatter:{title:"Docker 镜像",date:"2022-06-24T18:29:47.000Z",permalink:"/pages/6b922f/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/03.Docker%20%E9%95%9C%E5%83%8F.html",relativePath:"96.工具/01.Docker/03.Docker 镜像.md",key:"v-208af354",path:"/pages/6b922f/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:79},{level:3,title:"列出所有镜像",slug:"列出所有镜像",normalizedTitle:"列出所有镜像",charIndex:88},{level:3,title:"列出指定镜像列表",slug:"列出指定镜像列表",normalizedTitle:"列出指定镜像列表",charIndex:224},{level:3,title:"列出指定镜像的指定版本",slug:"列出指定镜像的指定版本",normalizedTitle:"列出指定镜像的指定版本",charIndex:279},{level:3,title:"拉取镜像",slug:"拉取镜像",normalizedTitle:"拉取镜像",charIndex:348},{level:3,title:"删除镜像",slug:"删除镜像",normalizedTitle:"删除镜像",charIndex:498},{level:2,title:"自定义镜像",slug:"自定义镜像",normalizedTitle:"自定义镜像",charIndex:706},{level:2,title:"更多docker images用法详解",slug:"更多docker-images用法详解",normalizedTitle:"更多docker images用法详解",charIndex:737}],headersStr:"概述 常用命令 列出所有镜像 列出指定镜像列表 列出指定镜像的指定版本 拉取镜像 删除镜像 自定义镜像 更多docker images用法详解",content:"# 概述\n\nDocker 镜像可以理解为就像安装操作系统一样需要一个镜像包（例如：Windows的iso镜像包），镜像本身包含了容器运行的程序内容。\n\n\n# 常用命令\n\n\n# 列出所有镜像\n\ndocker images\n\n\n选项           说明\nREPOSITORY   镜像源\nTAG          镜像版本\nIMAGE ID     镜像ID\nCREATED      镜像创建时间\nSIZE         镜像的大小\n\n\n# 列出指定镜像列表\n\n# docker images 镜像源\ndocker images redis\n\n\n\n# 列出指定镜像的指定版本\n\n# docker images 镜像源:镜像版本\ndcoker images redis:7.0.0\n\n\n\n# 拉取镜像\n\n# docker pull 镜像源\n# docker pull 镜像源:镜像版本\n\n# 这个是拉取最新版本\ndocker pull mysql\n\n# 这个拉取指定版本\ndocker pull mysql:8.0.28\n\n\n镜像搜索 https://hub.docker.com/\n\n\n# 删除镜像\n\n# docker rmi 镜像源\n# docker rmi 镜像源:镜像版本\n# docker rmi 镜像ID（注意可以省略，例如ID为a09124a3f90d，可以简写为 docker rmi a0，前提是避免有a0开头的其他镜像，不然会被一起删除）\n# docker rmi 镜像ID 镜像ID ...(删除多个镜像源)\n\n# 删除镜像mysql最新版\ndocker rmi mysql\n\n\n\n# 自定义镜像\n\n使用 Dockerfile 自定义镜像\n\n\n# 更多docker images用法详解\n\nhttps://docs.docker.com/engine/reference/commandline/images/",normalizedContent:"# 概述\n\ndocker 镜像可以理解为就像安装操作系统一样需要一个镜像包（例如：windows的iso镜像包），镜像本身包含了容器运行的程序内容。\n\n\n# 常用命令\n\n\n# 列出所有镜像\n\ndocker images\n\n\n选项           说明\nrepository   镜像源\ntag          镜像版本\nimage id     镜像id\ncreated      镜像创建时间\nsize         镜像的大小\n\n\n# 列出指定镜像列表\n\n# docker images 镜像源\ndocker images redis\n\n\n\n# 列出指定镜像的指定版本\n\n# docker images 镜像源:镜像版本\ndcoker images redis:7.0.0\n\n\n\n# 拉取镜像\n\n# docker pull 镜像源\n# docker pull 镜像源:镜像版本\n\n# 这个是拉取最新版本\ndocker pull mysql\n\n# 这个拉取指定版本\ndocker pull mysql:8.0.28\n\n\n镜像搜索 https://hub.docker.com/\n\n\n# 删除镜像\n\n# docker rmi 镜像源\n# docker rmi 镜像源:镜像版本\n# docker rmi 镜像id（注意可以省略，例如id为a09124a3f90d，可以简写为 docker rmi a0，前提是避免有a0开头的其他镜像，不然会被一起删除）\n# docker rmi 镜像id 镜像id ...(删除多个镜像源)\n\n# 删除镜像mysql最新版\ndocker rmi mysql\n\n\n\n# 自定义镜像\n\n使用 dockerfile 自定义镜像\n\n\n# 更多docker images用法详解\n\nhttps://docs.docker.com/engine/reference/commandline/images/",charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:15:39",lastUpdatedTimestamp:1671434139e3},{title:"Docker 容器",frontmatter:{title:"Docker 容器",date:"2022-07-01T10:29:51.000Z",permalink:"/pages/7e5b28/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/04.Docker%20%E5%AE%B9%E5%99%A8.html",relativePath:"96.工具/01.Docker/04.Docker 容器.md",key:"v-6e6b2235",path:"/pages/7e5b28/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"创建一个MySQL容器",slug:"创建一个mysql容器",normalizedTitle:"创建一个mysql容器",charIndex:245},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:524},{level:2,title:"更多高级用法",slug:"更多高级用法",normalizedTitle:"更多高级用法",charIndex:850}],headersStr:"概述 创建一个MySQL容器 常用命令 更多高级用法",content:"# 概述\n\nDocker 容器是Docker 镜像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到它，甚至可以根据其当前状态创建新映像。\n\n默认情况下，一个容器与其他容器及其主机的隔离相对较好。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。\n\n容器由其映像以及您在创建或启动它时提供给它的任何配置选项定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。\n\n\n# 创建一个MySQL容器\n\ndocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.29\n\n\n一个MySQL容器就创建好了，是不是很简单，不过类似数据库这种有状态的应用不推荐生产环境使用Docker创建参考自IT大咖说，但对于开发者的搭建环境来说简直是香~，用这个一下连接信息连接感受一下自己创建的第一个容器应用吧。\n\n说明     值\n连接地址   localhost\n端口     3306\n账号     root\n密码     123456\n\n\n# 常用命令\n\n# 查看所有正在运行的容器\ndocker ps\n\n# 查看所有容器\ndocker ps -a\n\n# 创建并运行容器\ndocker run --name 自定义的容器名 -p 宿主机端口:容器内端口 -e 自定义环境变量=变量值 -d 镜像源:镜像版本\n\n# 以下命令均支持多个容器操作\n# 启动一个已创建的容器\ndocker start 容器名或容器ID\n\n# 停止一个运行中的镜像\ndocker stop 容器名或容器ID\n\n# 给容器发送kill命令\ndocker kill 容器名或容器ID\n\n# 删除一个容器\ndocker rm 容器名或容器ID\n\n# 删除一个正在运行的容器\ndocker rm -f 容器名或容器ID\n\n\n\n# 更多高级用法\n\n使用 Docker compose 创建多应用容器\n\ndocker run 命令用法大全",normalizedContent:"# 概述\n\ndocker 容器是docker 镜像的可运行实例。您可以使用 docker api 或 cli 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到它，甚至可以根据其当前状态创建新映像。\n\n默认情况下，一个容器与其他容器及其主机的隔离相对较好。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。\n\n容器由其映像以及您在创建或启动它时提供给它的任何配置选项定义。当容器被移除时，任何未存储在持久存储中的状态更改都会消失。\n\n\n# 创建一个mysql容器\n\ndocker run --name mysql -p 3306:3306 -e mysql_root_password=123456 -d mysql:8.0.29\n\n\n一个mysql容器就创建好了，是不是很简单，不过类似数据库这种有状态的应用不推荐生产环境使用docker创建参考自it大咖说，但对于开发者的搭建环境来说简直是香~，用这个一下连接信息连接感受一下自己创建的第一个容器应用吧。\n\n说明     值\n连接地址   localhost\n端口     3306\n账号     root\n密码     123456\n\n\n# 常用命令\n\n# 查看所有正在运行的容器\ndocker ps\n\n# 查看所有容器\ndocker ps -a\n\n# 创建并运行容器\ndocker run --name 自定义的容器名 -p 宿主机端口:容器内端口 -e 自定义环境变量=变量值 -d 镜像源:镜像版本\n\n# 以下命令均支持多个容器操作\n# 启动一个已创建的容器\ndocker start 容器名或容器id\n\n# 停止一个运行中的镜像\ndocker stop 容器名或容器id\n\n# 给容器发送kill命令\ndocker kill 容器名或容器id\n\n# 删除一个容器\ndocker rm 容器名或容器id\n\n# 删除一个正在运行的容器\ndocker rm -f 容器名或容器id\n\n\n\n# 更多高级用法\n\n使用 docker compose 创建多应用容器\n\ndocker run 命令用法大全",charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:08:18",lastUpdatedTimestamp:1671433698e3},{title:"Dockerfile",frontmatter:{title:"Dockerfile",date:"2022-07-01T10:49:54.000Z",permalink:"/pages/571205/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/05.Dockerfile.html",relativePath:"96.工具/01.Docker/05.Dockerfile.md",key:"v-2eda8d39",path:"/pages/571205/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"快速上手",slug:"快速上手",normalizedTitle:"快速上手",charIndex:113},{level:3,title:"首先创建个基础应用",slug:"首先创建个基础应用",normalizedTitle:"首先创建个基础应用",charIndex:242},{level:3,title:"创建Dockerfile文件（和jar包在同一目录下）",slug:"创建dockerfile文件-和jar包在同一目录下",normalizedTitle:"创建dockerfile文件（和jar包在同一目录下）",charIndex:486},{level:2,title:"构建镜像",slug:"构建镜像",normalizedTitle:"构建镜像",charIndex:700},{level:2,title:"使用构建的镜像",slug:"使用构建的镜像",normalizedTitle:"使用构建的镜像",charIndex:1e3}],headersStr:"概述 快速上手 首先创建个基础应用 创建Dockerfile文件（和jar包在同一目录下） 构建镜像 使用构建的镜像",content:'# 概述\n\nDocker 可以通过读取来自 Dockerfile （一个文本文档），其中包含用户可以在命令行上调用以组装图像的所有命令。使用docker build 用户可以创建一个连续执行多个命令行指令的自动构建。\n\n\n# 快速上手\n\n> 这里以直接使用已打包好的jar配合docker构建自定义镜像，镜像构建不只这一种方式，例如：SpringBoot 构建 Docker 镜像的最佳 3 种方式，实际中应该以对应的硬件环境和资源进行选择，毕竟这个编程的世界没有银弹对吧~\n\n\n# 首先创建个基础应用\n\n使用 Spring 提供的 spring initializr 快速创建单应用，懒惰的同学可以直接IDEA创建，然后随便写个rest api，用于测试使用，并将其打包成可执行jar包\n\n@RestController\npublic class DemoCon {\n    @GetMapping("/docker")\n    public String docker() {\n        return "hello docker!";\n    }\n}\n\n\n\n# 创建Dockerfile文件（和jar包在同一目录下）\n\n# 需要依赖的其他环境（镜像源）\nFROM amazoncorretto:8u332\n# 把宿主机的文件拷贝到容器指定目录\nCOPY easy-upload.jar /opt\n# 暴露的接口\nEXPOSE 5680\n# 容器启动后执行的命令\nCMD cd /opt && java -Xmx512m -Xms512m -jar easy-upload.jar\n\n\n\n# 构建镜像\n\n# -t 是指定镜像源名称和版本，末尾的点是指当前的Dockerfile文件（Docker 的约定）\ndocker build -t easy-upload:1.0.0 .\n\n# 如果有多个命令可以在其他目录创建Dockerfile（注意，COPY 命令只能从 Dockerfile 所在文件为基础的相对路径，也就是需要把jar复制到Dockerfile同目录下）\ndocker build -t easy-upload:1.0.0 -f ./mydockerfile .\n\n\n通过命令 docker images easy-upload:1.0.0查看一下我们自定义构建的镜像\n\n\n# 使用构建的镜像\n\n# 创建容器\ndocker run --name easy-upload -p 5680:5680 -d easy-upload:1.0.0\n\n# 查看容器运行\ndocker ps\n\n\n浏览器验证一下，OK！',normalizedContent:'# 概述\n\ndocker 可以通过读取来自 dockerfile （一个文本文档），其中包含用户可以在命令行上调用以组装图像的所有命令。使用docker build 用户可以创建一个连续执行多个命令行指令的自动构建。\n\n\n# 快速上手\n\n> 这里以直接使用已打包好的jar配合docker构建自定义镜像，镜像构建不只这一种方式，例如：springboot 构建 docker 镜像的最佳 3 种方式，实际中应该以对应的硬件环境和资源进行选择，毕竟这个编程的世界没有银弹对吧~\n\n\n# 首先创建个基础应用\n\n使用 spring 提供的 spring initializr 快速创建单应用，懒惰的同学可以直接idea创建，然后随便写个rest api，用于测试使用，并将其打包成可执行jar包\n\n@restcontroller\npublic class democon {\n    @getmapping("/docker")\n    public string docker() {\n        return "hello docker!";\n    }\n}\n\n\n\n# 创建dockerfile文件（和jar包在同一目录下）\n\n# 需要依赖的其他环境（镜像源）\nfrom amazoncorretto:8u332\n# 把宿主机的文件拷贝到容器指定目录\ncopy easy-upload.jar /opt\n# 暴露的接口\nexpose 5680\n# 容器启动后执行的命令\ncmd cd /opt && java -xmx512m -xms512m -jar easy-upload.jar\n\n\n\n# 构建镜像\n\n# -t 是指定镜像源名称和版本，末尾的点是指当前的dockerfile文件（docker 的约定）\ndocker build -t easy-upload:1.0.0 .\n\n# 如果有多个命令可以在其他目录创建dockerfile（注意，copy 命令只能从 dockerfile 所在文件为基础的相对路径，也就是需要把jar复制到dockerfile同目录下）\ndocker build -t easy-upload:1.0.0 -f ./mydockerfile .\n\n\n通过命令 docker images easy-upload:1.0.0查看一下我们自定义构建的镜像\n\n\n# 使用构建的镜像\n\n# 创建容器\ndocker run --name easy-upload -p 5680:5680 -d easy-upload:1.0.0\n\n# 查看容器运行\ndocker ps\n\n\n浏览器验证一下，ok！',charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:15:39",lastUpdatedTimestamp:1671434139e3},{title:"Docker compose",frontmatter:{title:"Docker compose",date:"2022-07-01T10:56:00.000Z",permalink:"/pages/ee7caf/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/06.Docker%20compose.html",relativePath:"96.工具/01.Docker/06.Docker compose.md",key:"v-64a3dc1c",path:"/pages/ee7caf/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:160},{level:2,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:394},{level:2,title:"Docker-compose 和 Dockerfile",slug:"docker-compose-和-dockerfile",normalizedTitle:"docker-compose 和 dockerfile",charIndex:1766},{level:2,title:"常用环境的Docker-compose定义",slug:"常用环境的docker-compose定义",normalizedTitle:"常用环境的docker-compose定义",charIndex:2143}],headersStr:"概述 示例 环境变量 Docker-compose 和 Dockerfile 常用环境的Docker-compose定义",content:'# 概述\n\nDocker compose 文件是一个YAML文件，它为 Docker 应用程序定义服务、网络和卷。Compose 文件格式的最新和推荐版本由Compose 规范定义。Compose 规范合并了旧的 2.x 和 3.x 版本，聚合了这些格式的属性，并由**Compose 1.27.0+**实现。\n\n\n# 示例\n\n使用Docker compose启动一个MySQL实例，新建文件docker-compose.yml\n\nversion: "3.9"\n\nservices:\n  # services里的唯一标识\n  mysql:\n    # 容器名称，全局唯一\n    container_name: mysql\n    # 镜像源\n    image: mysql:8.0.29\n    # 端口映射\n    ports:\n      - "3306:3306"\n    # 环境变量\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n\n\n> 更多用法参考文档\n\n在docker-compose.yml目录下执行\n\n# 启动所有定义的services（容器）\ndocker-compose up -d\n\n# 删除所有定义的容器\ndocker-compose down\n\n\n形式和通过命令的执行结果相同，docker-compose可以定义多个容器，简化多容器部署的步骤，同时docker-compose还可以和Dockerfile一起使用，例如：创建多个MySQL容器应用：\n\n创建多个MySQL容器应用：\n\nversion: "3.9"\n\nservices:\n  mysql1:\n    container_name: mysql1\n    image: mysql:8.0.29\n    ports:\n      - "13306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n  mysql2:\n    container_name: mysql2\n    image: mysql:8.0.29\n    ports:\n      - "23306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n  mysql3:\n    container_name: mysql3\n    image: mysql:8.0.29\n    ports:\n      - "33306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n\n\n\n# 环境变量\n\n同Docker-compose.yml文件目录下，新建文件.env，在文件中写入如下内容：\n\nMYSQL_VERSION=8.0.29\n\n\n上述多个MySQL示例应用可改写如下\n\nversion: "3.9"\n\nservices:\n  mysql1:\n    container_name: mysql1\n    # 可直接使用环境变量，方便多个容器共同修改\n    image: mysql:${MYSQL_VERSION}\n    ports:\n      - "13306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n  mysql2:\n    container_name: mysql2\n    image: mysql:${MYSQL_VERSION}\n    ports:\n      - "23306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n  mysql3:\n    container_name: mysql3\n    image: mysql:${MYSQL_VERSION}\n    ports:\n      - "33306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n\n\n\n# Docker-compose 和 Dockerfile\n\n在上一章节的Dockerfile为例，结合Docker-compose实现部署，同Dockerfile 和 jar 包文件目录下，新建docker-compose.yml\n\n目录结构如下：\n\nversion: "3.9"\n\nservices:\n  easy-upload:\n    # Dockerfile的构建属性（相对路径）\n    build: .\n    container_name: easy-upload\n    image: easy-upload:1.0.0\n    ports:\n      - "5680:5680"\n\n\n# 该命令会执行自定义镜像的构建到容器的创建运行\ndocker-compose up -d --build --force-recreate\n\n\n\n# 常用环境的Docker-compose定义\n\nversion: "3.9"\n\nservices:\n  mysql:\n    container_name: mysql\n    image: mysql:5.0.29\n    volumes:\n      - ./data/mysql:/var/lib/mysql # 数据卷的映射\n      - ./data/init.sql:/docker-entrypoint-initdb.d # 默认执行SQL文件，只会执行一次（容器未创建的前提下）\n    ports:\n      - "3306:3306"\n    environment:\n      MYSQL_ROOT_PASSWORD: 123456\n    command: [\n      "--character-set-server=utf8mb4",  # 设置字符集\n      "--collation-server=utf8mb4_unicode_ci"\n    ]\n  mongo:\n    image: mongo:4\n    container_name: mongo\n    volumes:\n      - ./data/mongo/db:/data/db #数据文件挂载\n    ports:\n      - 27017:27017\n  nacos:\n    image: nacos/nacos-server:v2.1.0\n    container_name: nacos-standalone\n    environment:\n      - PREFER_HOST_MODE=hostname\n      - MODE=standalone # 单机模式\n    volumes:\n      - ./data/nacos-standalone/logs/:/home/nacos/logs\n    ports:\n      - "8848:8848"\n  prometheus:\n    container_name: prometheus\n    image: prom/prometheus:latest\n    ports:\n      - "9090:9090"\n    depends_on:\n      - nacos\n  grafana:\n    container_name: grafana\n    image: grafana/grafana:latest\n    ports:\n      - "3000:3000"\n  postgres:\n    container_name: postgres\n    image: postgres:14\n    environment:\n      POSTGRES_PASSWORD: 123456\n    ports:\n      - "5432:5432"\n    volumes:\n      - ./data/postgresql/data:/var/lib/postgresql/data\n  redis:\n    image: redis:7.0.0\n    container_name: redis\n    command: redis-server --appendonly yes\n    volumes:\n      - ./data/redis/data:/data #数据文件挂载\n    ports:\n      - 6379:6379\n  rabbitmq:\n    image: rabbitmq:3.9-management\n    container_name: rabbitmq\n    volumes:\n      - ./data/rabbitmq/data:/var/lib/rabbitmq #数据文件挂载\n      - ./data/rabbitmq/log:/var/log/rabbitmq #日志文件挂载\n    ports:\n      - 5672:5672\n      - 15672:15672\n  elasticsearch:\n    image: elasticsearch:7.17.3\n    container_name: elasticsearch\n    environment:\n      - "cluster.name=elasticsearch" #设置集群名称为elasticsearch\n      - "discovery.type=single-node" #以单一节点模式启动\n      - "ES_JAVA_OPTS=-Xms512m -Xmx1024m" #设置使用jvm内存大小\n    volumes:\n      - ./data/elasticsearch/plugins:/usr/share/elasticsearch/plugins #插件文件挂载\n      - ./data/elasticsearch/data:/usr/share/elasticsearch/data #数据文件挂载\n    ports:\n      - 9200:9200\n      - 9300:9300\n',normalizedContent:'# 概述\n\ndocker compose 文件是一个yaml文件，它为 docker 应用程序定义服务、网络和卷。compose 文件格式的最新和推荐版本由compose 规范定义。compose 规范合并了旧的 2.x 和 3.x 版本，聚合了这些格式的属性，并由**compose 1.27.0+**实现。\n\n\n# 示例\n\n使用docker compose启动一个mysql实例，新建文件docker-compose.yml\n\nversion: "3.9"\n\nservices:\n  # services里的唯一标识\n  mysql:\n    # 容器名称，全局唯一\n    container_name: mysql\n    # 镜像源\n    image: mysql:8.0.29\n    # 端口映射\n    ports:\n      - "3306:3306"\n    # 环境变量\n    environment:\n      mysql_root_password: 123456\n\n\n> 更多用法参考文档\n\n在docker-compose.yml目录下执行\n\n# 启动所有定义的services（容器）\ndocker-compose up -d\n\n# 删除所有定义的容器\ndocker-compose down\n\n\n形式和通过命令的执行结果相同，docker-compose可以定义多个容器，简化多容器部署的步骤，同时docker-compose还可以和dockerfile一起使用，例如：创建多个mysql容器应用：\n\n创建多个mysql容器应用：\n\nversion: "3.9"\n\nservices:\n  mysql1:\n    container_name: mysql1\n    image: mysql:8.0.29\n    ports:\n      - "13306:3306"\n    environment:\n      mysql_root_password: 123456\n  mysql2:\n    container_name: mysql2\n    image: mysql:8.0.29\n    ports:\n      - "23306:3306"\n    environment:\n      mysql_root_password: 123456\n  mysql3:\n    container_name: mysql3\n    image: mysql:8.0.29\n    ports:\n      - "33306:3306"\n    environment:\n      mysql_root_password: 123456\n\n\n\n# 环境变量\n\n同docker-compose.yml文件目录下，新建文件.env，在文件中写入如下内容：\n\nmysql_version=8.0.29\n\n\n上述多个mysql示例应用可改写如下\n\nversion: "3.9"\n\nservices:\n  mysql1:\n    container_name: mysql1\n    # 可直接使用环境变量，方便多个容器共同修改\n    image: mysql:${mysql_version}\n    ports:\n      - "13306:3306"\n    environment:\n      mysql_root_password: 123456\n  mysql2:\n    container_name: mysql2\n    image: mysql:${mysql_version}\n    ports:\n      - "23306:3306"\n    environment:\n      mysql_root_password: 123456\n  mysql3:\n    container_name: mysql3\n    image: mysql:${mysql_version}\n    ports:\n      - "33306:3306"\n    environment:\n      mysql_root_password: 123456\n\n\n\n# docker-compose 和 dockerfile\n\n在上一章节的dockerfile为例，结合docker-compose实现部署，同dockerfile 和 jar 包文件目录下，新建docker-compose.yml\n\n目录结构如下：\n\nversion: "3.9"\n\nservices:\n  easy-upload:\n    # dockerfile的构建属性（相对路径）\n    build: .\n    container_name: easy-upload\n    image: easy-upload:1.0.0\n    ports:\n      - "5680:5680"\n\n\n# 该命令会执行自定义镜像的构建到容器的创建运行\ndocker-compose up -d --build --force-recreate\n\n\n\n# 常用环境的docker-compose定义\n\nversion: "3.9"\n\nservices:\n  mysql:\n    container_name: mysql\n    image: mysql:5.0.29\n    volumes:\n      - ./data/mysql:/var/lib/mysql # 数据卷的映射\n      - ./data/init.sql:/docker-entrypoint-initdb.d # 默认执行sql文件，只会执行一次（容器未创建的前提下）\n    ports:\n      - "3306:3306"\n    environment:\n      mysql_root_password: 123456\n    command: [\n      "--character-set-server=utf8mb4",  # 设置字符集\n      "--collation-server=utf8mb4_unicode_ci"\n    ]\n  mongo:\n    image: mongo:4\n    container_name: mongo\n    volumes:\n      - ./data/mongo/db:/data/db #数据文件挂载\n    ports:\n      - 27017:27017\n  nacos:\n    image: nacos/nacos-server:v2.1.0\n    container_name: nacos-standalone\n    environment:\n      - prefer_host_mode=hostname\n      - mode=standalone # 单机模式\n    volumes:\n      - ./data/nacos-standalone/logs/:/home/nacos/logs\n    ports:\n      - "8848:8848"\n  prometheus:\n    container_name: prometheus\n    image: prom/prometheus:latest\n    ports:\n      - "9090:9090"\n    depends_on:\n      - nacos\n  grafana:\n    container_name: grafana\n    image: grafana/grafana:latest\n    ports:\n      - "3000:3000"\n  postgres:\n    container_name: postgres\n    image: postgres:14\n    environment:\n      postgres_password: 123456\n    ports:\n      - "5432:5432"\n    volumes:\n      - ./data/postgresql/data:/var/lib/postgresql/data\n  redis:\n    image: redis:7.0.0\n    container_name: redis\n    command: redis-server --appendonly yes\n    volumes:\n      - ./data/redis/data:/data #数据文件挂载\n    ports:\n      - 6379:6379\n  rabbitmq:\n    image: rabbitmq:3.9-management\n    container_name: rabbitmq\n    volumes:\n      - ./data/rabbitmq/data:/var/lib/rabbitmq #数据文件挂载\n      - ./data/rabbitmq/log:/var/log/rabbitmq #日志文件挂载\n    ports:\n      - 5672:5672\n      - 15672:15672\n  elasticsearch:\n    image: elasticsearch:7.17.3\n    container_name: elasticsearch\n    environment:\n      - "cluster.name=elasticsearch" #设置集群名称为elasticsearch\n      - "discovery.type=single-node" #以单一节点模式启动\n      - "es_java_opts=-xms512m -xmx1024m" #设置使用jvm内存大小\n    volumes:\n      - ./data/elasticsearch/plugins:/usr/share/elasticsearch/plugins #插件文件挂载\n      - ./data/elasticsearch/data:/usr/share/elasticsearch/data #数据文件挂载\n    ports:\n      - 9200:9200\n      - 9300:9300\n',charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:08:18",lastUpdatedTimestamp:1671433698e3},{title:"玩转Docker",frontmatter:{title:"玩转Docker",date:"2022-07-01T10:57:56.000Z",permalink:"/pages/c6bb18/"},regularPath:"/96.%E5%B7%A5%E5%85%B7/01.Docker/99.%E7%8E%A9%E8%BD%ACDocker.html",relativePath:"96.工具/01.Docker/99.玩转Docker.md",key:"v-4bbe2486",path:"/pages/c6bb18/",headersStr:null,content:"想啥呢，一个页面说明你就想玩转Docker了，上面章节只是让你简单感受Docker大概使用，让你有一个对Docker一个大致的了解，最好的、最新的学习材料永远是官方文档。",normalizedContent:"想啥呢，一个页面说明你就想玩转docker了，上面章节只是让你简单感受docker大概使用，让你有一个对docker一个大致的了解，最好的、最新的学习材料永远是官方文档。",charsets:{cjk:!0},lastUpdated:"2022/12/19, 15:08:18",lastUpdatedTimestamp:1671433698e3},{title:"SSL 证书申请",frontmatter:{title:"SSL 证书申请",date:"2022-10-14T17:20:56.000Z",permalink:"/pages/d9e60d/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/01.SSL%20%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7.html",relativePath:"97.笔记/01.SSL 证书申请.md",key:"v-6d925efc",path:"/pages/d9e60d/",headers:[{level:2,title:"方式1：acme.sh",slug:"方式1-acme-sh",normalizedTitle:"方式1：acme.sh",charIndex:15},{level:3,title:"1.安装acme.sh",slug:"_1-安装acme-sh",normalizedTitle:"1.安装acme.sh",charIndex:83},{level:3,title:"2.source",slug:"_2-source",normalizedTitle:"2.source",charIndex:208},{level:3,title:"3.生成证书（这里采用DNS方式，HTTP方式请前往Github查看）",slug:"_3-生成证书-这里采用dns方式-http方式请前往github查看",normalizedTitle:"3.生成证书（这里采用dns方式，http方式请前往github查看）",charIndex:240},{level:3,title:"4.安装证书（不要直接引用acme生成的路径，也不要使用复制的方式，手动复制会使自动更新失效）",slug:"_4-安装证书-不要直接引用acme生成的路径-也不要使用复制的方式-手动复制会使自动更新失效",normalizedTitle:"4.安装证书（不要直接引用acme生成的路径，也不要使用复制的方式，手动复制会使自动更新失效）",charIndex:588},{level:3,title:"5.配置 Nginx",slug:"_5-配置-nginx",normalizedTitle:"5.配置 nginx",charIndex:853},{level:3,title:"6.完成",slug:"_6-完成",normalizedTitle:"6.完成",charIndex:1764}],headersStr:"方式1：acme.sh 1.安装acme.sh 2.source 3.生成证书（这里采用DNS方式，HTTP方式请前往Github查看） 4.安装证书（不要直接引用acme生成的路径，也不要使用复制的方式，手动复制会使自动更新失效） 5.配置 Nginx 6.完成",content:'# SSL 证书申请\n\n\n# 方式1：acme.sh\n\n该方式基于 Ubuntu 20.04、Nginx 1.22 测试通过，更多用法可前往Github查看\n\n\n# 1.安装acme.sh\n\n先安装socat\n\napt install socat -y\n\n\n邮箱替换成自己的\n\ncurl https://get.acme.sh | sh -s email=chen1406736605@gmail.com\n\n\n\n# 2.source\n\nsource ~/.bashrc\n\n\n\n# 3.生成证书（这里采用DNS方式，HTTP方式请前往Github查看）\n\n设置dns运营商的识别 ID 和 Secret (已设置的无需重复设置)，acme也支持多家dsn运营商，我这里采用的是阿里云\n\nexport Ali_Key="sdfsdfsdfljlbjkljlkjsdfoiwje"\nexport Ali_Secret="jlsdflanljkljlfdsaklkjflsa"\n\n\n切换CA机构（默认ZeroSSL，ZeroSSL老是容易超时，中意ZeroSSL可以忽略）\n\nacme.sh --set-default-ca --server letsencrypt\n\n\n申请证书\n\nacme.sh --issue --dns dns_ali -d example.com\n\n\n\n# 4.安装证书（不要直接引用acme生成的路径，也不要使用复制的方式，手动复制会使自动更新失效）\n\n这里的路径就是实际就是你想存放证书的路径，对应文件夹要提前创建（例如我习惯放置的路径为/etc/nginx/ssl/域名）\n\nacme.sh --install-cert -d example.com \\\n--key-file       /etc/nginx/ssl/example.com/key.pem  \\\n--fullchain-file /etc/nginx/ssl/example.com/cert.pem\n\n\n\n# 5.配置 Nginx\n\n#以下属性中，以ssl开头的属性表示与证书配置有关。\nserver {\n    listen 443 ssl;\n    #配置HTTPS的默认访问端口为443。\n    #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。\n    #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。\n    server_name example.com;\n    ssl_certificate /etc/nginx/ssl/example.com/cert.pem;\n    ssl_certificate_key /etc/nginx/ssl/example.com/key.pem; \n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    #表示使用的加密套件的类型。\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。\n    ssl_prefer_server_ciphers on;\n    location / {\n        root html;  #Web网站程序存放目录。\n        index index.html index.htm;\n    }\n}\n\nserver {\n    listen 80;\n    server_name example.com; #需要将yourdomain替换成证书绑定的域名。\n    rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。\n    location / {\n        index index.html index.htm;\n    }\n}\n\n\n\n# 6.完成\n\n可以尝试检测或访问\n\nhttps://myssl.com/ssl.html\n\n\n更新：acme.sh会自动更新证书',normalizedContent:'# ssl 证书申请\n\n\n# 方式1：acme.sh\n\n该方式基于 ubuntu 20.04、nginx 1.22 测试通过，更多用法可前往github查看\n\n\n# 1.安装acme.sh\n\n先安装socat\n\napt install socat -y\n\n\n邮箱替换成自己的\n\ncurl https://get.acme.sh | sh -s email=chen1406736605@gmail.com\n\n\n\n# 2.source\n\nsource ~/.bashrc\n\n\n\n# 3.生成证书（这里采用dns方式，http方式请前往github查看）\n\n设置dns运营商的识别 id 和 secret (已设置的无需重复设置)，acme也支持多家dsn运营商，我这里采用的是阿里云\n\nexport ali_key="sdfsdfsdfljlbjkljlkjsdfoiwje"\nexport ali_secret="jlsdflanljkljlfdsaklkjflsa"\n\n\n切换ca机构（默认zerossl，zerossl老是容易超时，中意zerossl可以忽略）\n\nacme.sh --set-default-ca --server letsencrypt\n\n\n申请证书\n\nacme.sh --issue --dns dns_ali -d example.com\n\n\n\n# 4.安装证书（不要直接引用acme生成的路径，也不要使用复制的方式，手动复制会使自动更新失效）\n\n这里的路径就是实际就是你想存放证书的路径，对应文件夹要提前创建（例如我习惯放置的路径为/etc/nginx/ssl/域名）\n\nacme.sh --install-cert -d example.com \\\n--key-file       /etc/nginx/ssl/example.com/key.pem  \\\n--fullchain-file /etc/nginx/ssl/example.com/cert.pem\n\n\n\n# 5.配置 nginx\n\n#以下属性中，以ssl开头的属性表示与证书配置有关。\nserver {\n    listen 443 ssl;\n    #配置https的默认访问端口为443。\n    #如果未在此处配置https的默认访问端口，可能会造成nginx无法启动。\n    #如果您使用nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。\n    server_name example.com;\n    ssl_certificate /etc/nginx/ssl/example.com/cert.pem;\n    ssl_certificate_key /etc/nginx/ssl/example.com/key.pem; \n    ssl_session_timeout 5m;\n    ssl_ciphers ecdhe-rsa-aes128-gcm-sha256:ecdhe:ecdh:aes:high:!null:!anull:!md5:!adh:!rc4;\n    #表示使用的加密套件的类型。\n    ssl_protocols tlsv1.1 tlsv1.2 tlsv1.3; #表示使用的tls协议的类型，您需要自行评估是否配置tlsv1.1协议。\n    ssl_prefer_server_ciphers on;\n    location / {\n        root html;  #web网站程序存放目录。\n        index index.html index.htm;\n    }\n}\n\nserver {\n    listen 80;\n    server_name example.com; #需要将yourdomain替换成证书绑定的域名。\n    rewrite ^(.*)$ https://$host$1; #将所有http请求通过rewrite指令重定向到https。\n    location / {\n        index index.html index.htm;\n    }\n}\n\n\n\n# 6.完成\n\n可以尝试检测或访问\n\nhttps://myssl.com/ssl.html\n\n\n更新：acme.sh会自动更新证书',charsets:{cjk:!0},lastUpdated:"2022/10/31, 14:12:53",lastUpdatedTimestamp:1667196773e3},{title:"Postgresql 安装和访问",frontmatter:{title:"Postgresql 安装和访问",date:"2022-10-26T14:51:05.000Z",permalink:"/pages/71a585/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/02.Postgresql%20%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BF%E9%97%AE.html",relativePath:"97.笔记/02.Postgresql 安装和访问.md",key:"v-25f42d5c",path:"/pages/71a585/",headers:[{level:2,title:"1.安装",slug:"_1-安装",normalizedTitle:"1.安装",charIndex:2},{level:2,title:"2.修改密码",slug:"_2-修改密码",normalizedTitle:"2.修改密码",charIndex:392},{level:2,title:"3.设置外网访问",slug:"_3-设置外网访问",normalizedTitle:"3.设置外网访问",charIndex:534},{level:2,title:"4. 常用命令",slug:"_4-常用命令",normalizedTitle:"4. 常用命令",charIndex:2635}],headersStr:"1.安装 2.修改密码 3.设置外网访问 4. 常用命令",content:"# 1.安装\n\n提示\n\n该安装环境采用 Debain 11，其他系统可参照官方文档\n\n创建文件存储库配置\n\nsh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list'\n\n\n导入存储库签名密钥\n\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | apt-key add -\n\n\n更新软件包列表\n\napt update\n\n\n安装默认默认版本\n\napt install postgresql -y\n\n\n安装特定版本（-后面为你想要的版本）\n\napt install postgresql-14 -y\n\n\n\n# 2.修改密码\n\nPostgresql 会默认创建一个 postgres 用户，切换用户\n\nsu postgres\n\n\n然后就可以使用psql命令交互工具使用\n\npsql\n\n\n修改密码\n\nalter user postgres with password '123456';\n\n\n\n# 3.设置外网访问\n\n如果不清楚配置文件路径存放的可以查看进程\n\nps -ef|grep postgresql\n\n\n结果如下\n\npostgres    8451       1  0 14:44 ?        00:00:00 /usr/lib/postgresql/14/bin/postgres -D /var/lib/postgresql/14/main -c \t\tconfig_file=/etc/postgresql/14/main/postgresql.conf\nroot        9043    8507  0 15:38 pts/1    00:00:00 grep postgresql\n\n\n修改配置文件postgresql.conf，将listen_addresses的值改为*，记得去掉前面的#注释，同时该文件有pg_hba.conf的文件路径，这个文件也要修改\n\nvi /etc/postgresql/14/main/postgresql.conf\n\n\n文件部分内容如下\n\n#------------------------------------------------------------------------------\n# FILE LOCATIONS\n#------------------------------------------------------------------------------\n\n# The default values of these variables are driven from the -D command-line\n# option or PGDATA environment variable, represented here as ConfigDir.\n\ndata_directory = '/var/lib/postgresql/14/main'\t\t# use data in another directory\n\t\t\t\t\t# (change requires restart)\nhba_file = '/etc/postgresql/14/main/pg_hba.conf'\t# host-based authentication file\n\t\t\t\t\t# (change requires restart)\nident_file = '/etc/postgresql/14/main/pg_ident.conf'\t# ident configuration file\n\t\t\t\t\t# (change requires restart)\n\n# If external_pid_file is not explicitly set, no extra PID file is written.\nexternal_pid_file = '/var/run/postgresql/14-main.pid'\t\t\t# write an extra PID file\n\t\t\t\t\t# (change requires restart)\n\n\n#------------------------------------------------------------------------------\n# CONNECTIONS AND AUTHENTICATION\n#------------------------------------------------------------------------------\n\n# - Connection Settings -\n\nlisten_addresses = '*'  \t\t# what IP address(es) to listen on;\n\t\t\t\t\t# comma-separated list of addresses;\n\t\t\t\t\t# defaults to 'localhost'; use '*' for all\n\t\t\t\t\t# (change requires restart)\nport = 5432\t\t\t\t# (change requires restart)\nmax_connections = 100\t\t\t# (change requires restart)\n#superuser_reserved_connections = 3\t# (change requires restart)\nunix_socket_directories = '/var/run/postgresql'\t# comma-separated list of directories\n\n\n修改配置文件pg_hba.conf，直接在文件末尾添加以下配置项，可根据需要自己调整对应值\n\nhost all all 0.0.0.0/0 md5\n\n\n重启 Postgresql\n\nsystemctl restart postgresql.service\n\n\n\n# 4. 常用命令\n\n修改用户密码\n\nalter user postgres with password '123456';\n\n\n创建普通用户\n\ncreate user test encrypted password '123456';\n\n\n创建超级用户\n\ncreate user test superuser encrypted password '123456';\n\n\n将超级用户改为普通用户\n\nalter user test nosuperuser;\n\n\n普通用户改为超级用户\n\nalter user test superuser;\n\n\n设置不允许/允许其登录\n\nalter user test nologin;\nalter user test login;\n",normalizedContent:"# 1.安装\n\n提示\n\n该安装环境采用 debain 11，其他系统可参照官方文档\n\n创建文件存储库配置\n\nsh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list'\n\n\n导入存储库签名密钥\n\nwget --quiet -o - https://www.postgresql.org/media/keys/accc4cf8.asc | apt-key add -\n\n\n更新软件包列表\n\napt update\n\n\n安装默认默认版本\n\napt install postgresql -y\n\n\n安装特定版本（-后面为你想要的版本）\n\napt install postgresql-14 -y\n\n\n\n# 2.修改密码\n\npostgresql 会默认创建一个 postgres 用户，切换用户\n\nsu postgres\n\n\n然后就可以使用psql命令交互工具使用\n\npsql\n\n\n修改密码\n\nalter user postgres with password '123456';\n\n\n\n# 3.设置外网访问\n\n如果不清楚配置文件路径存放的可以查看进程\n\nps -ef|grep postgresql\n\n\n结果如下\n\npostgres    8451       1  0 14:44 ?        00:00:00 /usr/lib/postgresql/14/bin/postgres -d /var/lib/postgresql/14/main -c \t\tconfig_file=/etc/postgresql/14/main/postgresql.conf\nroot        9043    8507  0 15:38 pts/1    00:00:00 grep postgresql\n\n\n修改配置文件postgresql.conf，将listen_addresses的值改为*，记得去掉前面的#注释，同时该文件有pg_hba.conf的文件路径，这个文件也要修改\n\nvi /etc/postgresql/14/main/postgresql.conf\n\n\n文件部分内容如下\n\n#------------------------------------------------------------------------------\n# file locations\n#------------------------------------------------------------------------------\n\n# the default values of these variables are driven from the -d command-line\n# option or pgdata environment variable, represented here as configdir.\n\ndata_directory = '/var/lib/postgresql/14/main'\t\t# use data in another directory\n\t\t\t\t\t# (change requires restart)\nhba_file = '/etc/postgresql/14/main/pg_hba.conf'\t# host-based authentication file\n\t\t\t\t\t# (change requires restart)\nident_file = '/etc/postgresql/14/main/pg_ident.conf'\t# ident configuration file\n\t\t\t\t\t# (change requires restart)\n\n# if external_pid_file is not explicitly set, no extra pid file is written.\nexternal_pid_file = '/var/run/postgresql/14-main.pid'\t\t\t# write an extra pid file\n\t\t\t\t\t# (change requires restart)\n\n\n#------------------------------------------------------------------------------\n# connections and authentication\n#------------------------------------------------------------------------------\n\n# - connection settings -\n\nlisten_addresses = '*'  \t\t# what ip address(es) to listen on;\n\t\t\t\t\t# comma-separated list of addresses;\n\t\t\t\t\t# defaults to 'localhost'; use '*' for all\n\t\t\t\t\t# (change requires restart)\nport = 5432\t\t\t\t# (change requires restart)\nmax_connections = 100\t\t\t# (change requires restart)\n#superuser_reserved_connections = 3\t# (change requires restart)\nunix_socket_directories = '/var/run/postgresql'\t# comma-separated list of directories\n\n\n修改配置文件pg_hba.conf，直接在文件末尾添加以下配置项，可根据需要自己调整对应值\n\nhost all all 0.0.0.0/0 md5\n\n\n重启 postgresql\n\nsystemctl restart postgresql.service\n\n\n\n# 4. 常用命令\n\n修改用户密码\n\nalter user postgres with password '123456';\n\n\n创建普通用户\n\ncreate user test encrypted password '123456';\n\n\n创建超级用户\n\ncreate user test superuser encrypted password '123456';\n\n\n将超级用户改为普通用户\n\nalter user test nosuperuser;\n\n\n普通用户改为超级用户\n\nalter user test superuser;\n\n\n设置不允许/允许其登录\n\nalter user test nologin;\nalter user test login;\n",charsets:{cjk:!0},lastUpdated:"2022/10/26, 16:16:32",lastUpdatedTimestamp:1666772192e3},{title:"Linux 设置虚拟内存",frontmatter:{title:"Linux 设置虚拟内存",date:"2022-10-26T16:07:38.000Z",permalink:"/pages/64f05e/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/03.Linux%20%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.html",relativePath:"97.笔记/03.Linux 设置虚拟内存.md",key:"v-1253b9e4",path:"/pages/64f05e/",headers:[{level:2,title:"查看虚拟内存",slug:"查看虚拟内存",normalizedTitle:"查看虚拟内存",charIndex:59},{level:2,title:"创建虚拟内存配置文件",slug:"创建虚拟内存配置文件",normalizedTitle:"创建虚拟内存配置文件",charIndex:77},{level:2,title:"再次查看虚拟内存（执行命令可以看到新增了2G）",slug:"再次查看虚拟内存-执行命令可以看到新增了2g",normalizedTitle:"再次查看虚拟内存（执行命令可以看到新增了2g）",charIndex:317},{level:2,title:"如果需要释放的话（执行命令后，删除创建的swap目录即可）",slug:"如果需要释放的话-执行命令后-删除创建的swap目录即可",normalizedTitle:"如果需要释放的话（执行命令后，删除创建的swap目录即可）",charIndex:352},{level:2,title:"如果需要开机自动使用该虚拟内存的话，则需要加入到启动脚本",slug:"如果需要开机自动使用该虚拟内存的话-则需要加入到启动脚本",normalizedTitle:"如果需要开机自动使用该虚拟内存的话，则需要加入到启动脚本",charIndex:410}],headersStr:"查看虚拟内存 创建虚拟内存配置文件 再次查看虚拟内存（执行命令可以看到新增了2G） 如果需要释放的话（执行命令后，删除创建的swap目录即可） 如果需要开机自动使用该虚拟内存的话，则需要加入到启动脚本",content:"提示\n\n该操作流程采用 Ubuntu 20.04 操作系统，Debain 如无 sudo 命令则可以去掉即可\n\n\n# 查看虚拟内存\n\nfree\n\n\n\n# 创建虚拟内存配置文件\n\n新建文件夹\n\nmkdir /swap\n\n\n进入文件夹\n\ncd /swap\n\n\n创建虚拟文件，bs 为块的大小，count 创建多少个块\n\nsudo dd if=/dev/zero of=swapfile bs=1M count=2048\n\n\n修改权限\n\nsudo chmod 0600 swapfile\n\n\n把生成的文件转换成 Swap 文件\n\nsudo mkswap swapfile\n\n\n激活文件\n\nsudo swapon swapfile\n\n\n\n# 再次查看虚拟内存（执行命令可以看到新增了2G）\n\nfree\n\n\n\n# 如果需要释放的话（执行命令后，删除创建的swap目录即可）\n\nsudo swapoff swapfile\n\n\n\n# 如果需要开机自动使用该虚拟内存的话，则需要加入到启动脚本\n\n打开 /etc/fstab 文件\n\nvi /etc/fstab\n\n\n此时开的虚拟内存会在开机后消失,如果永久保持下去,在 /etc/fstab 文件尾添加一下信息:\n\n/swap/swapfile swap swap defaults 0 0\n",normalizedContent:"提示\n\n该操作流程采用 ubuntu 20.04 操作系统，debain 如无 sudo 命令则可以去掉即可\n\n\n# 查看虚拟内存\n\nfree\n\n\n\n# 创建虚拟内存配置文件\n\n新建文件夹\n\nmkdir /swap\n\n\n进入文件夹\n\ncd /swap\n\n\n创建虚拟文件，bs 为块的大小，count 创建多少个块\n\nsudo dd if=/dev/zero of=swapfile bs=1m count=2048\n\n\n修改权限\n\nsudo chmod 0600 swapfile\n\n\n把生成的文件转换成 swap 文件\n\nsudo mkswap swapfile\n\n\n激活文件\n\nsudo swapon swapfile\n\n\n\n# 再次查看虚拟内存（执行命令可以看到新增了2g）\n\nfree\n\n\n\n# 如果需要释放的话（执行命令后，删除创建的swap目录即可）\n\nsudo swapoff swapfile\n\n\n\n# 如果需要开机自动使用该虚拟内存的话，则需要加入到启动脚本\n\n打开 /etc/fstab 文件\n\nvi /etc/fstab\n\n\n此时开的虚拟内存会在开机后消失,如果永久保持下去,在 /etc/fstab 文件尾添加一下信息:\n\n/swap/swapfile swap swap defaults 0 0\n",charsets:{cjk:!0},lastUpdated:"2022/10/26, 17:37:27",lastUpdatedTimestamp:1666777047e3},{title:"科学上网",frontmatter:{title:"科学上网",date:"2022-09-20T14:05:32.000Z",permalink:"/pages/678b57/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/04.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html",relativePath:"97.笔记/04.科学上网.md",key:"v-e42fc402",path:"/pages/678b57/",headers:[{level:2,title:"V2Ray",slug:"v2ray",normalizedTitle:"v2ray",charIndex:2},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:12},{level:3,title:"开启BBR",slug:"开启bbr",normalizedTitle:"开启bbr",charIndex:64},{level:3,title:"安装BBR（上一步，如果内核自带可成功开启，无则执行脚本安装）",slug:"安装bbr-上一步-如果内核自带可成功开启-无则执行脚本安装",normalizedTitle:"安装bbr（上一步，如果内核自带可成功开启，无则执行脚本安装）",charIndex:86},{level:3,title:"生成链接",slug:"生成链接",normalizedTitle:"生成链接",charIndex:259},{level:3,title:"命令大全",slug:"命令大全",normalizedTitle:"命令大全",charIndex:280}],headersStr:"V2Ray 安装 开启BBR 安装BBR（上一步，如果内核自带可成功开启，无则执行脚本安装） 生成链接 命令大全",content:'# V2Ray\n\n\n# 安装\n\nbash <(curl -s -L https://git.io/v2ray.sh)\n\n\n\n# 开启BBR\n\nv2ray bbr\n\n\n\n# 安装BBR（上一步，如果内核自带可成功开启，无则执行脚本安装）\n\nwget -N --no-check-certificate "https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh" && chmod +x tcp.sh && ./tcp.sh\n\n\n\n# 生成链接\n\nv2ray url\n\n\n\n# 命令大全\n\n# 查看 V2Ray 配置信息\nv2ray info\n\n# 修改 V2Ray 配置（同 v2ray 效果一样）\nv2ray config\n\n# 生成 V2Ray 配置文件链接\nv2ray link\n\n# 生成 V2Ray 配置信息链接\nv2ray infolink\n\n# 生成 V2Ray 配置二维码链接\nv2ray qr\n\n# 修改 Shadowsocks 配置\nv2ray ss\n\n# 查看 Shadowsocks 配置信息\nv2ray ssinfo\n\n# 生成 Shadowsocks 配置二维码链接\nv2ray ssqr\n\n# 查看 V2Ray 运行状态\nv2ray status\n\n# 启动 V2Ray\nv2ray start\n\n# 停止 V2Ray\nv2ray stop\n\n# 重启 V2Ray\nv2ray restart\n\n# 查看 V2Ray 运行日志\nv2ray log\n\n# 更新 V2Ray\nv2ray update\n\n# 更新 V2Ray 管理脚本\nv2ray update.sh\n\n# 卸载 V2Ray\nv2ray uninstall\n',normalizedContent:'# v2ray\n\n\n# 安装\n\nbash <(curl -s -l https://git.io/v2ray.sh)\n\n\n\n# 开启bbr\n\nv2ray bbr\n\n\n\n# 安装bbr（上一步，如果内核自带可成功开启，无则执行脚本安装）\n\nwget -n --no-check-certificate "https://raw.githubusercontent.com/chiakge/linux-netspeed/master/tcp.sh" && chmod +x tcp.sh && ./tcp.sh\n\n\n\n# 生成链接\n\nv2ray url\n\n\n\n# 命令大全\n\n# 查看 v2ray 配置信息\nv2ray info\n\n# 修改 v2ray 配置（同 v2ray 效果一样）\nv2ray config\n\n# 生成 v2ray 配置文件链接\nv2ray link\n\n# 生成 v2ray 配置信息链接\nv2ray infolink\n\n# 生成 v2ray 配置二维码链接\nv2ray qr\n\n# 修改 shadowsocks 配置\nv2ray ss\n\n# 查看 shadowsocks 配置信息\nv2ray ssinfo\n\n# 生成 shadowsocks 配置二维码链接\nv2ray ssqr\n\n# 查看 v2ray 运行状态\nv2ray status\n\n# 启动 v2ray\nv2ray start\n\n# 停止 v2ray\nv2ray stop\n\n# 重启 v2ray\nv2ray restart\n\n# 查看 v2ray 运行日志\nv2ray log\n\n# 更新 v2ray\nv2ray update\n\n# 更新 v2ray 管理脚本\nv2ray update.sh\n\n# 卸载 v2ray\nv2ray uninstall\n',charsets:{cjk:!0},lastUpdated:"2022/11/09, 14:29:45",lastUpdatedTimestamp:1667975385e3},{title:"基于Maven打包独立jar",frontmatter:{title:"基于Maven打包独立jar",date:"2022-12-01T16:10:22.000Z",permalink:"/pages/1e1742/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/05.%E5%9F%BA%E4%BA%8EMaven%E6%89%93%E5%8C%85%E7%8B%AC%E7%AB%8Bjar.html",relativePath:"97.笔记/05.基于Maven打包独立jar.md",key:"v-5e941770",path:"/pages/1e1742/",headersStr:null,content:"提示\n\n基于 Java8 测试通过，修改mainClass为实际主函数类即可\n\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-assembly-plugin</artifactId>\n      <version>3.4.2</version>\n      <executions>\n        <execution>\n          <phase>package</phase>\n          <goals>\n            <goal>single</goal>\n          </goals>\n          <configuration>\n            <archive>\n              <manifest>\n                <mainClass>\n                  org.example.App\n                </mainClass>\n              </manifest>\n            </archive>\n            <descriptorRefs>\n              <descriptorRef>jar-with-dependencies</descriptorRef>\n            </descriptorRefs>\n          </configuration>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n",normalizedContent:"提示\n\n基于 java8 测试通过，修改mainclass为实际主函数类即可\n\n<build>\n  <plugins>\n    <plugin>\n      <groupid>org.apache.maven.plugins</groupid>\n      <artifactid>maven-assembly-plugin</artifactid>\n      <version>3.4.2</version>\n      <executions>\n        <execution>\n          <phase>package</phase>\n          <goals>\n            <goal>single</goal>\n          </goals>\n          <configuration>\n            <archive>\n              <manifest>\n                <mainclass>\n                  org.example.app\n                </mainclass>\n              </manifest>\n            </archive>\n            <descriptorrefs>\n              <descriptorref>jar-with-dependencies</descriptorref>\n            </descriptorrefs>\n          </configuration>\n        </execution>\n      </executions>\n    </plugin>\n  </plugins>\n</build>\n",charsets:{cjk:!0},lastUpdated:"2022/12/01, 16:15:19",lastUpdatedTimestamp:1669882519e3},{title:"ubuntu server 20.04 设置root用户登录",frontmatter:{title:"ubuntu server 20.04 设置root用户登录",date:"2022-12-21T10:45:39.000Z",permalink:"/pages/501eec/"},regularPath:"/97.%E7%AC%94%E8%AE%B0/06.ubuntu%20server%2020.04%20%E8%AE%BE%E7%BD%AEroot%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.html",relativePath:"97.笔记/06.ubuntu server 20.04 设置root用户登录.md",key:"v-174c68ca",path:"/pages/501eec/",headersStr:null,content:"# 1.设置root密码，已设置的可以往下走\n\nsudo passwd root\n\n\n\n# 2.修改文件\n\nsudo vi /etc/ssh/sshd_config\n\n\n把 PermitRootLogin without-password 改为 PermitRootLogin yes，注意PermitRootLogin without-password可能被注释掉了，要去掉注释 PS：如果2021.06后的20版本没有找到PermitRootLogin without-password，直接文件末尾添加PermitRootLogin yes即可\n\n\n# 3.重启sshd服务\n\nsudo systemctl restart sshd\n",normalizedContent:"# 1.设置root密码，已设置的可以往下走\n\nsudo passwd root\n\n\n\n# 2.修改文件\n\nsudo vi /etc/ssh/sshd_config\n\n\n把 permitrootlogin without-password 改为 permitrootlogin yes，注意permitrootlogin without-password可能被注释掉了，要去掉注释 ps：如果2021.06后的20版本没有找到permitrootlogin without-password，直接文件末尾添加permitrootlogin yes即可\n\n\n# 3.重启sshd服务\n\nsudo systemctl restart sshd\n",charsets:{cjk:!0},lastUpdated:"2022/12/21, 10:56:29",lastUpdatedTimestamp:1671591389e3},{title:"站点清单",frontmatter:{title:"站点清单",date:"2022-06-22T15:54:43.000Z",permalink:"/pages/20d224/"},regularPath:"/98.%E4%B9%A6%E7%AD%BE/01.%E8%B5%84%E6%BA%90%E7%AB%99%E7%82%B9.html",relativePath:"98.书签/01.资源站点.md",key:"v-35524cbe",path:"/pages/20d224/",headers:[{level:2,title:"资源导航",slug:"资源导航",normalizedTitle:"资源导航",charIndex:2},{level:2,title:"书籍类",slug:"书籍类",normalizedTitle:"书籍类",charIndex:84},{level:2,title:"资源搜索",slug:"资源搜索",normalizedTitle:"资源搜索",charIndex:343},{level:2,title:"设计资源搜索",slug:"设计资源搜索",normalizedTitle:"设计资源搜索",charIndex:551},{level:2,title:"视频解析",slug:"视频解析",normalizedTitle:"视频解析",charIndex:588}],headersStr:"资源导航 书籍类 资源搜索 设计资源搜索 视频解析",content:"# 资源导航\n\n * 不死鸟 - 定期分享有趣资源\n * 翻翻墙导航 - 资源导航\n * 迷鹿导航 - 注重挖掘优质资源，包括各种实用工具、优秀软件、好站酷站\n\n\n# 书籍类\n\n * ZLibary - 全球最大的数字图书馆（需要)\n * Z-Library 中文书搜索引擎 - 这是一个 IPFS 网络的 Z-Library 中文书籍目录索引，类似一个小型的搜索引擎吧，不储存资源，所有资源均是在 IPFS 网络中寻找并下载\n * 书栈网 - 书栈网程序员IT互联网开源编程书籍免费阅读与下载\n * 知搜 - 一个书籍辅助搜索的工具\n * 鸠摩搜书 - 一个书籍辅助搜索的工具\n * 书享家 - 一个书籍搜索的工具，资源度不理想，但提供现有一些资源站点列表，资源好坏自行斟酌\n\n\n# 资源搜索\n\n * MacWk - 收录精品Mac应用，每款Mac应用都经过MacWk严格测试后发布，确保应用可以和正版软件一样稳定运行使用\n * y2meta - 下载YouTube的视频和音频（需要)\n * Loader - 下载YouTube的视频和音频（需要)\n * idope - 磁力搜索资源站点（需要)\n * 吃力网 - 磁力搜索资源站点（需要)\n * 橘子盘搜 - 网盘资源搜索，网站风格简约\n\n\n# 设计资源搜索\n\n * iconfont - 阿里巴巴在线矢量图库\n\n\n# 视频解析\n\n * 夜雨聆风 - 免VIP会员无广告追剧",normalizedContent:"# 资源导航\n\n * 不死鸟 - 定期分享有趣资源\n * 翻翻墙导航 - 资源导航\n * 迷鹿导航 - 注重挖掘优质资源，包括各种实用工具、优秀软件、好站酷站\n\n\n# 书籍类\n\n * zlibary - 全球最大的数字图书馆（需要)\n * z-library 中文书搜索引擎 - 这是一个 ipfs 网络的 z-library 中文书籍目录索引，类似一个小型的搜索引擎吧，不储存资源，所有资源均是在 ipfs 网络中寻找并下载\n * 书栈网 - 书栈网程序员it互联网开源编程书籍免费阅读与下载\n * 知搜 - 一个书籍辅助搜索的工具\n * 鸠摩搜书 - 一个书籍辅助搜索的工具\n * 书享家 - 一个书籍搜索的工具，资源度不理想，但提供现有一些资源站点列表，资源好坏自行斟酌\n\n\n# 资源搜索\n\n * macwk - 收录精品mac应用，每款mac应用都经过macwk严格测试后发布，确保应用可以和正版软件一样稳定运行使用\n * y2meta - 下载youtube的视频和音频（需要)\n * loader - 下载youtube的视频和音频（需要)\n * idope - 磁力搜索资源站点（需要)\n * 吃力网 - 磁力搜索资源站点（需要)\n * 橘子盘搜 - 网盘资源搜索，网站风格简约\n\n\n# 设计资源搜索\n\n * iconfont - 阿里巴巴在线矢量图库\n\n\n# 视频解析\n\n * 夜雨聆风 - 免vip会员无广告追剧",charsets:{cjk:!0},lastUpdated:"2022/11/09, 14:29:45",lastUpdatedTimestamp:1667975385e3},{title:"常用工具",frontmatter:{title:"常用工具",date:"2022-06-22T15:55:47.000Z",permalink:"/pages/8cbb5d/"},regularPath:"/98.%E4%B9%A6%E7%AD%BE/02.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7.html",relativePath:"98.书签/02.常用工具.md",key:"v-3ec4edea",path:"/pages/8cbb5d/",headers:[{level:2,title:"图床&文件存储",slug:"图床-文件存储",normalizedTitle:"图床&amp;文件存储",charIndex:null},{level:2,title:"编程工具",slug:"编程工具",normalizedTitle:"编程工具",charIndex:82},{level:2,title:"生产力工具",slug:"生产力工具",normalizedTitle:"生产力工具",charIndex:162},{level:2,title:"格式工具",slug:"格式工具",normalizedTitle:"格式工具",charIndex:537},{level:2,title:"网络工具",slug:"网络工具",normalizedTitle:"网络工具",charIndex:645},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:705},{level:2,title:"有用的软件",slug:"有用的软件",normalizedTitle:"有用的软件",charIndex:738}],headersStr:"图床&文件存储 编程工具 生产力工具 格式工具 网络工具 图片工具 有用的软件",content:"# 图床&文件存储\n\n * eDocss - 是一款不限制文件类型和数量的存储站点，简单易用\n * backblaze - 普通用户拥有 10G 免费存储\n\n\n# 编程工具\n\n * CodeToImage - 把代码转成精美的图片形式\n * https://carbon.now.sh - 把代码转成精美的图片形式\n\n\n# 生产力工具\n\n * uTools - 新一代效率工具平台，自由组合插件应用，打造专属你的趁手工具集\n * GitMind - 是一款全平台思维导图软件，集头脑风暴、思想共创、规划、构建、管理、决策、沉淀等功能于一体，安放闪念、激发心流\n * Photopea - 是一款无需下载Photoshop，在线设计工具，无需安装即可体验大部分PS功能\n * MasterGo - 是一款面向团队的专业 UI/UX 设计工具，多人同时编辑、随时在线评审、设计一键交付，让想法更快实现\n * 网易见外 - 是一款免费提供音视频、文档、图片翻译等实用功能\n * jq22 - 提供在线文本差异对比（提供一些使用在线工具）\n * JSON - 简洁美观的JSON在线解析工具\n * 在线工具合集 - 一个丰富的在线工具合集网站\n * 记灵 - 在线工具合集\n\n\n# 格式工具\n\n * CloudConvert - 是一个在线文件转换器（提供丰富的格式转换）\n * Smallpdf - 是一款简单易用的PDF格式转换网站\n * 格式工厂 - 是一款老牌的音视频格式转换工具\n\n\n# 网络工具\n\n * frp - 是一款简单、高效的内网穿透工具\n * natapp - 是一款免费的内网穿透工具\n\n\n# 图片工具\n\n * removebg - 图片背景消除工具\n\n\n# 有用的软件\n\n * Moo0 - 提供简单和有用的软件来使我们的日常电脑使用更容易",normalizedContent:"# 图床&文件存储\n\n * edocss - 是一款不限制文件类型和数量的存储站点，简单易用\n * backblaze - 普通用户拥有 10g 免费存储\n\n\n# 编程工具\n\n * codetoimage - 把代码转成精美的图片形式\n * https://carbon.now.sh - 把代码转成精美的图片形式\n\n\n# 生产力工具\n\n * utools - 新一代效率工具平台，自由组合插件应用，打造专属你的趁手工具集\n * gitmind - 是一款全平台思维导图软件，集头脑风暴、思想共创、规划、构建、管理、决策、沉淀等功能于一体，安放闪念、激发心流\n * photopea - 是一款无需下载photoshop，在线设计工具，无需安装即可体验大部分ps功能\n * mastergo - 是一款面向团队的专业 ui/ux 设计工具，多人同时编辑、随时在线评审、设计一键交付，让想法更快实现\n * 网易见外 - 是一款免费提供音视频、文档、图片翻译等实用功能\n * jq22 - 提供在线文本差异对比（提供一些使用在线工具）\n * json - 简洁美观的json在线解析工具\n * 在线工具合集 - 一个丰富的在线工具合集网站\n * 记灵 - 在线工具合集\n\n\n# 格式工具\n\n * cloudconvert - 是一个在线文件转换器（提供丰富的格式转换）\n * smallpdf - 是一款简单易用的pdf格式转换网站\n * 格式工厂 - 是一款老牌的音视频格式转换工具\n\n\n# 网络工具\n\n * frp - 是一款简单、高效的内网穿透工具\n * natapp - 是一款免费的内网穿透工具\n\n\n# 图片工具\n\n * removebg - 图片背景消除工具\n\n\n# 有用的软件\n\n * moo0 - 提供简单和有用的软件来使我们的日常电脑使用更容易",charsets:{cjk:!0},lastUpdated:"2022/12/01, 16:15:19",lastUpdatedTimestamp:1669882519e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-717c1b47",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"技术社区&博客",frontmatter:{title:"技术社区&博客",date:"2022-06-22T15:56:01.000Z",permalink:"/pages/0b60af/"},regularPath:"/98.%E4%B9%A6%E7%AD%BE/03.%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA&%E5%8D%9A%E5%AE%A2.html",relativePath:"98.书签/03.技术社区&博客.md",key:"v-76db8340",path:"/pages/0b60af/",headers:[{level:2,title:"技术社区",slug:"技术社区",normalizedTitle:"技术社区",charIndex:2},{level:2,title:"个人博客",slug:"个人博客",normalizedTitle:"个人博客",charIndex:218},{level:2,title:"Go 相关",slug:"go-相关",normalizedTitle:"go 相关",charIndex:464}],headersStr:"技术社区 个人博客 Go 相关",content:"# 技术社区\n\n * 编程导航 - 内容丰富的编程资源导航网站\n * 力扣 - 全球极客挚爱的技术成长平台\n * stackoverflow - 是一个IT问答网站\n * 思否 - 中国领先的开发者技术社区\n * Spring4All - Spring技术社区\n * 编程字典 - 提供在线学习编程的网站，网站提供丰富的编程学习内容\n * 菜鸟教程 - 一个适合初学者入门编程的网站\n * 并发编程网 - 让天下没有难学的技术\n\n\n# 个人博客\n\n * Java 全栈知识体系 - 以Java开发为背景，全栈开发的知识库，告别碎片化学习，帮助你构筑你自己的知识体系\n * Java 工程师成神之路 - 个人整理的Java编程知识\n * PassJava - 个人整理的Java编程知识\n * JavaGuide - 一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide\n * 技术文章摘抄 - 以Java为背景的一些技术文章，也有部分Go基础讲解，以及分布式和软件工程等\n\n\n# Go 相关\n\n * Go 语言中文文档 - Go 语言编程知识网站\n * 地鼠文档 - Go 语言编程资源导航网站\n * 面向信仰编程 - 以 Go 开发为背景的个人技术博客",normalizedContent:"# 技术社区\n\n * 编程导航 - 内容丰富的编程资源导航网站\n * 力扣 - 全球极客挚爱的技术成长平台\n * stackoverflow - 是一个it问答网站\n * 思否 - 中国领先的开发者技术社区\n * spring4all - spring技术社区\n * 编程字典 - 提供在线学习编程的网站，网站提供丰富的编程学习内容\n * 菜鸟教程 - 一个适合初学者入门编程的网站\n * 并发编程网 - 让天下没有难学的技术\n\n\n# 个人博客\n\n * java 全栈知识体系 - 以java开发为背景，全栈开发的知识库，告别碎片化学习，帮助你构筑你自己的知识体系\n * java 工程师成神之路 - 个人整理的java编程知识\n * passjava - 个人整理的java编程知识\n * javaguide - 一份涵盖大部分 java 程序员所需要掌握的核心知识。准备 java 面试，首选 javaguide\n * 技术文章摘抄 - 以java为背景的一些技术文章，也有部分go基础讲解，以及分布式和软件工程等\n\n\n# go 相关\n\n * go 语言中文文档 - go 语言编程知识网站\n * 地鼠文档 - go 语言编程资源导航网站\n * 面向信仰编程 - 以 go 开发为背景的个人技术博客",charsets:{cjk:!0},lastUpdated:"2022/11/09, 14:29:45",lastUpdatedTimestamp:1667975385e3},{title:"关于 - 我",frontmatter:{title:"关于 - 我",date:"2022-06-24T16:15:33.000Z",permalink:"/pages/1b5e98/"},regularPath:"/99.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E%20-%20%E6%88%91.html",relativePath:"99.关于/01.关于/01.关于 - 我.md",key:"v-4afa064f",path:"/pages/1b5e98/",headers:[{level:2,title:"关于 - 我",slug:"关于-我",normalizedTitle:"关于 - 我",charIndex:2}],headersStr:"关于 - 我",content:"# 关于 - 我\n\n一个持续爬坑的小菜鸟！",normalizedContent:"# 关于 - 我\n\n一个持续爬坑的小菜鸟！",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"关于 - 本站",frontmatter:{title:"关于 - 本站",date:"2022-06-24T16:18:37.000Z",permalink:"/pages/860e31/"},regularPath:"/99.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E/02.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99.html",relativePath:"99.关于/01.关于/02.关于 - 本站.md",key:"v-7dee37d9",path:"/pages/860e31/",headers:[{level:2,title:"关于 - 本站",slug:"关于-本站",normalizedTitle:"关于 - 本站",charIndex:2}],headersStr:"关于 - 本站",content:"# 关于 - 本站\n\n这就是个知识和资源搬运的网站，主要是整合零碎知识，将其结构化，方便阅读和学习。",normalizedContent:"# 关于 - 本站\n\n这就是个知识和资源搬运的网站，主要是整合零碎知识，将其结构化，方便阅读和学习。",charsets:{cjk:!0},lastUpdated:"2022/09/16, 16:44:43",lastUpdatedTimestamp:1663317883e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/home.gif",heroText:"备忘录",tagline:"🚀嘿！我是@ZhcChen，这是我写的一些小抄。",actionText:"立即进入 →",actionLink:"/pages/d9e60d/",bannerBg:"none",postList:"none",features:[{title:"知识整理",details:"遨游在知识的海洋里，最容易溺水（主要是人老了，容易忘事，有些东西用的少了，就容易想不起来）"},{title:"简洁高效",details:"以 Markdown 为中心的项目结构，层层目录结构清晰，使阅读的心情更加舒畅"},{title:"沉浸式阅读",details:"专为阅读设计的UI，配合多种颜色模式(右下角换肤)、可关闭的侧边栏和导航栏，带给你一种沉浸式阅读体验"}]},regularPath:"/",relativePath:"index.md",key:"v-15fce9f3",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/12/01, 10:35:16",lastUpdatedTimestamp:1669862116e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"工具",items:[{text:"Docker",link:"/pages/f2e32e/"}]},{text:"笔记",link:"/pages/d9e60d/"},{text:"书签",link:"/pages/20d224/"}],sidebarDepth:2,logo:"/img/logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/0101.Java 核心知识/":[{title:"Java 基础知识",collapsable:!1,children:[["01.Java 基础知识/00.Java开发环境.md","Java 开发环境","/pages/7daf0d/"],["01.Java 基础知识/01.Java基础语法.md","Java 基础语法特性","/pages/2950ba/"],["01.Java 基础知识/02.Java基本数据类型.md","深入理解 Java 基本数据类型","/pages/55d693/"],["01.Java 基础知识/03.Java面向对象.md","Java 面向对象","/pages/3e1661/"],["01.Java 基础知识/04.Java方法.md","深入理解 Java 方法","/pages/7a3ffc/"],["01.Java 基础知识/05.Java数组.md","深入理解 Java 数组","/pages/155518/"],["01.Java 基础知识/06.Java枚举.md","深入理解 Java 枚举","/pages/979887/"],["01.Java 基础知识/07.Java控制语句.md","Java 控制语句","/pages/fb4f8c/"],["01.Java 基础知识/08.Java异常.md","深入理解 Java 异常","/pages/37415c/"],["01.Java 基础知识/09.Java泛型.md","深入理解 Java 泛型","/pages/33a820/"],["01.Java 基础知识/10.Java反射.md","深入理解 Java 反射和动态代理","/pages/0d066a/"],["01.Java 基础知识/11.Java注解.md","深入理解 Java 注解","/pages/ecc011/"],["01.Java 基础知识/42.JavaString类型.md","深入理解 Java String 类型","/pages/bc583c/"],["01.Java 基础知识/99.参考和来源.md","参考和来源","/pages/47aa52/"]]}],catalogue:{},"/0102.Java 版本特性/":[{title:"Java 8 新特性",collapsable:!1,children:[["01.Java 8 新特性/01.Overview.md","Overview","/pages/7ea877/"],["01.Java 8 新特性/02.Lambda 表达式.md","Lambda 表达式","/pages/81ea3b/"],["01.Java 8 新特性/03.Optional.md","Optional","/pages/ce7867/"]]}],"/0103.JVM 相关/":[{title:"Java 类加载机制",collapsable:!1,children:[["01.Java 类加载机制/01.Overview.md","Overview","/pages/bece42/"]]}],"/02.算法/":[{title:"算法基础",collapsable:!1,children:[["01.算法基础/01.数据结构.md","数据结构","/pages/cef328/"]]}],"/0201.速查表/":[["01.速查表.md","速查表","/pages/1b68b5/"],["0200001.Shell.md","Shell","/pages/5bc7d8/"],["0200003.Go.md","Go","/pages/918089/"]],"/0303.开发 - 代码设计/":[{title:"设计模式",collapsable:!1,children:[["01.设计模式/00.介绍.md","介绍","/pages/17da4a/"],["01.设计模式/01.单例模式.md","单例模式","/pages/6278f7/"],["01.设计模式/02.工厂模式.md","工厂模式","/pages/48ae87/"],["01.设计模式/03.建造者模式.md","建造者模式","/pages/ea53e7/"]]}],"/0501.工具-开发工具/":[{title:"开发工具",collapsable:!1,children:[["01.开发工具/01.Overview.md","Overview","/pages/422210/"]]}],"/0502.工具-Git/":[{title:"Git",collapsable:!1,children:[["01.Git/01.Overview.md","Overview","/pages/30becd/"]]}],"/0601.编程语言 - Dart/":[{title:"Dart",collapsable:!1,children:[["01.Dart/01.环境搭建.md","环境搭建","/pages/e71389/"],["01.Dart/02.变量.md","变量","/pages/b214ca/"],["01.Dart/03.类型.md","类型","/pages/e07dc6/"]]}],"/96.工具/":[{title:"Docker",collapsable:!1,children:[["01.Docker/01.介绍.md","介绍","/pages/f2e32e/"],["01.Docker/02.快速上手.md","快速上手","/pages/abbe88/"],["01.Docker/03.Docker 镜像.md","Docker 镜像","/pages/6b922f/"],["01.Docker/04.Docker 容器.md","Docker 容器","/pages/7e5b28/"],["01.Docker/05.Dockerfile.md","Dockerfile","/pages/571205/"],["01.Docker/06.Docker compose.md","Docker compose","/pages/ee7caf/"],["01.Docker/99.玩转Docker.md","玩转Docker","/pages/c6bb18/"]]}],"/97.笔记/":[["01.SSL 证书申请.md","SSL 证书申请","/pages/d9e60d/"],["02.Postgresql 安装和访问.md","Postgresql 安装和访问","/pages/71a585/"],["03.Linux 设置虚拟内存.md","Linux 设置虚拟内存","/pages/64f05e/"],["04.科学上网.md","科学上网","/pages/678b57/"],["05.基于Maven打包独立jar.md","基于Maven打包独立jar","/pages/1e1742/"],["06.ubuntu server 20.04 设置root用户登录.md","ubuntu server 20.04 设置root用户登录","/pages/501eec/"]],"/98.书签/":[["01.资源站点.md","站点清单","/pages/20d224/"],["02.常用工具.md","常用工具","/pages/8cbb5d/"],["03.技术社区&博客.md","技术社区&博客","/pages/0b60af/"]],"/99.关于/":[{title:"关于",collapsable:!1,children:[["01.关于/01.关于 - 我.md","关于 - 我","/pages/1b5e98/"],["01.关于/02.关于 - 本站.md","关于 - 本站","/pages/860e31/"]]}]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"ZhcChen",href:"https://github.com/ZhcChen"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"https://mail.qq.com/"},{iconClass:"icon-github",title:"Github",link:"https://github.com/ZhcChen/memo"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:"ZhcChen | MIT License"},htmlModules:{pageT:'\n  <div class="wwads-cn wwads-horizontal page-wwads" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .page-wwads img{\n      width:80px!important;\n    }\n    .wwads-horizontal .wwads-content{\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{\n      line-height:1;\n      flex: 1;\n      height: 100%;\n      display: flex;\n      align-items: center;\n    }\n    .wwads-horizontal .wwads-poweredby, .wwads-vertical .wwads-poweredby{display: none !important;}\n  </style>\n  '}}};var jl=t(95),Sl=t(96),El=t(11);var kl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(El.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(El.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(El.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(El.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(El.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(jl.default),Gt.component(Sl.default);function _l(n){return n.toString().padStart(2,"0")}t(242);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,378))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(243);var Tl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{r||t.afterEach(()=>{var n;n=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const n=document.getElementsByClassName("wwads-cn"),e=document.querySelector(".wwads-content");n[0]&&!e&&(n[0].innerHTML="<style>.wwads-horizontal,.wwads-vertical{background-color:#f4f8fa;padding:5px;min-height:120px;margin-top:20px;box-sizing:border-box;border-radius:3px;font-family:sans-serif;display:flex;min-width:150px;position:relative;overflow:hidden;}.wwads-horizontal{flex-wrap:wrap;justify-content:center}.wwads-vertical{flex-direction:column;align-items:center;padding-bottom:32px}.wwads-horizontal a,.wwads-vertical a{text-decoration:none}.wwads-horizontal .wwads-img,.wwads-vertical .wwads-img{margin:5px}.wwads-horizontal .wwads-content,.wwads-vertical .wwads-content{margin:5px}.wwads-horizontal .wwads-content{flex:130px}.wwads-vertical .wwads-content{margin-top:10px}.wwads-horizontal .wwads-text,.wwads-content .wwads-text{font-size:14px;line-height:1.4;color:#0e1011;-webkit-font-smoothing:antialiased}.wwads-horizontal .wwads-poweredby,.wwads-vertical .wwads-poweredby{display:block;font-size:11px;color:#a6b7bf;margin-top:1em}.wwads-vertical .wwads-poweredby{position:absolute;left:10px;bottom:10px}.wwads-horizontal .wwads-poweredby span,.wwads-vertical .wwads-poweredby span{transition:all 0.2s ease-in-out;margin-left:-1em}.wwads-horizontal .wwads-poweredby span:first-child,.wwads-vertical .wwads-poweredby span:first-child{opacity:0}.wwads-horizontal:hover .wwads-poweredby span,.wwads-vertical:hover .wwads-poweredby span{opacity:1;margin-left:0}.wwads-horizontal .wwads-hide,.wwads-vertical .wwads-hide{position:absolute;right:-23px;bottom:-23px;width:46px;height:46px;border-radius:23px;transition:all 0.3s ease-in-out;cursor:pointer;}.wwads-horizontal .wwads-hide:hover,.wwads-vertical .wwads-hide:hover{background:rgb(0 0 0 /0.05)}.wwads-horizontal .wwads-hide svg,.wwads-vertical .wwads-hide svg{position:absolute;left:10px;top:10px;fill:#a6b7bf}.wwads-horizontal .wwads-hide:hover svg,.wwads-vertical .wwads-hide:hover svg{fill:#3E4546}</style><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-img' target='_blank' rel='nofollow'><img src='https://fastly.jsdelivr.net/gh/xugaoyi/image_store@master/blog/wwads.2a3pidhlh4ys.webp' width='130'></a><div class='wwads-content'><a href='https://wwads.cn/page/whitelist-wwads' class='wwads-text' target='_blank' rel='nofollow'>为了本站的长期运营，请将我们的网站加入广告拦截器的白名单，感谢您的支持！<span style='color: #11a8cd'>如何添加白名单?</span></a><a href='https://wwads.cn/page/end-user-privacy' class='wwads-poweredby' title='万维广告 ～ 让广告更优雅，且有用' target='_blank'><span>万维</span><span>广告</span></a></div><a class='wwads-hide' onclick='parentNode.remove()' title='隐藏广告'><svg xmlns='http://www.w3.org/2000/svg' width='6' height='7'><path d='M.879.672L3 2.793 5.121.672a.5.5 0 11.707.707L3.708 3.5l2.12 2.121a.5.5 0 11-.707.707l-2.12-2.12-2.122 2.12a.5.5 0 11-.707-.707l2.121-2.12L.172 1.378A.5.5 0 01.879.672z'></path></svg></a>")}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout(()=>{const n=document.querySelector(".page-wwads");if(!n)return;const e=n.querySelector(".wwads-hide");e&&(e.onclick=()=>{n.style.display="none"}),"none"===n.style.display&&(n.style.display="flex")},900)})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${_l(n.getUTCMonth()+1)}-${_l(n.getUTCDate())} ${_l(n.getUTCHours())}:${_l(n.getUTCMinutes())}:${_l(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(kl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?de56efa48d87d7d61259a83cf7148633";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],Cl=[];class Il extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Il.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:us});var Ol={install(n){const e=new Il;n.$vuepress=e,n.prototype.$vuepress=e}};function Dl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Al={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Gt.component(e)||Gt.component(e,ss(e)),Gt.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Jl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Pl=(t(244),t(245),Object(bl.a)(Jl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ll={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use(Vo),Gt.use(Ol),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},wl)),Gt.component("Content",Al),Gt.component("ContentSlotsDistributor",zl),Gt.component("OutboundLink",Pl),Gt.component("ClientOnly",Ll),Gt.component("Layout",ls("Layout")),Gt.component("NotFound",ls("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"e2e10d0"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:wl.routerBase||wl.base,t=new Vo({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Dl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Dl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Dl(n,r)?a(r):Dl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Tl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:a,router:t,siteData:wl,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Cl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);